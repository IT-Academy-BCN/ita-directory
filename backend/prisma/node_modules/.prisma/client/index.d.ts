
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/index';
declare const prisma: unique symbol
export type PrismaPromise<A> = Promise<A> & {[prisma]: true}
type UnwrapPromise<P extends any> = P extends Promise<infer R> ? R : P
type UnwrapTuple<Tuple extends readonly unknown[]> = {
  [K in keyof Tuple]: K extends `${number}` ? Tuple[K] extends PrismaPromise<infer X> ? X : UnwrapPromise<Tuple[K]> : UnwrapPromise<Tuple[K]>
};


/**
 * Model user_role
 * 
 */
export type user_role = {
  id: number
  name: string
  admin: boolean
  manager: boolean
  registered: boolean
}

/**
 * Model user_status
 * 
 */
export type user_status = {
  id: number
  name: string
  active: boolean
  pending: boolean
  suspended: boolean
  deleted: boolean
}

/**
 * Model user
 * 
 */
export type user = {
  id: number
  name: string | null
  lastnames: string | null
  email: string
  password: string
  created_at: Date
  updated_at: Date
  user_status_id: number
  user_role_id: number
}

/**
 * Model acces_log
 * 
 */
export type acces_log = {
  id: number
  login: Date
  logout: Date
  user_id: number
}

/**
 * Model recover_password_log
 * 
 */
export type recover_password_log = {
  id: number
  created_at: Date
  password: string
  user_id: number
}

/**
 * Model media
 * 
 */
export type media = {
  id: number
  path: string
  mime_type: string
  file_size: string
  user_id: number
}

/**
 * Model media_meta
 * 
 */
export type media_meta = {
  id: number
  path: string
  mime_type: string
  file_size: string
  media_id: number
  media_type_id: number
}

/**
 * Model media_type
 * 
 */
export type media_type = {
  id: number
  name: string
  thumnail: boolean
  medium: boolean
  large: boolean
  original: boolean
}

/**
 * Model ad_type
 * 
 */
export type ad_type = {
  id: number
  name: string
  house: number
  room: number
  garage: number
  storage: number
  office: number
  warehouse: number
  building: number
  new_building: number
}

/**
 * Model ads
 * 
 */
export type ads = {
  id: number
  user_id: number
  title: string
  description: string
  city: string
  n_rooms: number
  price: number
  square_meters: number
  n_bathrooms: number
  map_lat: Prisma.Decimal
  map_lon: Prisma.Decimal
  ad_type_id: number
}

/**
 * Model level
 * 
 */
export type level = {
  id: number
  name: string
  parent_id: number | null
  level_type_id: number
}

/**
 * Model level_type
 * 
 */
export type level_type = {
  id: number
  name: string
  country: number
  state: number
  city: number
  town: number
  district: number
  neighbourhood: number
}


/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more User_roles
 * const user_roles = await prisma.user_role.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  GlobalReject = 'rejectOnNotFound' extends keyof T
    ? T['rejectOnNotFound']
    : false
      > {
      /**
       * @private
       */
      private fetcher;
      /**
       * @private
       */
      private readonly dmmf;
      /**
       * @private
       */
      private connectionPromise?;
      /**
       * @private
       */
      private disconnectionPromise?;
      /**
       * @private
       */
      private readonly engineConfig;
      /**
       * @private
       */
      private readonly measurePerformance;

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more User_roles
   * const user_roles = await prisma.user_role.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends (U | 'beforeExit')>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : V extends 'beforeExit' ? () => Promise<void> : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): Promise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): Promise<void>;

  /**
   * Add a middleware
   */
  $use(cb: Prisma.Middleware): void

  /**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends PrismaPromise<any>[]>(arg: [...P]): Promise<UnwrapTuple<P>>;


      /**
   * `prisma.user_role`: Exposes CRUD operations for the **user_role** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more User_roles
    * const user_roles = await prisma.user_role.findMany()
    * ```
    */
  get user_role(): Prisma.user_roleDelegate<GlobalReject>;

  /**
   * `prisma.user_status`: Exposes CRUD operations for the **user_status** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more User_statuses
    * const user_statuses = await prisma.user_status.findMany()
    * ```
    */
  get user_status(): Prisma.user_statusDelegate<GlobalReject>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **user** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.userDelegate<GlobalReject>;

  /**
   * `prisma.acces_log`: Exposes CRUD operations for the **acces_log** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Acces_logs
    * const acces_logs = await prisma.acces_log.findMany()
    * ```
    */
  get acces_log(): Prisma.acces_logDelegate<GlobalReject>;

  /**
   * `prisma.recover_password_log`: Exposes CRUD operations for the **recover_password_log** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Recover_password_logs
    * const recover_password_logs = await prisma.recover_password_log.findMany()
    * ```
    */
  get recover_password_log(): Prisma.recover_password_logDelegate<GlobalReject>;

  /**
   * `prisma.media`: Exposes CRUD operations for the **media** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Media
    * const media = await prisma.media.findMany()
    * ```
    */
  get media(): Prisma.mediaDelegate<GlobalReject>;

  /**
   * `prisma.media_meta`: Exposes CRUD operations for the **media_meta** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Media_metas
    * const media_metas = await prisma.media_meta.findMany()
    * ```
    */
  get media_meta(): Prisma.media_metaDelegate<GlobalReject>;

  /**
   * `prisma.media_type`: Exposes CRUD operations for the **media_type** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Media_types
    * const media_types = await prisma.media_type.findMany()
    * ```
    */
  get media_type(): Prisma.media_typeDelegate<GlobalReject>;

  /**
   * `prisma.ad_type`: Exposes CRUD operations for the **ad_type** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Ad_types
    * const ad_types = await prisma.ad_type.findMany()
    * ```
    */
  get ad_type(): Prisma.ad_typeDelegate<GlobalReject>;

  /**
   * `prisma.ads`: Exposes CRUD operations for the **ads** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Ads
    * const ads = await prisma.ads.findMany()
    * ```
    */
  get ads(): Prisma.adsDelegate<GlobalReject>;

  /**
   * `prisma.level`: Exposes CRUD operations for the **level** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Levels
    * const levels = await prisma.level.findMany()
    * ```
    */
  get level(): Prisma.levelDelegate<GlobalReject>;

  /**
   * `prisma.level_type`: Exposes CRUD operations for the **level_type** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Level_types
    * const level_types = await prisma.level_type.findMany()
    * ```
    */
  get level_type(): Prisma.level_typeDelegate<GlobalReject>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  /**
   * Prisma Client JS version: 3.8.1
   * Query Engine version: 34df67547cf5598f5a6cd3eb45f14ee70c3fb86f
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: 'DbNull'

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: 'JsonNull'

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: 'AnyNull'

  type SelectAndInclude = {
    select: any
    include: any
  }
  type HasSelect = {
    select: any
  }
  type HasInclude = {
    include: any
  }
  type CheckSelect<T, S, U> = T extends SelectAndInclude
    ? 'Please either choose `select` or `include`'
    : T extends HasSelect
    ? U
    : T extends HasInclude
    ? U
    : S

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => Promise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = {
    [key in keyof T]: T[key] extends false | undefined | null ? never : key
  }[keyof T]

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> = (T | U) extends object ? (Without<T, U> & U) | (Without<U, T> & T) : T | U;


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Buffer
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Exact<A, W = unknown> = 
  W extends unknown ? A extends Narrowable ? Cast<A, W> : Cast<
  {[K in keyof A]: K extends keyof W ? Exact<A[K], W[K]> : never},
  {[K in keyof W]: K extends keyof A ? Exact<A[K], W[K]> : W[K]}>
  : never;

  type Narrowable = string | number | boolean | bigint;

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;

  export function validator<V>(): <S>(select: Exact<S, V>) => S;

  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but with an array
   */
  type PickArray<T, K extends Array<keyof T>> = Prisma__Pick<T, TupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T

  class PrismaClientFetcher {
    private readonly prisma;
    private readonly debug;
    private readonly hooks?;
    constructor(prisma: PrismaClient<any, any>, debug?: boolean, hooks?: Hooks | undefined);
    request<T>(document: any, dataPath?: string[], rootField?: string, typeName?: string, isList?: boolean, callsite?: string): Promise<T>;
    sanitizeMessage(message: string): string;
    protected unpack(document: any, data: any, path: string[], rootField?: string, isList?: boolean): any;
  }

  export const ModelName: {
    user_role: 'user_role',
    user_status: 'user_status',
    user: 'user',
    acces_log: 'acces_log',
    recover_password_log: 'recover_password_log',
    media: 'media',
    media_meta: 'media_meta',
    media_type: 'media_type',
    ad_type: 'ad_type',
    ads: 'ads',
    level: 'level',
    level_type: 'level_type'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  export type RejectOnNotFound = boolean | ((error: Error) => Error)
  export type RejectPerModel = { [P in ModelName]?: RejectOnNotFound }
  export type RejectPerOperation =  { [P in "findUnique" | "findFirst"]?: RejectPerModel | RejectOnNotFound } 
  type IsReject<T> = T extends true ? True : T extends (err: Error) => Error ? True : False
  export type HasReject<
    GlobalRejectSettings extends Prisma.PrismaClientOptions['rejectOnNotFound'],
    LocalRejectSettings,
    Action extends PrismaAction,
    Model extends ModelName
  > = LocalRejectSettings extends RejectOnNotFound
    ? IsReject<LocalRejectSettings>
    : GlobalRejectSettings extends RejectPerOperation
    ? Action extends keyof GlobalRejectSettings
      ? GlobalRejectSettings[Action] extends boolean
        ? IsReject<GlobalRejectSettings[Action]>
        : GlobalRejectSettings[Action] extends RejectPerModel
        ? Model extends keyof GlobalRejectSettings[Action]
          ? IsReject<GlobalRejectSettings[Action][Model]>
          : False
        : False
      : False
    : IsReject<GlobalRejectSettings>
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'

  export interface PrismaClientOptions {
    /**
     * Configure findUnique/findFirst to throw an error if the query returns null. 
     *  * @example
     * ```
     * // Reject on both findUnique/findFirst
     * rejectOnNotFound: true
     * // Reject only on findFirst with a custom error
     * rejectOnNotFound: { findFirst: (err) => new Error("Custom Error")}
     * // Reject on user.findUnique with a custom error
     * rejectOnNotFound: { findUnique: {User: (err) => new Error("User not found")}}
     * ```
     */
    rejectOnNotFound?: RejectOnNotFound | RejectPerOperation
    /**
     * Overwrites the datasource url from your prisma.schema file
     */
    datasources?: Datasources

    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat

    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: Array<LogLevel | LogDefinition>
  }

  export type Hooks = {
    beforeRequest?: (options: { query: string, path: string[], rootField?: string, typeName?: string, document: any }) => any
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findMany'
    | 'findFirst'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'

  /**
   * These options are being passed in to the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => Promise<T>,
  ) => Promise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined; 
  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type User_roleCountOutputType
   */


  export type User_roleCountOutputType = {
    user: number
  }

  export type User_roleCountOutputTypeSelect = {
    user?: boolean
  }

  export type User_roleCountOutputTypeGetPayload<
    S extends boolean | null | undefined | User_roleCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? User_roleCountOutputType
    : S extends undefined
    ? never
    : S extends User_roleCountOutputTypeArgs
    ?'include' extends U
    ? User_roleCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof User_roleCountOutputType ?User_roleCountOutputType [P]
  : 
     never
  } 
    : User_roleCountOutputType
  : User_roleCountOutputType




  // Custom InputTypes

  /**
   * User_roleCountOutputType without action
   */
  export type User_roleCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the User_roleCountOutputType
     * 
    **/
    select?: User_roleCountOutputTypeSelect | null
  }



  /**
   * Count Type User_statusCountOutputType
   */


  export type User_statusCountOutputType = {
    user: number
  }

  export type User_statusCountOutputTypeSelect = {
    user?: boolean
  }

  export type User_statusCountOutputTypeGetPayload<
    S extends boolean | null | undefined | User_statusCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? User_statusCountOutputType
    : S extends undefined
    ? never
    : S extends User_statusCountOutputTypeArgs
    ?'include' extends U
    ? User_statusCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof User_statusCountOutputType ?User_statusCountOutputType [P]
  : 
     never
  } 
    : User_statusCountOutputType
  : User_statusCountOutputType




  // Custom InputTypes

  /**
   * User_statusCountOutputType without action
   */
  export type User_statusCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the User_statusCountOutputType
     * 
    **/
    select?: User_statusCountOutputTypeSelect | null
  }



  /**
   * Count Type UserCountOutputType
   */


  export type UserCountOutputType = {
    acces_log: number
    recover_password_log: number
    media: number
    ads: number
  }

  export type UserCountOutputTypeSelect = {
    acces_log?: boolean
    recover_password_log?: boolean
    media?: boolean
    ads?: boolean
  }

  export type UserCountOutputTypeGetPayload<
    S extends boolean | null | undefined | UserCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? UserCountOutputType
    : S extends undefined
    ? never
    : S extends UserCountOutputTypeArgs
    ?'include' extends U
    ? UserCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof UserCountOutputType ?UserCountOutputType [P]
  : 
     never
  } 
    : UserCountOutputType
  : UserCountOutputType




  // Custom InputTypes

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     * 
    **/
    select?: UserCountOutputTypeSelect | null
  }



  /**
   * Count Type MediaCountOutputType
   */


  export type MediaCountOutputType = {
    media_meta: number
  }

  export type MediaCountOutputTypeSelect = {
    media_meta?: boolean
  }

  export type MediaCountOutputTypeGetPayload<
    S extends boolean | null | undefined | MediaCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? MediaCountOutputType
    : S extends undefined
    ? never
    : S extends MediaCountOutputTypeArgs
    ?'include' extends U
    ? MediaCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof MediaCountOutputType ?MediaCountOutputType [P]
  : 
     never
  } 
    : MediaCountOutputType
  : MediaCountOutputType




  // Custom InputTypes

  /**
   * MediaCountOutputType without action
   */
  export type MediaCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the MediaCountOutputType
     * 
    **/
    select?: MediaCountOutputTypeSelect | null
  }



  /**
   * Count Type Media_typeCountOutputType
   */


  export type Media_typeCountOutputType = {
    media_meta: number
  }

  export type Media_typeCountOutputTypeSelect = {
    media_meta?: boolean
  }

  export type Media_typeCountOutputTypeGetPayload<
    S extends boolean | null | undefined | Media_typeCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? Media_typeCountOutputType
    : S extends undefined
    ? never
    : S extends Media_typeCountOutputTypeArgs
    ?'include' extends U
    ? Media_typeCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof Media_typeCountOutputType ?Media_typeCountOutputType [P]
  : 
     never
  } 
    : Media_typeCountOutputType
  : Media_typeCountOutputType




  // Custom InputTypes

  /**
   * Media_typeCountOutputType without action
   */
  export type Media_typeCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the Media_typeCountOutputType
     * 
    **/
    select?: Media_typeCountOutputTypeSelect | null
  }



  /**
   * Count Type Ad_typeCountOutputType
   */


  export type Ad_typeCountOutputType = {
    ads: number
  }

  export type Ad_typeCountOutputTypeSelect = {
    ads?: boolean
  }

  export type Ad_typeCountOutputTypeGetPayload<
    S extends boolean | null | undefined | Ad_typeCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? Ad_typeCountOutputType
    : S extends undefined
    ? never
    : S extends Ad_typeCountOutputTypeArgs
    ?'include' extends U
    ? Ad_typeCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof Ad_typeCountOutputType ?Ad_typeCountOutputType [P]
  : 
     never
  } 
    : Ad_typeCountOutputType
  : Ad_typeCountOutputType




  // Custom InputTypes

  /**
   * Ad_typeCountOutputType without action
   */
  export type Ad_typeCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the Ad_typeCountOutputType
     * 
    **/
    select?: Ad_typeCountOutputTypeSelect | null
  }



  /**
   * Count Type LevelCountOutputType
   */


  export type LevelCountOutputType = {
    child: number
  }

  export type LevelCountOutputTypeSelect = {
    child?: boolean
  }

  export type LevelCountOutputTypeGetPayload<
    S extends boolean | null | undefined | LevelCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? LevelCountOutputType
    : S extends undefined
    ? never
    : S extends LevelCountOutputTypeArgs
    ?'include' extends U
    ? LevelCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof LevelCountOutputType ?LevelCountOutputType [P]
  : 
     never
  } 
    : LevelCountOutputType
  : LevelCountOutputType




  // Custom InputTypes

  /**
   * LevelCountOutputType without action
   */
  export type LevelCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the LevelCountOutputType
     * 
    **/
    select?: LevelCountOutputTypeSelect | null
  }



  /**
   * Count Type Level_typeCountOutputType
   */


  export type Level_typeCountOutputType = {
    level: number
  }

  export type Level_typeCountOutputTypeSelect = {
    level?: boolean
  }

  export type Level_typeCountOutputTypeGetPayload<
    S extends boolean | null | undefined | Level_typeCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? Level_typeCountOutputType
    : S extends undefined
    ? never
    : S extends Level_typeCountOutputTypeArgs
    ?'include' extends U
    ? Level_typeCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof Level_typeCountOutputType ?Level_typeCountOutputType [P]
  : 
     never
  } 
    : Level_typeCountOutputType
  : Level_typeCountOutputType




  // Custom InputTypes

  /**
   * Level_typeCountOutputType without action
   */
  export type Level_typeCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the Level_typeCountOutputType
     * 
    **/
    select?: Level_typeCountOutputTypeSelect | null
  }



  /**
   * Models
   */

  /**
   * Model user_role
   */


  export type AggregateUser_role = {
    _count: User_roleCountAggregateOutputType | null
    _avg: User_roleAvgAggregateOutputType | null
    _sum: User_roleSumAggregateOutputType | null
    _min: User_roleMinAggregateOutputType | null
    _max: User_roleMaxAggregateOutputType | null
  }

  export type User_roleAvgAggregateOutputType = {
    id: number | null
  }

  export type User_roleSumAggregateOutputType = {
    id: number | null
  }

  export type User_roleMinAggregateOutputType = {
    id: number | null
    name: string | null
    admin: boolean | null
    manager: boolean | null
    registered: boolean | null
  }

  export type User_roleMaxAggregateOutputType = {
    id: number | null
    name: string | null
    admin: boolean | null
    manager: boolean | null
    registered: boolean | null
  }

  export type User_roleCountAggregateOutputType = {
    id: number
    name: number
    admin: number
    manager: number
    registered: number
    _all: number
  }


  export type User_roleAvgAggregateInputType = {
    id?: true
  }

  export type User_roleSumAggregateInputType = {
    id?: true
  }

  export type User_roleMinAggregateInputType = {
    id?: true
    name?: true
    admin?: true
    manager?: true
    registered?: true
  }

  export type User_roleMaxAggregateInputType = {
    id?: true
    name?: true
    admin?: true
    manager?: true
    registered?: true
  }

  export type User_roleCountAggregateInputType = {
    id?: true
    name?: true
    admin?: true
    manager?: true
    registered?: true
    _all?: true
  }

  export type User_roleAggregateArgs = {
    /**
     * Filter which user_role to aggregate.
     * 
    **/
    where?: user_roleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_roles to fetch.
     * 
    **/
    orderBy?: Enumerable<user_roleOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: user_roleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_roles from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_roles.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned user_roles
    **/
    _count?: true | User_roleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: User_roleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: User_roleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: User_roleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: User_roleMaxAggregateInputType
  }

  export type GetUser_roleAggregateType<T extends User_roleAggregateArgs> = {
        [P in keyof T & keyof AggregateUser_role]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser_role[P]>
      : GetScalarType<T[P], AggregateUser_role[P]>
  }




  export type User_roleGroupByArgs = {
    where?: user_roleWhereInput
    orderBy?: Enumerable<user_roleOrderByWithAggregationInput>
    by: Array<User_roleScalarFieldEnum>
    having?: user_roleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: User_roleCountAggregateInputType | true
    _avg?: User_roleAvgAggregateInputType
    _sum?: User_roleSumAggregateInputType
    _min?: User_roleMinAggregateInputType
    _max?: User_roleMaxAggregateInputType
  }


  export type User_roleGroupByOutputType = {
    id: number
    name: string
    admin: boolean
    manager: boolean
    registered: boolean
    _count: User_roleCountAggregateOutputType | null
    _avg: User_roleAvgAggregateOutputType | null
    _sum: User_roleSumAggregateOutputType | null
    _min: User_roleMinAggregateOutputType | null
    _max: User_roleMaxAggregateOutputType | null
  }

  type GetUser_roleGroupByPayload<T extends User_roleGroupByArgs> = Promise<
    Array<
      PickArray<User_roleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof User_roleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], User_roleGroupByOutputType[P]>
            : GetScalarType<T[P], User_roleGroupByOutputType[P]>
        }
      >
    >


  export type user_roleSelect = {
    id?: boolean
    name?: boolean
    admin?: boolean
    manager?: boolean
    registered?: boolean
    user?: boolean | userFindManyArgs
    _count?: boolean | User_roleCountOutputTypeArgs
  }

  export type user_roleInclude = {
    user?: boolean | userFindManyArgs
    _count?: boolean | User_roleCountOutputTypeArgs
  }

  export type user_roleGetPayload<
    S extends boolean | null | undefined | user_roleArgs,
    U = keyof S
      > = S extends true
        ? user_role
    : S extends undefined
    ? never
    : S extends user_roleArgs | user_roleFindManyArgs
    ?'include' extends U
    ? user_role  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'user'
        ? Array < userGetPayload<S['include'][P]>>  :
        P extends '_count'
        ? User_roleCountOutputTypeGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof user_role ?user_role [P]
  : 
          P extends 'user'
        ? Array < userGetPayload<S['select'][P]>>  :
        P extends '_count'
        ? User_roleCountOutputTypeGetPayload<S['select'][P]> : never
  } 
    : user_role
  : user_role


  type user_roleCountArgs = Merge<
    Omit<user_roleFindManyArgs, 'select' | 'include'> & {
      select?: User_roleCountAggregateInputType | true
    }
  >

  export interface user_roleDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one User_role that matches the filter.
     * @param {user_roleFindUniqueArgs} args - Arguments to find a User_role
     * @example
     * // Get one User_role
     * const user_role = await prisma.user_role.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends user_roleFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, user_roleFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'user_role'> extends True ? CheckSelect<T, Prisma__user_roleClient<user_role>, Prisma__user_roleClient<user_roleGetPayload<T>>> : CheckSelect<T, Prisma__user_roleClient<user_role | null >, Prisma__user_roleClient<user_roleGetPayload<T> | null >>

    /**
     * Find the first User_role that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_roleFindFirstArgs} args - Arguments to find a User_role
     * @example
     * // Get one User_role
     * const user_role = await prisma.user_role.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends user_roleFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, user_roleFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'user_role'> extends True ? CheckSelect<T, Prisma__user_roleClient<user_role>, Prisma__user_roleClient<user_roleGetPayload<T>>> : CheckSelect<T, Prisma__user_roleClient<user_role | null >, Prisma__user_roleClient<user_roleGetPayload<T> | null >>

    /**
     * Find zero or more User_roles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_roleFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all User_roles
     * const user_roles = await prisma.user_role.findMany()
     * 
     * // Get first 10 User_roles
     * const user_roles = await prisma.user_role.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const user_roleWithIdOnly = await prisma.user_role.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends user_roleFindManyArgs>(
      args?: SelectSubset<T, user_roleFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<user_role>>, PrismaPromise<Array<user_roleGetPayload<T>>>>

    /**
     * Create a User_role.
     * @param {user_roleCreateArgs} args - Arguments to create a User_role.
     * @example
     * // Create one User_role
     * const User_role = await prisma.user_role.create({
     *   data: {
     *     // ... data to create a User_role
     *   }
     * })
     * 
    **/
    create<T extends user_roleCreateArgs>(
      args: SelectSubset<T, user_roleCreateArgs>
    ): CheckSelect<T, Prisma__user_roleClient<user_role>, Prisma__user_roleClient<user_roleGetPayload<T>>>

    /**
     * Create many User_roles.
     *     @param {user_roleCreateManyArgs} args - Arguments to create many User_roles.
     *     @example
     *     // Create many User_roles
     *     const user_role = await prisma.user_role.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends user_roleCreateManyArgs>(
      args?: SelectSubset<T, user_roleCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a User_role.
     * @param {user_roleDeleteArgs} args - Arguments to delete one User_role.
     * @example
     * // Delete one User_role
     * const User_role = await prisma.user_role.delete({
     *   where: {
     *     // ... filter to delete one User_role
     *   }
     * })
     * 
    **/
    delete<T extends user_roleDeleteArgs>(
      args: SelectSubset<T, user_roleDeleteArgs>
    ): CheckSelect<T, Prisma__user_roleClient<user_role>, Prisma__user_roleClient<user_roleGetPayload<T>>>

    /**
     * Update one User_role.
     * @param {user_roleUpdateArgs} args - Arguments to update one User_role.
     * @example
     * // Update one User_role
     * const user_role = await prisma.user_role.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends user_roleUpdateArgs>(
      args: SelectSubset<T, user_roleUpdateArgs>
    ): CheckSelect<T, Prisma__user_roleClient<user_role>, Prisma__user_roleClient<user_roleGetPayload<T>>>

    /**
     * Delete zero or more User_roles.
     * @param {user_roleDeleteManyArgs} args - Arguments to filter User_roles to delete.
     * @example
     * // Delete a few User_roles
     * const { count } = await prisma.user_role.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends user_roleDeleteManyArgs>(
      args?: SelectSubset<T, user_roleDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more User_roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_roleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many User_roles
     * const user_role = await prisma.user_role.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends user_roleUpdateManyArgs>(
      args: SelectSubset<T, user_roleUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one User_role.
     * @param {user_roleUpsertArgs} args - Arguments to update or create a User_role.
     * @example
     * // Update or create a User_role
     * const user_role = await prisma.user_role.upsert({
     *   create: {
     *     // ... data to create a User_role
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User_role we want to update
     *   }
     * })
    **/
    upsert<T extends user_roleUpsertArgs>(
      args: SelectSubset<T, user_roleUpsertArgs>
    ): CheckSelect<T, Prisma__user_roleClient<user_role>, Prisma__user_roleClient<user_roleGetPayload<T>>>

    /**
     * Count the number of User_roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_roleCountArgs} args - Arguments to filter User_roles to count.
     * @example
     * // Count the number of User_roles
     * const count = await prisma.user_role.count({
     *   where: {
     *     // ... the filter for the User_roles we want to count
     *   }
     * })
    **/
    count<T extends user_roleCountArgs>(
      args?: Subset<T, user_roleCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], User_roleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User_role.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {User_roleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends User_roleAggregateArgs>(args: Subset<T, User_roleAggregateArgs>): PrismaPromise<GetUser_roleAggregateType<T>>

    /**
     * Group by User_role.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {User_roleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends User_roleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: User_roleGroupByArgs['orderBy'] }
        : { orderBy?: User_roleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, User_roleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUser_roleGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for user_role.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__user_roleClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    user<T extends userFindManyArgs = {}>(args?: Subset<T, userFindManyArgs>): CheckSelect<T, PrismaPromise<Array<user>>, PrismaPromise<Array<userGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * user_role findUnique
   */
  export type user_roleFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the user_role
     * 
    **/
    select?: user_roleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: user_roleInclude | null
    /**
     * Throw an Error if a user_role can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which user_role to fetch.
     * 
    **/
    where: user_roleWhereUniqueInput
  }


  /**
   * user_role findFirst
   */
  export type user_roleFindFirstArgs = {
    /**
     * Select specific fields to fetch from the user_role
     * 
    **/
    select?: user_roleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: user_roleInclude | null
    /**
     * Throw an Error if a user_role can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which user_role to fetch.
     * 
    **/
    where?: user_roleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_roles to fetch.
     * 
    **/
    orderBy?: Enumerable<user_roleOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for user_roles.
     * 
    **/
    cursor?: user_roleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_roles from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_roles.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of user_roles.
     * 
    **/
    distinct?: Enumerable<User_roleScalarFieldEnum>
  }


  /**
   * user_role findMany
   */
  export type user_roleFindManyArgs = {
    /**
     * Select specific fields to fetch from the user_role
     * 
    **/
    select?: user_roleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: user_roleInclude | null
    /**
     * Filter, which user_roles to fetch.
     * 
    **/
    where?: user_roleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_roles to fetch.
     * 
    **/
    orderBy?: Enumerable<user_roleOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing user_roles.
     * 
    **/
    cursor?: user_roleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_roles from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_roles.
     * 
    **/
    skip?: number
    distinct?: Enumerable<User_roleScalarFieldEnum>
  }


  /**
   * user_role create
   */
  export type user_roleCreateArgs = {
    /**
     * Select specific fields to fetch from the user_role
     * 
    **/
    select?: user_roleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: user_roleInclude | null
    /**
     * The data needed to create a user_role.
     * 
    **/
    data: XOR<user_roleCreateInput, user_roleUncheckedCreateInput>
  }


  /**
   * user_role createMany
   */
  export type user_roleCreateManyArgs = {
    data: Enumerable<user_roleCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * user_role update
   */
  export type user_roleUpdateArgs = {
    /**
     * Select specific fields to fetch from the user_role
     * 
    **/
    select?: user_roleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: user_roleInclude | null
    /**
     * The data needed to update a user_role.
     * 
    **/
    data: XOR<user_roleUpdateInput, user_roleUncheckedUpdateInput>
    /**
     * Choose, which user_role to update.
     * 
    **/
    where: user_roleWhereUniqueInput
  }


  /**
   * user_role updateMany
   */
  export type user_roleUpdateManyArgs = {
    data: XOR<user_roleUpdateManyMutationInput, user_roleUncheckedUpdateManyInput>
    where?: user_roleWhereInput
  }


  /**
   * user_role upsert
   */
  export type user_roleUpsertArgs = {
    /**
     * Select specific fields to fetch from the user_role
     * 
    **/
    select?: user_roleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: user_roleInclude | null
    /**
     * The filter to search for the user_role to update in case it exists.
     * 
    **/
    where: user_roleWhereUniqueInput
    /**
     * In case the user_role found by the `where` argument doesn't exist, create a new user_role with this data.
     * 
    **/
    create: XOR<user_roleCreateInput, user_roleUncheckedCreateInput>
    /**
     * In case the user_role was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<user_roleUpdateInput, user_roleUncheckedUpdateInput>
  }


  /**
   * user_role delete
   */
  export type user_roleDeleteArgs = {
    /**
     * Select specific fields to fetch from the user_role
     * 
    **/
    select?: user_roleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: user_roleInclude | null
    /**
     * Filter which user_role to delete.
     * 
    **/
    where: user_roleWhereUniqueInput
  }


  /**
   * user_role deleteMany
   */
  export type user_roleDeleteManyArgs = {
    where?: user_roleWhereInput
  }


  /**
   * user_role without action
   */
  export type user_roleArgs = {
    /**
     * Select specific fields to fetch from the user_role
     * 
    **/
    select?: user_roleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: user_roleInclude | null
  }



  /**
   * Model user_status
   */


  export type AggregateUser_status = {
    _count: User_statusCountAggregateOutputType | null
    _avg: User_statusAvgAggregateOutputType | null
    _sum: User_statusSumAggregateOutputType | null
    _min: User_statusMinAggregateOutputType | null
    _max: User_statusMaxAggregateOutputType | null
  }

  export type User_statusAvgAggregateOutputType = {
    id: number | null
  }

  export type User_statusSumAggregateOutputType = {
    id: number | null
  }

  export type User_statusMinAggregateOutputType = {
    id: number | null
    name: string | null
    active: boolean | null
    pending: boolean | null
    suspended: boolean | null
    deleted: boolean | null
  }

  export type User_statusMaxAggregateOutputType = {
    id: number | null
    name: string | null
    active: boolean | null
    pending: boolean | null
    suspended: boolean | null
    deleted: boolean | null
  }

  export type User_statusCountAggregateOutputType = {
    id: number
    name: number
    active: number
    pending: number
    suspended: number
    deleted: number
    _all: number
  }


  export type User_statusAvgAggregateInputType = {
    id?: true
  }

  export type User_statusSumAggregateInputType = {
    id?: true
  }

  export type User_statusMinAggregateInputType = {
    id?: true
    name?: true
    active?: true
    pending?: true
    suspended?: true
    deleted?: true
  }

  export type User_statusMaxAggregateInputType = {
    id?: true
    name?: true
    active?: true
    pending?: true
    suspended?: true
    deleted?: true
  }

  export type User_statusCountAggregateInputType = {
    id?: true
    name?: true
    active?: true
    pending?: true
    suspended?: true
    deleted?: true
    _all?: true
  }

  export type User_statusAggregateArgs = {
    /**
     * Filter which user_status to aggregate.
     * 
    **/
    where?: user_statusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_statuses to fetch.
     * 
    **/
    orderBy?: Enumerable<user_statusOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: user_statusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_statuses from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_statuses.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned user_statuses
    **/
    _count?: true | User_statusCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: User_statusAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: User_statusSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: User_statusMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: User_statusMaxAggregateInputType
  }

  export type GetUser_statusAggregateType<T extends User_statusAggregateArgs> = {
        [P in keyof T & keyof AggregateUser_status]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser_status[P]>
      : GetScalarType<T[P], AggregateUser_status[P]>
  }




  export type User_statusGroupByArgs = {
    where?: user_statusWhereInput
    orderBy?: Enumerable<user_statusOrderByWithAggregationInput>
    by: Array<User_statusScalarFieldEnum>
    having?: user_statusScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: User_statusCountAggregateInputType | true
    _avg?: User_statusAvgAggregateInputType
    _sum?: User_statusSumAggregateInputType
    _min?: User_statusMinAggregateInputType
    _max?: User_statusMaxAggregateInputType
  }


  export type User_statusGroupByOutputType = {
    id: number
    name: string
    active: boolean
    pending: boolean
    suspended: boolean
    deleted: boolean
    _count: User_statusCountAggregateOutputType | null
    _avg: User_statusAvgAggregateOutputType | null
    _sum: User_statusSumAggregateOutputType | null
    _min: User_statusMinAggregateOutputType | null
    _max: User_statusMaxAggregateOutputType | null
  }

  type GetUser_statusGroupByPayload<T extends User_statusGroupByArgs> = Promise<
    Array<
      PickArray<User_statusGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof User_statusGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], User_statusGroupByOutputType[P]>
            : GetScalarType<T[P], User_statusGroupByOutputType[P]>
        }
      >
    >


  export type user_statusSelect = {
    id?: boolean
    name?: boolean
    active?: boolean
    pending?: boolean
    suspended?: boolean
    deleted?: boolean
    user?: boolean | userFindManyArgs
    _count?: boolean | User_statusCountOutputTypeArgs
  }

  export type user_statusInclude = {
    user?: boolean | userFindManyArgs
    _count?: boolean | User_statusCountOutputTypeArgs
  }

  export type user_statusGetPayload<
    S extends boolean | null | undefined | user_statusArgs,
    U = keyof S
      > = S extends true
        ? user_status
    : S extends undefined
    ? never
    : S extends user_statusArgs | user_statusFindManyArgs
    ?'include' extends U
    ? user_status  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'user'
        ? Array < userGetPayload<S['include'][P]>>  :
        P extends '_count'
        ? User_statusCountOutputTypeGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof user_status ?user_status [P]
  : 
          P extends 'user'
        ? Array < userGetPayload<S['select'][P]>>  :
        P extends '_count'
        ? User_statusCountOutputTypeGetPayload<S['select'][P]> : never
  } 
    : user_status
  : user_status


  type user_statusCountArgs = Merge<
    Omit<user_statusFindManyArgs, 'select' | 'include'> & {
      select?: User_statusCountAggregateInputType | true
    }
  >

  export interface user_statusDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one User_status that matches the filter.
     * @param {user_statusFindUniqueArgs} args - Arguments to find a User_status
     * @example
     * // Get one User_status
     * const user_status = await prisma.user_status.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends user_statusFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, user_statusFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'user_status'> extends True ? CheckSelect<T, Prisma__user_statusClient<user_status>, Prisma__user_statusClient<user_statusGetPayload<T>>> : CheckSelect<T, Prisma__user_statusClient<user_status | null >, Prisma__user_statusClient<user_statusGetPayload<T> | null >>

    /**
     * Find the first User_status that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_statusFindFirstArgs} args - Arguments to find a User_status
     * @example
     * // Get one User_status
     * const user_status = await prisma.user_status.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends user_statusFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, user_statusFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'user_status'> extends True ? CheckSelect<T, Prisma__user_statusClient<user_status>, Prisma__user_statusClient<user_statusGetPayload<T>>> : CheckSelect<T, Prisma__user_statusClient<user_status | null >, Prisma__user_statusClient<user_statusGetPayload<T> | null >>

    /**
     * Find zero or more User_statuses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_statusFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all User_statuses
     * const user_statuses = await prisma.user_status.findMany()
     * 
     * // Get first 10 User_statuses
     * const user_statuses = await prisma.user_status.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const user_statusWithIdOnly = await prisma.user_status.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends user_statusFindManyArgs>(
      args?: SelectSubset<T, user_statusFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<user_status>>, PrismaPromise<Array<user_statusGetPayload<T>>>>

    /**
     * Create a User_status.
     * @param {user_statusCreateArgs} args - Arguments to create a User_status.
     * @example
     * // Create one User_status
     * const User_status = await prisma.user_status.create({
     *   data: {
     *     // ... data to create a User_status
     *   }
     * })
     * 
    **/
    create<T extends user_statusCreateArgs>(
      args: SelectSubset<T, user_statusCreateArgs>
    ): CheckSelect<T, Prisma__user_statusClient<user_status>, Prisma__user_statusClient<user_statusGetPayload<T>>>

    /**
     * Create many User_statuses.
     *     @param {user_statusCreateManyArgs} args - Arguments to create many User_statuses.
     *     @example
     *     // Create many User_statuses
     *     const user_status = await prisma.user_status.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends user_statusCreateManyArgs>(
      args?: SelectSubset<T, user_statusCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a User_status.
     * @param {user_statusDeleteArgs} args - Arguments to delete one User_status.
     * @example
     * // Delete one User_status
     * const User_status = await prisma.user_status.delete({
     *   where: {
     *     // ... filter to delete one User_status
     *   }
     * })
     * 
    **/
    delete<T extends user_statusDeleteArgs>(
      args: SelectSubset<T, user_statusDeleteArgs>
    ): CheckSelect<T, Prisma__user_statusClient<user_status>, Prisma__user_statusClient<user_statusGetPayload<T>>>

    /**
     * Update one User_status.
     * @param {user_statusUpdateArgs} args - Arguments to update one User_status.
     * @example
     * // Update one User_status
     * const user_status = await prisma.user_status.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends user_statusUpdateArgs>(
      args: SelectSubset<T, user_statusUpdateArgs>
    ): CheckSelect<T, Prisma__user_statusClient<user_status>, Prisma__user_statusClient<user_statusGetPayload<T>>>

    /**
     * Delete zero or more User_statuses.
     * @param {user_statusDeleteManyArgs} args - Arguments to filter User_statuses to delete.
     * @example
     * // Delete a few User_statuses
     * const { count } = await prisma.user_status.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends user_statusDeleteManyArgs>(
      args?: SelectSubset<T, user_statusDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more User_statuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_statusUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many User_statuses
     * const user_status = await prisma.user_status.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends user_statusUpdateManyArgs>(
      args: SelectSubset<T, user_statusUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one User_status.
     * @param {user_statusUpsertArgs} args - Arguments to update or create a User_status.
     * @example
     * // Update or create a User_status
     * const user_status = await prisma.user_status.upsert({
     *   create: {
     *     // ... data to create a User_status
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User_status we want to update
     *   }
     * })
    **/
    upsert<T extends user_statusUpsertArgs>(
      args: SelectSubset<T, user_statusUpsertArgs>
    ): CheckSelect<T, Prisma__user_statusClient<user_status>, Prisma__user_statusClient<user_statusGetPayload<T>>>

    /**
     * Count the number of User_statuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_statusCountArgs} args - Arguments to filter User_statuses to count.
     * @example
     * // Count the number of User_statuses
     * const count = await prisma.user_status.count({
     *   where: {
     *     // ... the filter for the User_statuses we want to count
     *   }
     * })
    **/
    count<T extends user_statusCountArgs>(
      args?: Subset<T, user_statusCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], User_statusCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User_status.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {User_statusAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends User_statusAggregateArgs>(args: Subset<T, User_statusAggregateArgs>): PrismaPromise<GetUser_statusAggregateType<T>>

    /**
     * Group by User_status.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {User_statusGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends User_statusGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: User_statusGroupByArgs['orderBy'] }
        : { orderBy?: User_statusGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, User_statusGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUser_statusGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for user_status.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__user_statusClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    user<T extends userFindManyArgs = {}>(args?: Subset<T, userFindManyArgs>): CheckSelect<T, PrismaPromise<Array<user>>, PrismaPromise<Array<userGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * user_status findUnique
   */
  export type user_statusFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the user_status
     * 
    **/
    select?: user_statusSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: user_statusInclude | null
    /**
     * Throw an Error if a user_status can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which user_status to fetch.
     * 
    **/
    where: user_statusWhereUniqueInput
  }


  /**
   * user_status findFirst
   */
  export type user_statusFindFirstArgs = {
    /**
     * Select specific fields to fetch from the user_status
     * 
    **/
    select?: user_statusSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: user_statusInclude | null
    /**
     * Throw an Error if a user_status can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which user_status to fetch.
     * 
    **/
    where?: user_statusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_statuses to fetch.
     * 
    **/
    orderBy?: Enumerable<user_statusOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for user_statuses.
     * 
    **/
    cursor?: user_statusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_statuses from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_statuses.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of user_statuses.
     * 
    **/
    distinct?: Enumerable<User_statusScalarFieldEnum>
  }


  /**
   * user_status findMany
   */
  export type user_statusFindManyArgs = {
    /**
     * Select specific fields to fetch from the user_status
     * 
    **/
    select?: user_statusSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: user_statusInclude | null
    /**
     * Filter, which user_statuses to fetch.
     * 
    **/
    where?: user_statusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_statuses to fetch.
     * 
    **/
    orderBy?: Enumerable<user_statusOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing user_statuses.
     * 
    **/
    cursor?: user_statusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_statuses from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_statuses.
     * 
    **/
    skip?: number
    distinct?: Enumerable<User_statusScalarFieldEnum>
  }


  /**
   * user_status create
   */
  export type user_statusCreateArgs = {
    /**
     * Select specific fields to fetch from the user_status
     * 
    **/
    select?: user_statusSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: user_statusInclude | null
    /**
     * The data needed to create a user_status.
     * 
    **/
    data: XOR<user_statusCreateInput, user_statusUncheckedCreateInput>
  }


  /**
   * user_status createMany
   */
  export type user_statusCreateManyArgs = {
    data: Enumerable<user_statusCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * user_status update
   */
  export type user_statusUpdateArgs = {
    /**
     * Select specific fields to fetch from the user_status
     * 
    **/
    select?: user_statusSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: user_statusInclude | null
    /**
     * The data needed to update a user_status.
     * 
    **/
    data: XOR<user_statusUpdateInput, user_statusUncheckedUpdateInput>
    /**
     * Choose, which user_status to update.
     * 
    **/
    where: user_statusWhereUniqueInput
  }


  /**
   * user_status updateMany
   */
  export type user_statusUpdateManyArgs = {
    data: XOR<user_statusUpdateManyMutationInput, user_statusUncheckedUpdateManyInput>
    where?: user_statusWhereInput
  }


  /**
   * user_status upsert
   */
  export type user_statusUpsertArgs = {
    /**
     * Select specific fields to fetch from the user_status
     * 
    **/
    select?: user_statusSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: user_statusInclude | null
    /**
     * The filter to search for the user_status to update in case it exists.
     * 
    **/
    where: user_statusWhereUniqueInput
    /**
     * In case the user_status found by the `where` argument doesn't exist, create a new user_status with this data.
     * 
    **/
    create: XOR<user_statusCreateInput, user_statusUncheckedCreateInput>
    /**
     * In case the user_status was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<user_statusUpdateInput, user_statusUncheckedUpdateInput>
  }


  /**
   * user_status delete
   */
  export type user_statusDeleteArgs = {
    /**
     * Select specific fields to fetch from the user_status
     * 
    **/
    select?: user_statusSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: user_statusInclude | null
    /**
     * Filter which user_status to delete.
     * 
    **/
    where: user_statusWhereUniqueInput
  }


  /**
   * user_status deleteMany
   */
  export type user_statusDeleteManyArgs = {
    where?: user_statusWhereInput
  }


  /**
   * user_status without action
   */
  export type user_statusArgs = {
    /**
     * Select specific fields to fetch from the user_status
     * 
    **/
    select?: user_statusSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: user_statusInclude | null
  }



  /**
   * Model user
   */


  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    id: number | null
    user_status_id: number | null
    user_role_id: number | null
  }

  export type UserSumAggregateOutputType = {
    id: number | null
    user_status_id: number | null
    user_role_id: number | null
  }

  export type UserMinAggregateOutputType = {
    id: number | null
    name: string | null
    lastnames: string | null
    email: string | null
    password: string | null
    created_at: Date | null
    updated_at: Date | null
    user_status_id: number | null
    user_role_id: number | null
  }

  export type UserMaxAggregateOutputType = {
    id: number | null
    name: string | null
    lastnames: string | null
    email: string | null
    password: string | null
    created_at: Date | null
    updated_at: Date | null
    user_status_id: number | null
    user_role_id: number | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    name: number
    lastnames: number
    email: number
    password: number
    created_at: number
    updated_at: number
    user_status_id: number
    user_role_id: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    id?: true
    user_status_id?: true
    user_role_id?: true
  }

  export type UserSumAggregateInputType = {
    id?: true
    user_status_id?: true
    user_role_id?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    name?: true
    lastnames?: true
    email?: true
    password?: true
    created_at?: true
    updated_at?: true
    user_status_id?: true
    user_role_id?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    name?: true
    lastnames?: true
    email?: true
    password?: true
    created_at?: true
    updated_at?: true
    user_status_id?: true
    user_role_id?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    name?: true
    lastnames?: true
    email?: true
    password?: true
    created_at?: true
    updated_at?: true
    user_status_id?: true
    user_role_id?: true
    _all?: true
  }

  export type UserAggregateArgs = {
    /**
     * Filter which user to aggregate.
     * 
    **/
    where?: userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     * 
    **/
    orderBy?: Enumerable<userOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs = {
    where?: userWhereInput
    orderBy?: Enumerable<userOrderByWithAggregationInput>
    by: Array<UserScalarFieldEnum>
    having?: userScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }


  export type UserGroupByOutputType = {
    id: number
    name: string | null
    lastnames: string | null
    email: string
    password: string
    created_at: Date
    updated_at: Date
    user_status_id: number
    user_role_id: number
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Promise<
    Array<
      PickArray<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type userSelect = {
    id?: boolean
    name?: boolean
    lastnames?: boolean
    email?: boolean
    password?: boolean
    created_at?: boolean
    updated_at?: boolean
    user_status?: boolean | user_statusArgs
    user_status_id?: boolean
    user_role?: boolean | user_roleArgs
    user_role_id?: boolean
    acces_log?: boolean | acces_logFindManyArgs
    recover_password_log?: boolean | recover_password_logFindManyArgs
    media?: boolean | mediaFindManyArgs
    ads?: boolean | adsFindManyArgs
    _count?: boolean | UserCountOutputTypeArgs
  }

  export type userInclude = {
    user_status?: boolean | user_statusArgs
    user_role?: boolean | user_roleArgs
    acces_log?: boolean | acces_logFindManyArgs
    recover_password_log?: boolean | recover_password_logFindManyArgs
    media?: boolean | mediaFindManyArgs
    ads?: boolean | adsFindManyArgs
    _count?: boolean | UserCountOutputTypeArgs
  }

  export type userGetPayload<
    S extends boolean | null | undefined | userArgs,
    U = keyof S
      > = S extends true
        ? user
    : S extends undefined
    ? never
    : S extends userArgs | userFindManyArgs
    ?'include' extends U
    ? user  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'user_status'
        ? user_statusGetPayload<S['include'][P]> :
        P extends 'user_role'
        ? user_roleGetPayload<S['include'][P]> :
        P extends 'acces_log'
        ? Array < acces_logGetPayload<S['include'][P]>>  :
        P extends 'recover_password_log'
        ? Array < recover_password_logGetPayload<S['include'][P]>>  :
        P extends 'media'
        ? Array < mediaGetPayload<S['include'][P]>>  :
        P extends 'ads'
        ? Array < adsGetPayload<S['include'][P]>>  :
        P extends '_count'
        ? UserCountOutputTypeGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof user ?user [P]
  : 
          P extends 'user_status'
        ? user_statusGetPayload<S['select'][P]> :
        P extends 'user_role'
        ? user_roleGetPayload<S['select'][P]> :
        P extends 'acces_log'
        ? Array < acces_logGetPayload<S['select'][P]>>  :
        P extends 'recover_password_log'
        ? Array < recover_password_logGetPayload<S['select'][P]>>  :
        P extends 'media'
        ? Array < mediaGetPayload<S['select'][P]>>  :
        P extends 'ads'
        ? Array < adsGetPayload<S['select'][P]>>  :
        P extends '_count'
        ? UserCountOutputTypeGetPayload<S['select'][P]> : never
  } 
    : user
  : user


  type userCountArgs = Merge<
    Omit<userFindManyArgs, 'select' | 'include'> & {
      select?: UserCountAggregateInputType | true
    }
  >

  export interface userDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one User that matches the filter.
     * @param {userFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends userFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, userFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'user'> extends True ? CheckSelect<T, Prisma__userClient<user>, Prisma__userClient<userGetPayload<T>>> : CheckSelect<T, Prisma__userClient<user | null >, Prisma__userClient<userGetPayload<T> | null >>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends userFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, userFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'user'> extends True ? CheckSelect<T, Prisma__userClient<user>, Prisma__userClient<userGetPayload<T>>> : CheckSelect<T, Prisma__userClient<user | null >, Prisma__userClient<userGetPayload<T> | null >>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends userFindManyArgs>(
      args?: SelectSubset<T, userFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<user>>, PrismaPromise<Array<userGetPayload<T>>>>

    /**
     * Create a User.
     * @param {userCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
    **/
    create<T extends userCreateArgs>(
      args: SelectSubset<T, userCreateArgs>
    ): CheckSelect<T, Prisma__userClient<user>, Prisma__userClient<userGetPayload<T>>>

    /**
     * Create many Users.
     *     @param {userCreateManyArgs} args - Arguments to create many Users.
     *     @example
     *     // Create many Users
     *     const user = await prisma.user.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends userCreateManyArgs>(
      args?: SelectSubset<T, userCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {userDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
    **/
    delete<T extends userDeleteArgs>(
      args: SelectSubset<T, userDeleteArgs>
    ): CheckSelect<T, Prisma__userClient<user>, Prisma__userClient<userGetPayload<T>>>

    /**
     * Update one User.
     * @param {userUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends userUpdateArgs>(
      args: SelectSubset<T, userUpdateArgs>
    ): CheckSelect<T, Prisma__userClient<user>, Prisma__userClient<userGetPayload<T>>>

    /**
     * Delete zero or more Users.
     * @param {userDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends userDeleteManyArgs>(
      args?: SelectSubset<T, userDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends userUpdateManyArgs>(
      args: SelectSubset<T, userUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {userUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
    **/
    upsert<T extends userUpsertArgs>(
      args: SelectSubset<T, userUpsertArgs>
    ): CheckSelect<T, Prisma__userClient<user>, Prisma__userClient<userGetPayload<T>>>

    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends userCountArgs>(
      args?: Subset<T, userCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for user.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__userClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    user_status<T extends user_statusArgs = {}>(args?: Subset<T, user_statusArgs>): CheckSelect<T, Prisma__user_statusClient<user_status | null >, Prisma__user_statusClient<user_statusGetPayload<T> | null >>;

    user_role<T extends user_roleArgs = {}>(args?: Subset<T, user_roleArgs>): CheckSelect<T, Prisma__user_roleClient<user_role | null >, Prisma__user_roleClient<user_roleGetPayload<T> | null >>;

    acces_log<T extends acces_logFindManyArgs = {}>(args?: Subset<T, acces_logFindManyArgs>): CheckSelect<T, PrismaPromise<Array<acces_log>>, PrismaPromise<Array<acces_logGetPayload<T>>>>;

    recover_password_log<T extends recover_password_logFindManyArgs = {}>(args?: Subset<T, recover_password_logFindManyArgs>): CheckSelect<T, PrismaPromise<Array<recover_password_log>>, PrismaPromise<Array<recover_password_logGetPayload<T>>>>;

    media<T extends mediaFindManyArgs = {}>(args?: Subset<T, mediaFindManyArgs>): CheckSelect<T, PrismaPromise<Array<media>>, PrismaPromise<Array<mediaGetPayload<T>>>>;

    ads<T extends adsFindManyArgs = {}>(args?: Subset<T, adsFindManyArgs>): CheckSelect<T, PrismaPromise<Array<ads>>, PrismaPromise<Array<adsGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * user findUnique
   */
  export type userFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the user
     * 
    **/
    select?: userSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: userInclude | null
    /**
     * Throw an Error if a user can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which user to fetch.
     * 
    **/
    where: userWhereUniqueInput
  }


  /**
   * user findFirst
   */
  export type userFindFirstArgs = {
    /**
     * Select specific fields to fetch from the user
     * 
    **/
    select?: userSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: userInclude | null
    /**
     * Throw an Error if a user can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which user to fetch.
     * 
    **/
    where?: userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     * 
    **/
    orderBy?: Enumerable<userOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     * 
    **/
    cursor?: userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     * 
    **/
    distinct?: Enumerable<UserScalarFieldEnum>
  }


  /**
   * user findMany
   */
  export type userFindManyArgs = {
    /**
     * Select specific fields to fetch from the user
     * 
    **/
    select?: userSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: userInclude | null
    /**
     * Filter, which users to fetch.
     * 
    **/
    where?: userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     * 
    **/
    orderBy?: Enumerable<userOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing users.
     * 
    **/
    cursor?: userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     * 
    **/
    skip?: number
    distinct?: Enumerable<UserScalarFieldEnum>
  }


  /**
   * user create
   */
  export type userCreateArgs = {
    /**
     * Select specific fields to fetch from the user
     * 
    **/
    select?: userSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: userInclude | null
    /**
     * The data needed to create a user.
     * 
    **/
    data: XOR<userCreateInput, userUncheckedCreateInput>
  }


  /**
   * user createMany
   */
  export type userCreateManyArgs = {
    data: Enumerable<userCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * user update
   */
  export type userUpdateArgs = {
    /**
     * Select specific fields to fetch from the user
     * 
    **/
    select?: userSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: userInclude | null
    /**
     * The data needed to update a user.
     * 
    **/
    data: XOR<userUpdateInput, userUncheckedUpdateInput>
    /**
     * Choose, which user to update.
     * 
    **/
    where: userWhereUniqueInput
  }


  /**
   * user updateMany
   */
  export type userUpdateManyArgs = {
    data: XOR<userUpdateManyMutationInput, userUncheckedUpdateManyInput>
    where?: userWhereInput
  }


  /**
   * user upsert
   */
  export type userUpsertArgs = {
    /**
     * Select specific fields to fetch from the user
     * 
    **/
    select?: userSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: userInclude | null
    /**
     * The filter to search for the user to update in case it exists.
     * 
    **/
    where: userWhereUniqueInput
    /**
     * In case the user found by the `where` argument doesn't exist, create a new user with this data.
     * 
    **/
    create: XOR<userCreateInput, userUncheckedCreateInput>
    /**
     * In case the user was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<userUpdateInput, userUncheckedUpdateInput>
  }


  /**
   * user delete
   */
  export type userDeleteArgs = {
    /**
     * Select specific fields to fetch from the user
     * 
    **/
    select?: userSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: userInclude | null
    /**
     * Filter which user to delete.
     * 
    **/
    where: userWhereUniqueInput
  }


  /**
   * user deleteMany
   */
  export type userDeleteManyArgs = {
    where?: userWhereInput
  }


  /**
   * user without action
   */
  export type userArgs = {
    /**
     * Select specific fields to fetch from the user
     * 
    **/
    select?: userSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: userInclude | null
  }



  /**
   * Model acces_log
   */


  export type AggregateAcces_log = {
    _count: Acces_logCountAggregateOutputType | null
    _avg: Acces_logAvgAggregateOutputType | null
    _sum: Acces_logSumAggregateOutputType | null
    _min: Acces_logMinAggregateOutputType | null
    _max: Acces_logMaxAggregateOutputType | null
  }

  export type Acces_logAvgAggregateOutputType = {
    id: number | null
    user_id: number | null
  }

  export type Acces_logSumAggregateOutputType = {
    id: number | null
    user_id: number | null
  }

  export type Acces_logMinAggregateOutputType = {
    id: number | null
    login: Date | null
    logout: Date | null
    user_id: number | null
  }

  export type Acces_logMaxAggregateOutputType = {
    id: number | null
    login: Date | null
    logout: Date | null
    user_id: number | null
  }

  export type Acces_logCountAggregateOutputType = {
    id: number
    login: number
    logout: number
    user_id: number
    _all: number
  }


  export type Acces_logAvgAggregateInputType = {
    id?: true
    user_id?: true
  }

  export type Acces_logSumAggregateInputType = {
    id?: true
    user_id?: true
  }

  export type Acces_logMinAggregateInputType = {
    id?: true
    login?: true
    logout?: true
    user_id?: true
  }

  export type Acces_logMaxAggregateInputType = {
    id?: true
    login?: true
    logout?: true
    user_id?: true
  }

  export type Acces_logCountAggregateInputType = {
    id?: true
    login?: true
    logout?: true
    user_id?: true
    _all?: true
  }

  export type Acces_logAggregateArgs = {
    /**
     * Filter which acces_log to aggregate.
     * 
    **/
    where?: acces_logWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of acces_logs to fetch.
     * 
    **/
    orderBy?: Enumerable<acces_logOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: acces_logWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` acces_logs from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` acces_logs.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned acces_logs
    **/
    _count?: true | Acces_logCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Acces_logAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Acces_logSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Acces_logMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Acces_logMaxAggregateInputType
  }

  export type GetAcces_logAggregateType<T extends Acces_logAggregateArgs> = {
        [P in keyof T & keyof AggregateAcces_log]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAcces_log[P]>
      : GetScalarType<T[P], AggregateAcces_log[P]>
  }




  export type Acces_logGroupByArgs = {
    where?: acces_logWhereInput
    orderBy?: Enumerable<acces_logOrderByWithAggregationInput>
    by: Array<Acces_logScalarFieldEnum>
    having?: acces_logScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Acces_logCountAggregateInputType | true
    _avg?: Acces_logAvgAggregateInputType
    _sum?: Acces_logSumAggregateInputType
    _min?: Acces_logMinAggregateInputType
    _max?: Acces_logMaxAggregateInputType
  }


  export type Acces_logGroupByOutputType = {
    id: number
    login: Date
    logout: Date
    user_id: number
    _count: Acces_logCountAggregateOutputType | null
    _avg: Acces_logAvgAggregateOutputType | null
    _sum: Acces_logSumAggregateOutputType | null
    _min: Acces_logMinAggregateOutputType | null
    _max: Acces_logMaxAggregateOutputType | null
  }

  type GetAcces_logGroupByPayload<T extends Acces_logGroupByArgs> = Promise<
    Array<
      PickArray<Acces_logGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Acces_logGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Acces_logGroupByOutputType[P]>
            : GetScalarType<T[P], Acces_logGroupByOutputType[P]>
        }
      >
    >


  export type acces_logSelect = {
    id?: boolean
    login?: boolean
    logout?: boolean
    user?: boolean | userArgs
    user_id?: boolean
  }

  export type acces_logInclude = {
    user?: boolean | userArgs
  }

  export type acces_logGetPayload<
    S extends boolean | null | undefined | acces_logArgs,
    U = keyof S
      > = S extends true
        ? acces_log
    : S extends undefined
    ? never
    : S extends acces_logArgs | acces_logFindManyArgs
    ?'include' extends U
    ? acces_log  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'user'
        ? userGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof acces_log ?acces_log [P]
  : 
          P extends 'user'
        ? userGetPayload<S['select'][P]> : never
  } 
    : acces_log
  : acces_log


  type acces_logCountArgs = Merge<
    Omit<acces_logFindManyArgs, 'select' | 'include'> & {
      select?: Acces_logCountAggregateInputType | true
    }
  >

  export interface acces_logDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Acces_log that matches the filter.
     * @param {acces_logFindUniqueArgs} args - Arguments to find a Acces_log
     * @example
     * // Get one Acces_log
     * const acces_log = await prisma.acces_log.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends acces_logFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, acces_logFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'acces_log'> extends True ? CheckSelect<T, Prisma__acces_logClient<acces_log>, Prisma__acces_logClient<acces_logGetPayload<T>>> : CheckSelect<T, Prisma__acces_logClient<acces_log | null >, Prisma__acces_logClient<acces_logGetPayload<T> | null >>

    /**
     * Find the first Acces_log that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {acces_logFindFirstArgs} args - Arguments to find a Acces_log
     * @example
     * // Get one Acces_log
     * const acces_log = await prisma.acces_log.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends acces_logFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, acces_logFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'acces_log'> extends True ? CheckSelect<T, Prisma__acces_logClient<acces_log>, Prisma__acces_logClient<acces_logGetPayload<T>>> : CheckSelect<T, Prisma__acces_logClient<acces_log | null >, Prisma__acces_logClient<acces_logGetPayload<T> | null >>

    /**
     * Find zero or more Acces_logs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {acces_logFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Acces_logs
     * const acces_logs = await prisma.acces_log.findMany()
     * 
     * // Get first 10 Acces_logs
     * const acces_logs = await prisma.acces_log.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const acces_logWithIdOnly = await prisma.acces_log.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends acces_logFindManyArgs>(
      args?: SelectSubset<T, acces_logFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<acces_log>>, PrismaPromise<Array<acces_logGetPayload<T>>>>

    /**
     * Create a Acces_log.
     * @param {acces_logCreateArgs} args - Arguments to create a Acces_log.
     * @example
     * // Create one Acces_log
     * const Acces_log = await prisma.acces_log.create({
     *   data: {
     *     // ... data to create a Acces_log
     *   }
     * })
     * 
    **/
    create<T extends acces_logCreateArgs>(
      args: SelectSubset<T, acces_logCreateArgs>
    ): CheckSelect<T, Prisma__acces_logClient<acces_log>, Prisma__acces_logClient<acces_logGetPayload<T>>>

    /**
     * Create many Acces_logs.
     *     @param {acces_logCreateManyArgs} args - Arguments to create many Acces_logs.
     *     @example
     *     // Create many Acces_logs
     *     const acces_log = await prisma.acces_log.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends acces_logCreateManyArgs>(
      args?: SelectSubset<T, acces_logCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Acces_log.
     * @param {acces_logDeleteArgs} args - Arguments to delete one Acces_log.
     * @example
     * // Delete one Acces_log
     * const Acces_log = await prisma.acces_log.delete({
     *   where: {
     *     // ... filter to delete one Acces_log
     *   }
     * })
     * 
    **/
    delete<T extends acces_logDeleteArgs>(
      args: SelectSubset<T, acces_logDeleteArgs>
    ): CheckSelect<T, Prisma__acces_logClient<acces_log>, Prisma__acces_logClient<acces_logGetPayload<T>>>

    /**
     * Update one Acces_log.
     * @param {acces_logUpdateArgs} args - Arguments to update one Acces_log.
     * @example
     * // Update one Acces_log
     * const acces_log = await prisma.acces_log.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends acces_logUpdateArgs>(
      args: SelectSubset<T, acces_logUpdateArgs>
    ): CheckSelect<T, Prisma__acces_logClient<acces_log>, Prisma__acces_logClient<acces_logGetPayload<T>>>

    /**
     * Delete zero or more Acces_logs.
     * @param {acces_logDeleteManyArgs} args - Arguments to filter Acces_logs to delete.
     * @example
     * // Delete a few Acces_logs
     * const { count } = await prisma.acces_log.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends acces_logDeleteManyArgs>(
      args?: SelectSubset<T, acces_logDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Acces_logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {acces_logUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Acces_logs
     * const acces_log = await prisma.acces_log.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends acces_logUpdateManyArgs>(
      args: SelectSubset<T, acces_logUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Acces_log.
     * @param {acces_logUpsertArgs} args - Arguments to update or create a Acces_log.
     * @example
     * // Update or create a Acces_log
     * const acces_log = await prisma.acces_log.upsert({
     *   create: {
     *     // ... data to create a Acces_log
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Acces_log we want to update
     *   }
     * })
    **/
    upsert<T extends acces_logUpsertArgs>(
      args: SelectSubset<T, acces_logUpsertArgs>
    ): CheckSelect<T, Prisma__acces_logClient<acces_log>, Prisma__acces_logClient<acces_logGetPayload<T>>>

    /**
     * Count the number of Acces_logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {acces_logCountArgs} args - Arguments to filter Acces_logs to count.
     * @example
     * // Count the number of Acces_logs
     * const count = await prisma.acces_log.count({
     *   where: {
     *     // ... the filter for the Acces_logs we want to count
     *   }
     * })
    **/
    count<T extends acces_logCountArgs>(
      args?: Subset<T, acces_logCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Acces_logCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Acces_log.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Acces_logAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Acces_logAggregateArgs>(args: Subset<T, Acces_logAggregateArgs>): PrismaPromise<GetAcces_logAggregateType<T>>

    /**
     * Group by Acces_log.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Acces_logGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Acces_logGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Acces_logGroupByArgs['orderBy'] }
        : { orderBy?: Acces_logGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Acces_logGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAcces_logGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for acces_log.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__acces_logClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    user<T extends userArgs = {}>(args?: Subset<T, userArgs>): CheckSelect<T, Prisma__userClient<user | null >, Prisma__userClient<userGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * acces_log findUnique
   */
  export type acces_logFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the acces_log
     * 
    **/
    select?: acces_logSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: acces_logInclude | null
    /**
     * Throw an Error if a acces_log can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which acces_log to fetch.
     * 
    **/
    where: acces_logWhereUniqueInput
  }


  /**
   * acces_log findFirst
   */
  export type acces_logFindFirstArgs = {
    /**
     * Select specific fields to fetch from the acces_log
     * 
    **/
    select?: acces_logSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: acces_logInclude | null
    /**
     * Throw an Error if a acces_log can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which acces_log to fetch.
     * 
    **/
    where?: acces_logWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of acces_logs to fetch.
     * 
    **/
    orderBy?: Enumerable<acces_logOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for acces_logs.
     * 
    **/
    cursor?: acces_logWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` acces_logs from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` acces_logs.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of acces_logs.
     * 
    **/
    distinct?: Enumerable<Acces_logScalarFieldEnum>
  }


  /**
   * acces_log findMany
   */
  export type acces_logFindManyArgs = {
    /**
     * Select specific fields to fetch from the acces_log
     * 
    **/
    select?: acces_logSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: acces_logInclude | null
    /**
     * Filter, which acces_logs to fetch.
     * 
    **/
    where?: acces_logWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of acces_logs to fetch.
     * 
    **/
    orderBy?: Enumerable<acces_logOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing acces_logs.
     * 
    **/
    cursor?: acces_logWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` acces_logs from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` acces_logs.
     * 
    **/
    skip?: number
    distinct?: Enumerable<Acces_logScalarFieldEnum>
  }


  /**
   * acces_log create
   */
  export type acces_logCreateArgs = {
    /**
     * Select specific fields to fetch from the acces_log
     * 
    **/
    select?: acces_logSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: acces_logInclude | null
    /**
     * The data needed to create a acces_log.
     * 
    **/
    data: XOR<acces_logCreateInput, acces_logUncheckedCreateInput>
  }


  /**
   * acces_log createMany
   */
  export type acces_logCreateManyArgs = {
    data: Enumerable<acces_logCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * acces_log update
   */
  export type acces_logUpdateArgs = {
    /**
     * Select specific fields to fetch from the acces_log
     * 
    **/
    select?: acces_logSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: acces_logInclude | null
    /**
     * The data needed to update a acces_log.
     * 
    **/
    data: XOR<acces_logUpdateInput, acces_logUncheckedUpdateInput>
    /**
     * Choose, which acces_log to update.
     * 
    **/
    where: acces_logWhereUniqueInput
  }


  /**
   * acces_log updateMany
   */
  export type acces_logUpdateManyArgs = {
    data: XOR<acces_logUpdateManyMutationInput, acces_logUncheckedUpdateManyInput>
    where?: acces_logWhereInput
  }


  /**
   * acces_log upsert
   */
  export type acces_logUpsertArgs = {
    /**
     * Select specific fields to fetch from the acces_log
     * 
    **/
    select?: acces_logSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: acces_logInclude | null
    /**
     * The filter to search for the acces_log to update in case it exists.
     * 
    **/
    where: acces_logWhereUniqueInput
    /**
     * In case the acces_log found by the `where` argument doesn't exist, create a new acces_log with this data.
     * 
    **/
    create: XOR<acces_logCreateInput, acces_logUncheckedCreateInput>
    /**
     * In case the acces_log was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<acces_logUpdateInput, acces_logUncheckedUpdateInput>
  }


  /**
   * acces_log delete
   */
  export type acces_logDeleteArgs = {
    /**
     * Select specific fields to fetch from the acces_log
     * 
    **/
    select?: acces_logSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: acces_logInclude | null
    /**
     * Filter which acces_log to delete.
     * 
    **/
    where: acces_logWhereUniqueInput
  }


  /**
   * acces_log deleteMany
   */
  export type acces_logDeleteManyArgs = {
    where?: acces_logWhereInput
  }


  /**
   * acces_log without action
   */
  export type acces_logArgs = {
    /**
     * Select specific fields to fetch from the acces_log
     * 
    **/
    select?: acces_logSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: acces_logInclude | null
  }



  /**
   * Model recover_password_log
   */


  export type AggregateRecover_password_log = {
    _count: Recover_password_logCountAggregateOutputType | null
    _avg: Recover_password_logAvgAggregateOutputType | null
    _sum: Recover_password_logSumAggregateOutputType | null
    _min: Recover_password_logMinAggregateOutputType | null
    _max: Recover_password_logMaxAggregateOutputType | null
  }

  export type Recover_password_logAvgAggregateOutputType = {
    id: number | null
    user_id: number | null
  }

  export type Recover_password_logSumAggregateOutputType = {
    id: number | null
    user_id: number | null
  }

  export type Recover_password_logMinAggregateOutputType = {
    id: number | null
    created_at: Date | null
    password: string | null
    user_id: number | null
  }

  export type Recover_password_logMaxAggregateOutputType = {
    id: number | null
    created_at: Date | null
    password: string | null
    user_id: number | null
  }

  export type Recover_password_logCountAggregateOutputType = {
    id: number
    created_at: number
    password: number
    user_id: number
    _all: number
  }


  export type Recover_password_logAvgAggregateInputType = {
    id?: true
    user_id?: true
  }

  export type Recover_password_logSumAggregateInputType = {
    id?: true
    user_id?: true
  }

  export type Recover_password_logMinAggregateInputType = {
    id?: true
    created_at?: true
    password?: true
    user_id?: true
  }

  export type Recover_password_logMaxAggregateInputType = {
    id?: true
    created_at?: true
    password?: true
    user_id?: true
  }

  export type Recover_password_logCountAggregateInputType = {
    id?: true
    created_at?: true
    password?: true
    user_id?: true
    _all?: true
  }

  export type Recover_password_logAggregateArgs = {
    /**
     * Filter which recover_password_log to aggregate.
     * 
    **/
    where?: recover_password_logWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of recover_password_logs to fetch.
     * 
    **/
    orderBy?: Enumerable<recover_password_logOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: recover_password_logWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` recover_password_logs from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` recover_password_logs.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned recover_password_logs
    **/
    _count?: true | Recover_password_logCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Recover_password_logAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Recover_password_logSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Recover_password_logMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Recover_password_logMaxAggregateInputType
  }

  export type GetRecover_password_logAggregateType<T extends Recover_password_logAggregateArgs> = {
        [P in keyof T & keyof AggregateRecover_password_log]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRecover_password_log[P]>
      : GetScalarType<T[P], AggregateRecover_password_log[P]>
  }




  export type Recover_password_logGroupByArgs = {
    where?: recover_password_logWhereInput
    orderBy?: Enumerable<recover_password_logOrderByWithAggregationInput>
    by: Array<Recover_password_logScalarFieldEnum>
    having?: recover_password_logScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Recover_password_logCountAggregateInputType | true
    _avg?: Recover_password_logAvgAggregateInputType
    _sum?: Recover_password_logSumAggregateInputType
    _min?: Recover_password_logMinAggregateInputType
    _max?: Recover_password_logMaxAggregateInputType
  }


  export type Recover_password_logGroupByOutputType = {
    id: number
    created_at: Date
    password: string
    user_id: number
    _count: Recover_password_logCountAggregateOutputType | null
    _avg: Recover_password_logAvgAggregateOutputType | null
    _sum: Recover_password_logSumAggregateOutputType | null
    _min: Recover_password_logMinAggregateOutputType | null
    _max: Recover_password_logMaxAggregateOutputType | null
  }

  type GetRecover_password_logGroupByPayload<T extends Recover_password_logGroupByArgs> = Promise<
    Array<
      PickArray<Recover_password_logGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Recover_password_logGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Recover_password_logGroupByOutputType[P]>
            : GetScalarType<T[P], Recover_password_logGroupByOutputType[P]>
        }
      >
    >


  export type recover_password_logSelect = {
    id?: boolean
    created_at?: boolean
    password?: boolean
    user?: boolean | userArgs
    user_id?: boolean
  }

  export type recover_password_logInclude = {
    user?: boolean | userArgs
  }

  export type recover_password_logGetPayload<
    S extends boolean | null | undefined | recover_password_logArgs,
    U = keyof S
      > = S extends true
        ? recover_password_log
    : S extends undefined
    ? never
    : S extends recover_password_logArgs | recover_password_logFindManyArgs
    ?'include' extends U
    ? recover_password_log  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'user'
        ? userGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof recover_password_log ?recover_password_log [P]
  : 
          P extends 'user'
        ? userGetPayload<S['select'][P]> : never
  } 
    : recover_password_log
  : recover_password_log


  type recover_password_logCountArgs = Merge<
    Omit<recover_password_logFindManyArgs, 'select' | 'include'> & {
      select?: Recover_password_logCountAggregateInputType | true
    }
  >

  export interface recover_password_logDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Recover_password_log that matches the filter.
     * @param {recover_password_logFindUniqueArgs} args - Arguments to find a Recover_password_log
     * @example
     * // Get one Recover_password_log
     * const recover_password_log = await prisma.recover_password_log.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends recover_password_logFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, recover_password_logFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'recover_password_log'> extends True ? CheckSelect<T, Prisma__recover_password_logClient<recover_password_log>, Prisma__recover_password_logClient<recover_password_logGetPayload<T>>> : CheckSelect<T, Prisma__recover_password_logClient<recover_password_log | null >, Prisma__recover_password_logClient<recover_password_logGetPayload<T> | null >>

    /**
     * Find the first Recover_password_log that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {recover_password_logFindFirstArgs} args - Arguments to find a Recover_password_log
     * @example
     * // Get one Recover_password_log
     * const recover_password_log = await prisma.recover_password_log.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends recover_password_logFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, recover_password_logFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'recover_password_log'> extends True ? CheckSelect<T, Prisma__recover_password_logClient<recover_password_log>, Prisma__recover_password_logClient<recover_password_logGetPayload<T>>> : CheckSelect<T, Prisma__recover_password_logClient<recover_password_log | null >, Prisma__recover_password_logClient<recover_password_logGetPayload<T> | null >>

    /**
     * Find zero or more Recover_password_logs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {recover_password_logFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Recover_password_logs
     * const recover_password_logs = await prisma.recover_password_log.findMany()
     * 
     * // Get first 10 Recover_password_logs
     * const recover_password_logs = await prisma.recover_password_log.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const recover_password_logWithIdOnly = await prisma.recover_password_log.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends recover_password_logFindManyArgs>(
      args?: SelectSubset<T, recover_password_logFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<recover_password_log>>, PrismaPromise<Array<recover_password_logGetPayload<T>>>>

    /**
     * Create a Recover_password_log.
     * @param {recover_password_logCreateArgs} args - Arguments to create a Recover_password_log.
     * @example
     * // Create one Recover_password_log
     * const Recover_password_log = await prisma.recover_password_log.create({
     *   data: {
     *     // ... data to create a Recover_password_log
     *   }
     * })
     * 
    **/
    create<T extends recover_password_logCreateArgs>(
      args: SelectSubset<T, recover_password_logCreateArgs>
    ): CheckSelect<T, Prisma__recover_password_logClient<recover_password_log>, Prisma__recover_password_logClient<recover_password_logGetPayload<T>>>

    /**
     * Create many Recover_password_logs.
     *     @param {recover_password_logCreateManyArgs} args - Arguments to create many Recover_password_logs.
     *     @example
     *     // Create many Recover_password_logs
     *     const recover_password_log = await prisma.recover_password_log.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends recover_password_logCreateManyArgs>(
      args?: SelectSubset<T, recover_password_logCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Recover_password_log.
     * @param {recover_password_logDeleteArgs} args - Arguments to delete one Recover_password_log.
     * @example
     * // Delete one Recover_password_log
     * const Recover_password_log = await prisma.recover_password_log.delete({
     *   where: {
     *     // ... filter to delete one Recover_password_log
     *   }
     * })
     * 
    **/
    delete<T extends recover_password_logDeleteArgs>(
      args: SelectSubset<T, recover_password_logDeleteArgs>
    ): CheckSelect<T, Prisma__recover_password_logClient<recover_password_log>, Prisma__recover_password_logClient<recover_password_logGetPayload<T>>>

    /**
     * Update one Recover_password_log.
     * @param {recover_password_logUpdateArgs} args - Arguments to update one Recover_password_log.
     * @example
     * // Update one Recover_password_log
     * const recover_password_log = await prisma.recover_password_log.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends recover_password_logUpdateArgs>(
      args: SelectSubset<T, recover_password_logUpdateArgs>
    ): CheckSelect<T, Prisma__recover_password_logClient<recover_password_log>, Prisma__recover_password_logClient<recover_password_logGetPayload<T>>>

    /**
     * Delete zero or more Recover_password_logs.
     * @param {recover_password_logDeleteManyArgs} args - Arguments to filter Recover_password_logs to delete.
     * @example
     * // Delete a few Recover_password_logs
     * const { count } = await prisma.recover_password_log.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends recover_password_logDeleteManyArgs>(
      args?: SelectSubset<T, recover_password_logDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Recover_password_logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {recover_password_logUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Recover_password_logs
     * const recover_password_log = await prisma.recover_password_log.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends recover_password_logUpdateManyArgs>(
      args: SelectSubset<T, recover_password_logUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Recover_password_log.
     * @param {recover_password_logUpsertArgs} args - Arguments to update or create a Recover_password_log.
     * @example
     * // Update or create a Recover_password_log
     * const recover_password_log = await prisma.recover_password_log.upsert({
     *   create: {
     *     // ... data to create a Recover_password_log
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Recover_password_log we want to update
     *   }
     * })
    **/
    upsert<T extends recover_password_logUpsertArgs>(
      args: SelectSubset<T, recover_password_logUpsertArgs>
    ): CheckSelect<T, Prisma__recover_password_logClient<recover_password_log>, Prisma__recover_password_logClient<recover_password_logGetPayload<T>>>

    /**
     * Count the number of Recover_password_logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {recover_password_logCountArgs} args - Arguments to filter Recover_password_logs to count.
     * @example
     * // Count the number of Recover_password_logs
     * const count = await prisma.recover_password_log.count({
     *   where: {
     *     // ... the filter for the Recover_password_logs we want to count
     *   }
     * })
    **/
    count<T extends recover_password_logCountArgs>(
      args?: Subset<T, recover_password_logCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Recover_password_logCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Recover_password_log.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Recover_password_logAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Recover_password_logAggregateArgs>(args: Subset<T, Recover_password_logAggregateArgs>): PrismaPromise<GetRecover_password_logAggregateType<T>>

    /**
     * Group by Recover_password_log.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Recover_password_logGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Recover_password_logGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Recover_password_logGroupByArgs['orderBy'] }
        : { orderBy?: Recover_password_logGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Recover_password_logGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRecover_password_logGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for recover_password_log.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__recover_password_logClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    user<T extends userArgs = {}>(args?: Subset<T, userArgs>): CheckSelect<T, Prisma__userClient<user | null >, Prisma__userClient<userGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * recover_password_log findUnique
   */
  export type recover_password_logFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the recover_password_log
     * 
    **/
    select?: recover_password_logSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: recover_password_logInclude | null
    /**
     * Throw an Error if a recover_password_log can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which recover_password_log to fetch.
     * 
    **/
    where: recover_password_logWhereUniqueInput
  }


  /**
   * recover_password_log findFirst
   */
  export type recover_password_logFindFirstArgs = {
    /**
     * Select specific fields to fetch from the recover_password_log
     * 
    **/
    select?: recover_password_logSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: recover_password_logInclude | null
    /**
     * Throw an Error if a recover_password_log can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which recover_password_log to fetch.
     * 
    **/
    where?: recover_password_logWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of recover_password_logs to fetch.
     * 
    **/
    orderBy?: Enumerable<recover_password_logOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for recover_password_logs.
     * 
    **/
    cursor?: recover_password_logWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` recover_password_logs from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` recover_password_logs.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of recover_password_logs.
     * 
    **/
    distinct?: Enumerable<Recover_password_logScalarFieldEnum>
  }


  /**
   * recover_password_log findMany
   */
  export type recover_password_logFindManyArgs = {
    /**
     * Select specific fields to fetch from the recover_password_log
     * 
    **/
    select?: recover_password_logSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: recover_password_logInclude | null
    /**
     * Filter, which recover_password_logs to fetch.
     * 
    **/
    where?: recover_password_logWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of recover_password_logs to fetch.
     * 
    **/
    orderBy?: Enumerable<recover_password_logOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing recover_password_logs.
     * 
    **/
    cursor?: recover_password_logWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` recover_password_logs from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` recover_password_logs.
     * 
    **/
    skip?: number
    distinct?: Enumerable<Recover_password_logScalarFieldEnum>
  }


  /**
   * recover_password_log create
   */
  export type recover_password_logCreateArgs = {
    /**
     * Select specific fields to fetch from the recover_password_log
     * 
    **/
    select?: recover_password_logSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: recover_password_logInclude | null
    /**
     * The data needed to create a recover_password_log.
     * 
    **/
    data: XOR<recover_password_logCreateInput, recover_password_logUncheckedCreateInput>
  }


  /**
   * recover_password_log createMany
   */
  export type recover_password_logCreateManyArgs = {
    data: Enumerable<recover_password_logCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * recover_password_log update
   */
  export type recover_password_logUpdateArgs = {
    /**
     * Select specific fields to fetch from the recover_password_log
     * 
    **/
    select?: recover_password_logSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: recover_password_logInclude | null
    /**
     * The data needed to update a recover_password_log.
     * 
    **/
    data: XOR<recover_password_logUpdateInput, recover_password_logUncheckedUpdateInput>
    /**
     * Choose, which recover_password_log to update.
     * 
    **/
    where: recover_password_logWhereUniqueInput
  }


  /**
   * recover_password_log updateMany
   */
  export type recover_password_logUpdateManyArgs = {
    data: XOR<recover_password_logUpdateManyMutationInput, recover_password_logUncheckedUpdateManyInput>
    where?: recover_password_logWhereInput
  }


  /**
   * recover_password_log upsert
   */
  export type recover_password_logUpsertArgs = {
    /**
     * Select specific fields to fetch from the recover_password_log
     * 
    **/
    select?: recover_password_logSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: recover_password_logInclude | null
    /**
     * The filter to search for the recover_password_log to update in case it exists.
     * 
    **/
    where: recover_password_logWhereUniqueInput
    /**
     * In case the recover_password_log found by the `where` argument doesn't exist, create a new recover_password_log with this data.
     * 
    **/
    create: XOR<recover_password_logCreateInput, recover_password_logUncheckedCreateInput>
    /**
     * In case the recover_password_log was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<recover_password_logUpdateInput, recover_password_logUncheckedUpdateInput>
  }


  /**
   * recover_password_log delete
   */
  export type recover_password_logDeleteArgs = {
    /**
     * Select specific fields to fetch from the recover_password_log
     * 
    **/
    select?: recover_password_logSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: recover_password_logInclude | null
    /**
     * Filter which recover_password_log to delete.
     * 
    **/
    where: recover_password_logWhereUniqueInput
  }


  /**
   * recover_password_log deleteMany
   */
  export type recover_password_logDeleteManyArgs = {
    where?: recover_password_logWhereInput
  }


  /**
   * recover_password_log without action
   */
  export type recover_password_logArgs = {
    /**
     * Select specific fields to fetch from the recover_password_log
     * 
    **/
    select?: recover_password_logSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: recover_password_logInclude | null
  }



  /**
   * Model media
   */


  export type AggregateMedia = {
    _count: MediaCountAggregateOutputType | null
    _avg: MediaAvgAggregateOutputType | null
    _sum: MediaSumAggregateOutputType | null
    _min: MediaMinAggregateOutputType | null
    _max: MediaMaxAggregateOutputType | null
  }

  export type MediaAvgAggregateOutputType = {
    id: number | null
    user_id: number | null
  }

  export type MediaSumAggregateOutputType = {
    id: number | null
    user_id: number | null
  }

  export type MediaMinAggregateOutputType = {
    id: number | null
    path: string | null
    mime_type: string | null
    file_size: string | null
    user_id: number | null
  }

  export type MediaMaxAggregateOutputType = {
    id: number | null
    path: string | null
    mime_type: string | null
    file_size: string | null
    user_id: number | null
  }

  export type MediaCountAggregateOutputType = {
    id: number
    path: number
    mime_type: number
    file_size: number
    user_id: number
    _all: number
  }


  export type MediaAvgAggregateInputType = {
    id?: true
    user_id?: true
  }

  export type MediaSumAggregateInputType = {
    id?: true
    user_id?: true
  }

  export type MediaMinAggregateInputType = {
    id?: true
    path?: true
    mime_type?: true
    file_size?: true
    user_id?: true
  }

  export type MediaMaxAggregateInputType = {
    id?: true
    path?: true
    mime_type?: true
    file_size?: true
    user_id?: true
  }

  export type MediaCountAggregateInputType = {
    id?: true
    path?: true
    mime_type?: true
    file_size?: true
    user_id?: true
    _all?: true
  }

  export type MediaAggregateArgs = {
    /**
     * Filter which media to aggregate.
     * 
    **/
    where?: mediaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of media to fetch.
     * 
    **/
    orderBy?: Enumerable<mediaOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: mediaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` media from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` media.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned media
    **/
    _count?: true | MediaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MediaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MediaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MediaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MediaMaxAggregateInputType
  }

  export type GetMediaAggregateType<T extends MediaAggregateArgs> = {
        [P in keyof T & keyof AggregateMedia]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMedia[P]>
      : GetScalarType<T[P], AggregateMedia[P]>
  }




  export type MediaGroupByArgs = {
    where?: mediaWhereInput
    orderBy?: Enumerable<mediaOrderByWithAggregationInput>
    by: Array<MediaScalarFieldEnum>
    having?: mediaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MediaCountAggregateInputType | true
    _avg?: MediaAvgAggregateInputType
    _sum?: MediaSumAggregateInputType
    _min?: MediaMinAggregateInputType
    _max?: MediaMaxAggregateInputType
  }


  export type MediaGroupByOutputType = {
    id: number
    path: string
    mime_type: string
    file_size: string
    user_id: number
    _count: MediaCountAggregateOutputType | null
    _avg: MediaAvgAggregateOutputType | null
    _sum: MediaSumAggregateOutputType | null
    _min: MediaMinAggregateOutputType | null
    _max: MediaMaxAggregateOutputType | null
  }

  type GetMediaGroupByPayload<T extends MediaGroupByArgs> = Promise<
    Array<
      PickArray<MediaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MediaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MediaGroupByOutputType[P]>
            : GetScalarType<T[P], MediaGroupByOutputType[P]>
        }
      >
    >


  export type mediaSelect = {
    id?: boolean
    path?: boolean
    mime_type?: boolean
    file_size?: boolean
    user?: boolean | userArgs
    user_id?: boolean
    media_meta?: boolean | media_metaFindManyArgs
    _count?: boolean | MediaCountOutputTypeArgs
  }

  export type mediaInclude = {
    user?: boolean | userArgs
    media_meta?: boolean | media_metaFindManyArgs
    _count?: boolean | MediaCountOutputTypeArgs
  }

  export type mediaGetPayload<
    S extends boolean | null | undefined | mediaArgs,
    U = keyof S
      > = S extends true
        ? media
    : S extends undefined
    ? never
    : S extends mediaArgs | mediaFindManyArgs
    ?'include' extends U
    ? media  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'user'
        ? userGetPayload<S['include'][P]> :
        P extends 'media_meta'
        ? Array < media_metaGetPayload<S['include'][P]>>  :
        P extends '_count'
        ? MediaCountOutputTypeGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof media ?media [P]
  : 
          P extends 'user'
        ? userGetPayload<S['select'][P]> :
        P extends 'media_meta'
        ? Array < media_metaGetPayload<S['select'][P]>>  :
        P extends '_count'
        ? MediaCountOutputTypeGetPayload<S['select'][P]> : never
  } 
    : media
  : media


  type mediaCountArgs = Merge<
    Omit<mediaFindManyArgs, 'select' | 'include'> & {
      select?: MediaCountAggregateInputType | true
    }
  >

  export interface mediaDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Media that matches the filter.
     * @param {mediaFindUniqueArgs} args - Arguments to find a Media
     * @example
     * // Get one Media
     * const media = await prisma.media.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends mediaFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, mediaFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'media'> extends True ? CheckSelect<T, Prisma__mediaClient<media>, Prisma__mediaClient<mediaGetPayload<T>>> : CheckSelect<T, Prisma__mediaClient<media | null >, Prisma__mediaClient<mediaGetPayload<T> | null >>

    /**
     * Find the first Media that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mediaFindFirstArgs} args - Arguments to find a Media
     * @example
     * // Get one Media
     * const media = await prisma.media.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends mediaFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, mediaFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'media'> extends True ? CheckSelect<T, Prisma__mediaClient<media>, Prisma__mediaClient<mediaGetPayload<T>>> : CheckSelect<T, Prisma__mediaClient<media | null >, Prisma__mediaClient<mediaGetPayload<T> | null >>

    /**
     * Find zero or more Media that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mediaFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Media
     * const media = await prisma.media.findMany()
     * 
     * // Get first 10 Media
     * const media = await prisma.media.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const mediaWithIdOnly = await prisma.media.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends mediaFindManyArgs>(
      args?: SelectSubset<T, mediaFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<media>>, PrismaPromise<Array<mediaGetPayload<T>>>>

    /**
     * Create a Media.
     * @param {mediaCreateArgs} args - Arguments to create a Media.
     * @example
     * // Create one Media
     * const Media = await prisma.media.create({
     *   data: {
     *     // ... data to create a Media
     *   }
     * })
     * 
    **/
    create<T extends mediaCreateArgs>(
      args: SelectSubset<T, mediaCreateArgs>
    ): CheckSelect<T, Prisma__mediaClient<media>, Prisma__mediaClient<mediaGetPayload<T>>>

    /**
     * Create many Media.
     *     @param {mediaCreateManyArgs} args - Arguments to create many Media.
     *     @example
     *     // Create many Media
     *     const media = await prisma.media.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends mediaCreateManyArgs>(
      args?: SelectSubset<T, mediaCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Media.
     * @param {mediaDeleteArgs} args - Arguments to delete one Media.
     * @example
     * // Delete one Media
     * const Media = await prisma.media.delete({
     *   where: {
     *     // ... filter to delete one Media
     *   }
     * })
     * 
    **/
    delete<T extends mediaDeleteArgs>(
      args: SelectSubset<T, mediaDeleteArgs>
    ): CheckSelect<T, Prisma__mediaClient<media>, Prisma__mediaClient<mediaGetPayload<T>>>

    /**
     * Update one Media.
     * @param {mediaUpdateArgs} args - Arguments to update one Media.
     * @example
     * // Update one Media
     * const media = await prisma.media.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends mediaUpdateArgs>(
      args: SelectSubset<T, mediaUpdateArgs>
    ): CheckSelect<T, Prisma__mediaClient<media>, Prisma__mediaClient<mediaGetPayload<T>>>

    /**
     * Delete zero or more Media.
     * @param {mediaDeleteManyArgs} args - Arguments to filter Media to delete.
     * @example
     * // Delete a few Media
     * const { count } = await prisma.media.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends mediaDeleteManyArgs>(
      args?: SelectSubset<T, mediaDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Media.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mediaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Media
     * const media = await prisma.media.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends mediaUpdateManyArgs>(
      args: SelectSubset<T, mediaUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Media.
     * @param {mediaUpsertArgs} args - Arguments to update or create a Media.
     * @example
     * // Update or create a Media
     * const media = await prisma.media.upsert({
     *   create: {
     *     // ... data to create a Media
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Media we want to update
     *   }
     * })
    **/
    upsert<T extends mediaUpsertArgs>(
      args: SelectSubset<T, mediaUpsertArgs>
    ): CheckSelect<T, Prisma__mediaClient<media>, Prisma__mediaClient<mediaGetPayload<T>>>

    /**
     * Count the number of Media.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mediaCountArgs} args - Arguments to filter Media to count.
     * @example
     * // Count the number of Media
     * const count = await prisma.media.count({
     *   where: {
     *     // ... the filter for the Media we want to count
     *   }
     * })
    **/
    count<T extends mediaCountArgs>(
      args?: Subset<T, mediaCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MediaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Media.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MediaAggregateArgs>(args: Subset<T, MediaAggregateArgs>): PrismaPromise<GetMediaAggregateType<T>>

    /**
     * Group by Media.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MediaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MediaGroupByArgs['orderBy'] }
        : { orderBy?: MediaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MediaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMediaGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for media.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__mediaClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    user<T extends userArgs = {}>(args?: Subset<T, userArgs>): CheckSelect<T, Prisma__userClient<user | null >, Prisma__userClient<userGetPayload<T> | null >>;

    media_meta<T extends media_metaFindManyArgs = {}>(args?: Subset<T, media_metaFindManyArgs>): CheckSelect<T, PrismaPromise<Array<media_meta>>, PrismaPromise<Array<media_metaGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * media findUnique
   */
  export type mediaFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the media
     * 
    **/
    select?: mediaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: mediaInclude | null
    /**
     * Throw an Error if a media can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which media to fetch.
     * 
    **/
    where: mediaWhereUniqueInput
  }


  /**
   * media findFirst
   */
  export type mediaFindFirstArgs = {
    /**
     * Select specific fields to fetch from the media
     * 
    **/
    select?: mediaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: mediaInclude | null
    /**
     * Throw an Error if a media can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which media to fetch.
     * 
    **/
    where?: mediaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of media to fetch.
     * 
    **/
    orderBy?: Enumerable<mediaOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for media.
     * 
    **/
    cursor?: mediaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` media from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` media.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of media.
     * 
    **/
    distinct?: Enumerable<MediaScalarFieldEnum>
  }


  /**
   * media findMany
   */
  export type mediaFindManyArgs = {
    /**
     * Select specific fields to fetch from the media
     * 
    **/
    select?: mediaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: mediaInclude | null
    /**
     * Filter, which media to fetch.
     * 
    **/
    where?: mediaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of media to fetch.
     * 
    **/
    orderBy?: Enumerable<mediaOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing media.
     * 
    **/
    cursor?: mediaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` media from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` media.
     * 
    **/
    skip?: number
    distinct?: Enumerable<MediaScalarFieldEnum>
  }


  /**
   * media create
   */
  export type mediaCreateArgs = {
    /**
     * Select specific fields to fetch from the media
     * 
    **/
    select?: mediaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: mediaInclude | null
    /**
     * The data needed to create a media.
     * 
    **/
    data: XOR<mediaCreateInput, mediaUncheckedCreateInput>
  }


  /**
   * media createMany
   */
  export type mediaCreateManyArgs = {
    data: Enumerable<mediaCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * media update
   */
  export type mediaUpdateArgs = {
    /**
     * Select specific fields to fetch from the media
     * 
    **/
    select?: mediaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: mediaInclude | null
    /**
     * The data needed to update a media.
     * 
    **/
    data: XOR<mediaUpdateInput, mediaUncheckedUpdateInput>
    /**
     * Choose, which media to update.
     * 
    **/
    where: mediaWhereUniqueInput
  }


  /**
   * media updateMany
   */
  export type mediaUpdateManyArgs = {
    data: XOR<mediaUpdateManyMutationInput, mediaUncheckedUpdateManyInput>
    where?: mediaWhereInput
  }


  /**
   * media upsert
   */
  export type mediaUpsertArgs = {
    /**
     * Select specific fields to fetch from the media
     * 
    **/
    select?: mediaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: mediaInclude | null
    /**
     * The filter to search for the media to update in case it exists.
     * 
    **/
    where: mediaWhereUniqueInput
    /**
     * In case the media found by the `where` argument doesn't exist, create a new media with this data.
     * 
    **/
    create: XOR<mediaCreateInput, mediaUncheckedCreateInput>
    /**
     * In case the media was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<mediaUpdateInput, mediaUncheckedUpdateInput>
  }


  /**
   * media delete
   */
  export type mediaDeleteArgs = {
    /**
     * Select specific fields to fetch from the media
     * 
    **/
    select?: mediaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: mediaInclude | null
    /**
     * Filter which media to delete.
     * 
    **/
    where: mediaWhereUniqueInput
  }


  /**
   * media deleteMany
   */
  export type mediaDeleteManyArgs = {
    where?: mediaWhereInput
  }


  /**
   * media without action
   */
  export type mediaArgs = {
    /**
     * Select specific fields to fetch from the media
     * 
    **/
    select?: mediaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: mediaInclude | null
  }



  /**
   * Model media_meta
   */


  export type AggregateMedia_meta = {
    _count: Media_metaCountAggregateOutputType | null
    _avg: Media_metaAvgAggregateOutputType | null
    _sum: Media_metaSumAggregateOutputType | null
    _min: Media_metaMinAggregateOutputType | null
    _max: Media_metaMaxAggregateOutputType | null
  }

  export type Media_metaAvgAggregateOutputType = {
    id: number | null
    media_id: number | null
    media_type_id: number | null
  }

  export type Media_metaSumAggregateOutputType = {
    id: number | null
    media_id: number | null
    media_type_id: number | null
  }

  export type Media_metaMinAggregateOutputType = {
    id: number | null
    path: string | null
    mime_type: string | null
    file_size: string | null
    media_id: number | null
    media_type_id: number | null
  }

  export type Media_metaMaxAggregateOutputType = {
    id: number | null
    path: string | null
    mime_type: string | null
    file_size: string | null
    media_id: number | null
    media_type_id: number | null
  }

  export type Media_metaCountAggregateOutputType = {
    id: number
    path: number
    mime_type: number
    file_size: number
    media_id: number
    media_type_id: number
    _all: number
  }


  export type Media_metaAvgAggregateInputType = {
    id?: true
    media_id?: true
    media_type_id?: true
  }

  export type Media_metaSumAggregateInputType = {
    id?: true
    media_id?: true
    media_type_id?: true
  }

  export type Media_metaMinAggregateInputType = {
    id?: true
    path?: true
    mime_type?: true
    file_size?: true
    media_id?: true
    media_type_id?: true
  }

  export type Media_metaMaxAggregateInputType = {
    id?: true
    path?: true
    mime_type?: true
    file_size?: true
    media_id?: true
    media_type_id?: true
  }

  export type Media_metaCountAggregateInputType = {
    id?: true
    path?: true
    mime_type?: true
    file_size?: true
    media_id?: true
    media_type_id?: true
    _all?: true
  }

  export type Media_metaAggregateArgs = {
    /**
     * Filter which media_meta to aggregate.
     * 
    **/
    where?: media_metaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of media_metas to fetch.
     * 
    **/
    orderBy?: Enumerable<media_metaOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: media_metaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` media_metas from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` media_metas.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned media_metas
    **/
    _count?: true | Media_metaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Media_metaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Media_metaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Media_metaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Media_metaMaxAggregateInputType
  }

  export type GetMedia_metaAggregateType<T extends Media_metaAggregateArgs> = {
        [P in keyof T & keyof AggregateMedia_meta]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMedia_meta[P]>
      : GetScalarType<T[P], AggregateMedia_meta[P]>
  }




  export type Media_metaGroupByArgs = {
    where?: media_metaWhereInput
    orderBy?: Enumerable<media_metaOrderByWithAggregationInput>
    by: Array<Media_metaScalarFieldEnum>
    having?: media_metaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Media_metaCountAggregateInputType | true
    _avg?: Media_metaAvgAggregateInputType
    _sum?: Media_metaSumAggregateInputType
    _min?: Media_metaMinAggregateInputType
    _max?: Media_metaMaxAggregateInputType
  }


  export type Media_metaGroupByOutputType = {
    id: number
    path: string
    mime_type: string
    file_size: string
    media_id: number
    media_type_id: number
    _count: Media_metaCountAggregateOutputType | null
    _avg: Media_metaAvgAggregateOutputType | null
    _sum: Media_metaSumAggregateOutputType | null
    _min: Media_metaMinAggregateOutputType | null
    _max: Media_metaMaxAggregateOutputType | null
  }

  type GetMedia_metaGroupByPayload<T extends Media_metaGroupByArgs> = Promise<
    Array<
      PickArray<Media_metaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Media_metaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Media_metaGroupByOutputType[P]>
            : GetScalarType<T[P], Media_metaGroupByOutputType[P]>
        }
      >
    >


  export type media_metaSelect = {
    id?: boolean
    path?: boolean
    mime_type?: boolean
    file_size?: boolean
    media?: boolean | mediaArgs
    media_id?: boolean
    media_type?: boolean | media_typeArgs
    media_type_id?: boolean
  }

  export type media_metaInclude = {
    media?: boolean | mediaArgs
    media_type?: boolean | media_typeArgs
  }

  export type media_metaGetPayload<
    S extends boolean | null | undefined | media_metaArgs,
    U = keyof S
      > = S extends true
        ? media_meta
    : S extends undefined
    ? never
    : S extends media_metaArgs | media_metaFindManyArgs
    ?'include' extends U
    ? media_meta  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'media'
        ? mediaGetPayload<S['include'][P]> :
        P extends 'media_type'
        ? media_typeGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof media_meta ?media_meta [P]
  : 
          P extends 'media'
        ? mediaGetPayload<S['select'][P]> :
        P extends 'media_type'
        ? media_typeGetPayload<S['select'][P]> : never
  } 
    : media_meta
  : media_meta


  type media_metaCountArgs = Merge<
    Omit<media_metaFindManyArgs, 'select' | 'include'> & {
      select?: Media_metaCountAggregateInputType | true
    }
  >

  export interface media_metaDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Media_meta that matches the filter.
     * @param {media_metaFindUniqueArgs} args - Arguments to find a Media_meta
     * @example
     * // Get one Media_meta
     * const media_meta = await prisma.media_meta.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends media_metaFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, media_metaFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'media_meta'> extends True ? CheckSelect<T, Prisma__media_metaClient<media_meta>, Prisma__media_metaClient<media_metaGetPayload<T>>> : CheckSelect<T, Prisma__media_metaClient<media_meta | null >, Prisma__media_metaClient<media_metaGetPayload<T> | null >>

    /**
     * Find the first Media_meta that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {media_metaFindFirstArgs} args - Arguments to find a Media_meta
     * @example
     * // Get one Media_meta
     * const media_meta = await prisma.media_meta.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends media_metaFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, media_metaFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'media_meta'> extends True ? CheckSelect<T, Prisma__media_metaClient<media_meta>, Prisma__media_metaClient<media_metaGetPayload<T>>> : CheckSelect<T, Prisma__media_metaClient<media_meta | null >, Prisma__media_metaClient<media_metaGetPayload<T> | null >>

    /**
     * Find zero or more Media_metas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {media_metaFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Media_metas
     * const media_metas = await prisma.media_meta.findMany()
     * 
     * // Get first 10 Media_metas
     * const media_metas = await prisma.media_meta.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const media_metaWithIdOnly = await prisma.media_meta.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends media_metaFindManyArgs>(
      args?: SelectSubset<T, media_metaFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<media_meta>>, PrismaPromise<Array<media_metaGetPayload<T>>>>

    /**
     * Create a Media_meta.
     * @param {media_metaCreateArgs} args - Arguments to create a Media_meta.
     * @example
     * // Create one Media_meta
     * const Media_meta = await prisma.media_meta.create({
     *   data: {
     *     // ... data to create a Media_meta
     *   }
     * })
     * 
    **/
    create<T extends media_metaCreateArgs>(
      args: SelectSubset<T, media_metaCreateArgs>
    ): CheckSelect<T, Prisma__media_metaClient<media_meta>, Prisma__media_metaClient<media_metaGetPayload<T>>>

    /**
     * Create many Media_metas.
     *     @param {media_metaCreateManyArgs} args - Arguments to create many Media_metas.
     *     @example
     *     // Create many Media_metas
     *     const media_meta = await prisma.media_meta.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends media_metaCreateManyArgs>(
      args?: SelectSubset<T, media_metaCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Media_meta.
     * @param {media_metaDeleteArgs} args - Arguments to delete one Media_meta.
     * @example
     * // Delete one Media_meta
     * const Media_meta = await prisma.media_meta.delete({
     *   where: {
     *     // ... filter to delete one Media_meta
     *   }
     * })
     * 
    **/
    delete<T extends media_metaDeleteArgs>(
      args: SelectSubset<T, media_metaDeleteArgs>
    ): CheckSelect<T, Prisma__media_metaClient<media_meta>, Prisma__media_metaClient<media_metaGetPayload<T>>>

    /**
     * Update one Media_meta.
     * @param {media_metaUpdateArgs} args - Arguments to update one Media_meta.
     * @example
     * // Update one Media_meta
     * const media_meta = await prisma.media_meta.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends media_metaUpdateArgs>(
      args: SelectSubset<T, media_metaUpdateArgs>
    ): CheckSelect<T, Prisma__media_metaClient<media_meta>, Prisma__media_metaClient<media_metaGetPayload<T>>>

    /**
     * Delete zero or more Media_metas.
     * @param {media_metaDeleteManyArgs} args - Arguments to filter Media_metas to delete.
     * @example
     * // Delete a few Media_metas
     * const { count } = await prisma.media_meta.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends media_metaDeleteManyArgs>(
      args?: SelectSubset<T, media_metaDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Media_metas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {media_metaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Media_metas
     * const media_meta = await prisma.media_meta.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends media_metaUpdateManyArgs>(
      args: SelectSubset<T, media_metaUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Media_meta.
     * @param {media_metaUpsertArgs} args - Arguments to update or create a Media_meta.
     * @example
     * // Update or create a Media_meta
     * const media_meta = await prisma.media_meta.upsert({
     *   create: {
     *     // ... data to create a Media_meta
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Media_meta we want to update
     *   }
     * })
    **/
    upsert<T extends media_metaUpsertArgs>(
      args: SelectSubset<T, media_metaUpsertArgs>
    ): CheckSelect<T, Prisma__media_metaClient<media_meta>, Prisma__media_metaClient<media_metaGetPayload<T>>>

    /**
     * Count the number of Media_metas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {media_metaCountArgs} args - Arguments to filter Media_metas to count.
     * @example
     * // Count the number of Media_metas
     * const count = await prisma.media_meta.count({
     *   where: {
     *     // ... the filter for the Media_metas we want to count
     *   }
     * })
    **/
    count<T extends media_metaCountArgs>(
      args?: Subset<T, media_metaCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Media_metaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Media_meta.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Media_metaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Media_metaAggregateArgs>(args: Subset<T, Media_metaAggregateArgs>): PrismaPromise<GetMedia_metaAggregateType<T>>

    /**
     * Group by Media_meta.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Media_metaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Media_metaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Media_metaGroupByArgs['orderBy'] }
        : { orderBy?: Media_metaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Media_metaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMedia_metaGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for media_meta.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__media_metaClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    media<T extends mediaArgs = {}>(args?: Subset<T, mediaArgs>): CheckSelect<T, Prisma__mediaClient<media | null >, Prisma__mediaClient<mediaGetPayload<T> | null >>;

    media_type<T extends media_typeArgs = {}>(args?: Subset<T, media_typeArgs>): CheckSelect<T, Prisma__media_typeClient<media_type | null >, Prisma__media_typeClient<media_typeGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * media_meta findUnique
   */
  export type media_metaFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the media_meta
     * 
    **/
    select?: media_metaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: media_metaInclude | null
    /**
     * Throw an Error if a media_meta can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which media_meta to fetch.
     * 
    **/
    where: media_metaWhereUniqueInput
  }


  /**
   * media_meta findFirst
   */
  export type media_metaFindFirstArgs = {
    /**
     * Select specific fields to fetch from the media_meta
     * 
    **/
    select?: media_metaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: media_metaInclude | null
    /**
     * Throw an Error if a media_meta can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which media_meta to fetch.
     * 
    **/
    where?: media_metaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of media_metas to fetch.
     * 
    **/
    orderBy?: Enumerable<media_metaOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for media_metas.
     * 
    **/
    cursor?: media_metaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` media_metas from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` media_metas.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of media_metas.
     * 
    **/
    distinct?: Enumerable<Media_metaScalarFieldEnum>
  }


  /**
   * media_meta findMany
   */
  export type media_metaFindManyArgs = {
    /**
     * Select specific fields to fetch from the media_meta
     * 
    **/
    select?: media_metaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: media_metaInclude | null
    /**
     * Filter, which media_metas to fetch.
     * 
    **/
    where?: media_metaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of media_metas to fetch.
     * 
    **/
    orderBy?: Enumerable<media_metaOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing media_metas.
     * 
    **/
    cursor?: media_metaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` media_metas from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` media_metas.
     * 
    **/
    skip?: number
    distinct?: Enumerable<Media_metaScalarFieldEnum>
  }


  /**
   * media_meta create
   */
  export type media_metaCreateArgs = {
    /**
     * Select specific fields to fetch from the media_meta
     * 
    **/
    select?: media_metaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: media_metaInclude | null
    /**
     * The data needed to create a media_meta.
     * 
    **/
    data: XOR<media_metaCreateInput, media_metaUncheckedCreateInput>
  }


  /**
   * media_meta createMany
   */
  export type media_metaCreateManyArgs = {
    data: Enumerable<media_metaCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * media_meta update
   */
  export type media_metaUpdateArgs = {
    /**
     * Select specific fields to fetch from the media_meta
     * 
    **/
    select?: media_metaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: media_metaInclude | null
    /**
     * The data needed to update a media_meta.
     * 
    **/
    data: XOR<media_metaUpdateInput, media_metaUncheckedUpdateInput>
    /**
     * Choose, which media_meta to update.
     * 
    **/
    where: media_metaWhereUniqueInput
  }


  /**
   * media_meta updateMany
   */
  export type media_metaUpdateManyArgs = {
    data: XOR<media_metaUpdateManyMutationInput, media_metaUncheckedUpdateManyInput>
    where?: media_metaWhereInput
  }


  /**
   * media_meta upsert
   */
  export type media_metaUpsertArgs = {
    /**
     * Select specific fields to fetch from the media_meta
     * 
    **/
    select?: media_metaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: media_metaInclude | null
    /**
     * The filter to search for the media_meta to update in case it exists.
     * 
    **/
    where: media_metaWhereUniqueInput
    /**
     * In case the media_meta found by the `where` argument doesn't exist, create a new media_meta with this data.
     * 
    **/
    create: XOR<media_metaCreateInput, media_metaUncheckedCreateInput>
    /**
     * In case the media_meta was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<media_metaUpdateInput, media_metaUncheckedUpdateInput>
  }


  /**
   * media_meta delete
   */
  export type media_metaDeleteArgs = {
    /**
     * Select specific fields to fetch from the media_meta
     * 
    **/
    select?: media_metaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: media_metaInclude | null
    /**
     * Filter which media_meta to delete.
     * 
    **/
    where: media_metaWhereUniqueInput
  }


  /**
   * media_meta deleteMany
   */
  export type media_metaDeleteManyArgs = {
    where?: media_metaWhereInput
  }


  /**
   * media_meta without action
   */
  export type media_metaArgs = {
    /**
     * Select specific fields to fetch from the media_meta
     * 
    **/
    select?: media_metaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: media_metaInclude | null
  }



  /**
   * Model media_type
   */


  export type AggregateMedia_type = {
    _count: Media_typeCountAggregateOutputType | null
    _avg: Media_typeAvgAggregateOutputType | null
    _sum: Media_typeSumAggregateOutputType | null
    _min: Media_typeMinAggregateOutputType | null
    _max: Media_typeMaxAggregateOutputType | null
  }

  export type Media_typeAvgAggregateOutputType = {
    id: number | null
  }

  export type Media_typeSumAggregateOutputType = {
    id: number | null
  }

  export type Media_typeMinAggregateOutputType = {
    id: number | null
    name: string | null
    thumnail: boolean | null
    medium: boolean | null
    large: boolean | null
    original: boolean | null
  }

  export type Media_typeMaxAggregateOutputType = {
    id: number | null
    name: string | null
    thumnail: boolean | null
    medium: boolean | null
    large: boolean | null
    original: boolean | null
  }

  export type Media_typeCountAggregateOutputType = {
    id: number
    name: number
    thumnail: number
    medium: number
    large: number
    original: number
    _all: number
  }


  export type Media_typeAvgAggregateInputType = {
    id?: true
  }

  export type Media_typeSumAggregateInputType = {
    id?: true
  }

  export type Media_typeMinAggregateInputType = {
    id?: true
    name?: true
    thumnail?: true
    medium?: true
    large?: true
    original?: true
  }

  export type Media_typeMaxAggregateInputType = {
    id?: true
    name?: true
    thumnail?: true
    medium?: true
    large?: true
    original?: true
  }

  export type Media_typeCountAggregateInputType = {
    id?: true
    name?: true
    thumnail?: true
    medium?: true
    large?: true
    original?: true
    _all?: true
  }

  export type Media_typeAggregateArgs = {
    /**
     * Filter which media_type to aggregate.
     * 
    **/
    where?: media_typeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of media_types to fetch.
     * 
    **/
    orderBy?: Enumerable<media_typeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: media_typeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` media_types from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` media_types.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned media_types
    **/
    _count?: true | Media_typeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Media_typeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Media_typeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Media_typeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Media_typeMaxAggregateInputType
  }

  export type GetMedia_typeAggregateType<T extends Media_typeAggregateArgs> = {
        [P in keyof T & keyof AggregateMedia_type]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMedia_type[P]>
      : GetScalarType<T[P], AggregateMedia_type[P]>
  }




  export type Media_typeGroupByArgs = {
    where?: media_typeWhereInput
    orderBy?: Enumerable<media_typeOrderByWithAggregationInput>
    by: Array<Media_typeScalarFieldEnum>
    having?: media_typeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Media_typeCountAggregateInputType | true
    _avg?: Media_typeAvgAggregateInputType
    _sum?: Media_typeSumAggregateInputType
    _min?: Media_typeMinAggregateInputType
    _max?: Media_typeMaxAggregateInputType
  }


  export type Media_typeGroupByOutputType = {
    id: number
    name: string
    thumnail: boolean
    medium: boolean
    large: boolean
    original: boolean
    _count: Media_typeCountAggregateOutputType | null
    _avg: Media_typeAvgAggregateOutputType | null
    _sum: Media_typeSumAggregateOutputType | null
    _min: Media_typeMinAggregateOutputType | null
    _max: Media_typeMaxAggregateOutputType | null
  }

  type GetMedia_typeGroupByPayload<T extends Media_typeGroupByArgs> = Promise<
    Array<
      PickArray<Media_typeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Media_typeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Media_typeGroupByOutputType[P]>
            : GetScalarType<T[P], Media_typeGroupByOutputType[P]>
        }
      >
    >


  export type media_typeSelect = {
    id?: boolean
    name?: boolean
    thumnail?: boolean
    medium?: boolean
    large?: boolean
    original?: boolean
    media_meta?: boolean | media_metaFindManyArgs
    _count?: boolean | Media_typeCountOutputTypeArgs
  }

  export type media_typeInclude = {
    media_meta?: boolean | media_metaFindManyArgs
    _count?: boolean | Media_typeCountOutputTypeArgs
  }

  export type media_typeGetPayload<
    S extends boolean | null | undefined | media_typeArgs,
    U = keyof S
      > = S extends true
        ? media_type
    : S extends undefined
    ? never
    : S extends media_typeArgs | media_typeFindManyArgs
    ?'include' extends U
    ? media_type  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'media_meta'
        ? Array < media_metaGetPayload<S['include'][P]>>  :
        P extends '_count'
        ? Media_typeCountOutputTypeGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof media_type ?media_type [P]
  : 
          P extends 'media_meta'
        ? Array < media_metaGetPayload<S['select'][P]>>  :
        P extends '_count'
        ? Media_typeCountOutputTypeGetPayload<S['select'][P]> : never
  } 
    : media_type
  : media_type


  type media_typeCountArgs = Merge<
    Omit<media_typeFindManyArgs, 'select' | 'include'> & {
      select?: Media_typeCountAggregateInputType | true
    }
  >

  export interface media_typeDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Media_type that matches the filter.
     * @param {media_typeFindUniqueArgs} args - Arguments to find a Media_type
     * @example
     * // Get one Media_type
     * const media_type = await prisma.media_type.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends media_typeFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, media_typeFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'media_type'> extends True ? CheckSelect<T, Prisma__media_typeClient<media_type>, Prisma__media_typeClient<media_typeGetPayload<T>>> : CheckSelect<T, Prisma__media_typeClient<media_type | null >, Prisma__media_typeClient<media_typeGetPayload<T> | null >>

    /**
     * Find the first Media_type that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {media_typeFindFirstArgs} args - Arguments to find a Media_type
     * @example
     * // Get one Media_type
     * const media_type = await prisma.media_type.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends media_typeFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, media_typeFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'media_type'> extends True ? CheckSelect<T, Prisma__media_typeClient<media_type>, Prisma__media_typeClient<media_typeGetPayload<T>>> : CheckSelect<T, Prisma__media_typeClient<media_type | null >, Prisma__media_typeClient<media_typeGetPayload<T> | null >>

    /**
     * Find zero or more Media_types that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {media_typeFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Media_types
     * const media_types = await prisma.media_type.findMany()
     * 
     * // Get first 10 Media_types
     * const media_types = await prisma.media_type.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const media_typeWithIdOnly = await prisma.media_type.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends media_typeFindManyArgs>(
      args?: SelectSubset<T, media_typeFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<media_type>>, PrismaPromise<Array<media_typeGetPayload<T>>>>

    /**
     * Create a Media_type.
     * @param {media_typeCreateArgs} args - Arguments to create a Media_type.
     * @example
     * // Create one Media_type
     * const Media_type = await prisma.media_type.create({
     *   data: {
     *     // ... data to create a Media_type
     *   }
     * })
     * 
    **/
    create<T extends media_typeCreateArgs>(
      args: SelectSubset<T, media_typeCreateArgs>
    ): CheckSelect<T, Prisma__media_typeClient<media_type>, Prisma__media_typeClient<media_typeGetPayload<T>>>

    /**
     * Create many Media_types.
     *     @param {media_typeCreateManyArgs} args - Arguments to create many Media_types.
     *     @example
     *     // Create many Media_types
     *     const media_type = await prisma.media_type.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends media_typeCreateManyArgs>(
      args?: SelectSubset<T, media_typeCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Media_type.
     * @param {media_typeDeleteArgs} args - Arguments to delete one Media_type.
     * @example
     * // Delete one Media_type
     * const Media_type = await prisma.media_type.delete({
     *   where: {
     *     // ... filter to delete one Media_type
     *   }
     * })
     * 
    **/
    delete<T extends media_typeDeleteArgs>(
      args: SelectSubset<T, media_typeDeleteArgs>
    ): CheckSelect<T, Prisma__media_typeClient<media_type>, Prisma__media_typeClient<media_typeGetPayload<T>>>

    /**
     * Update one Media_type.
     * @param {media_typeUpdateArgs} args - Arguments to update one Media_type.
     * @example
     * // Update one Media_type
     * const media_type = await prisma.media_type.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends media_typeUpdateArgs>(
      args: SelectSubset<T, media_typeUpdateArgs>
    ): CheckSelect<T, Prisma__media_typeClient<media_type>, Prisma__media_typeClient<media_typeGetPayload<T>>>

    /**
     * Delete zero or more Media_types.
     * @param {media_typeDeleteManyArgs} args - Arguments to filter Media_types to delete.
     * @example
     * // Delete a few Media_types
     * const { count } = await prisma.media_type.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends media_typeDeleteManyArgs>(
      args?: SelectSubset<T, media_typeDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Media_types.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {media_typeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Media_types
     * const media_type = await prisma.media_type.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends media_typeUpdateManyArgs>(
      args: SelectSubset<T, media_typeUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Media_type.
     * @param {media_typeUpsertArgs} args - Arguments to update or create a Media_type.
     * @example
     * // Update or create a Media_type
     * const media_type = await prisma.media_type.upsert({
     *   create: {
     *     // ... data to create a Media_type
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Media_type we want to update
     *   }
     * })
    **/
    upsert<T extends media_typeUpsertArgs>(
      args: SelectSubset<T, media_typeUpsertArgs>
    ): CheckSelect<T, Prisma__media_typeClient<media_type>, Prisma__media_typeClient<media_typeGetPayload<T>>>

    /**
     * Count the number of Media_types.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {media_typeCountArgs} args - Arguments to filter Media_types to count.
     * @example
     * // Count the number of Media_types
     * const count = await prisma.media_type.count({
     *   where: {
     *     // ... the filter for the Media_types we want to count
     *   }
     * })
    **/
    count<T extends media_typeCountArgs>(
      args?: Subset<T, media_typeCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Media_typeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Media_type.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Media_typeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Media_typeAggregateArgs>(args: Subset<T, Media_typeAggregateArgs>): PrismaPromise<GetMedia_typeAggregateType<T>>

    /**
     * Group by Media_type.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Media_typeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Media_typeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Media_typeGroupByArgs['orderBy'] }
        : { orderBy?: Media_typeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Media_typeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMedia_typeGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for media_type.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__media_typeClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    media_meta<T extends media_metaFindManyArgs = {}>(args?: Subset<T, media_metaFindManyArgs>): CheckSelect<T, PrismaPromise<Array<media_meta>>, PrismaPromise<Array<media_metaGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * media_type findUnique
   */
  export type media_typeFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the media_type
     * 
    **/
    select?: media_typeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: media_typeInclude | null
    /**
     * Throw an Error if a media_type can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which media_type to fetch.
     * 
    **/
    where: media_typeWhereUniqueInput
  }


  /**
   * media_type findFirst
   */
  export type media_typeFindFirstArgs = {
    /**
     * Select specific fields to fetch from the media_type
     * 
    **/
    select?: media_typeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: media_typeInclude | null
    /**
     * Throw an Error if a media_type can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which media_type to fetch.
     * 
    **/
    where?: media_typeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of media_types to fetch.
     * 
    **/
    orderBy?: Enumerable<media_typeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for media_types.
     * 
    **/
    cursor?: media_typeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` media_types from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` media_types.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of media_types.
     * 
    **/
    distinct?: Enumerable<Media_typeScalarFieldEnum>
  }


  /**
   * media_type findMany
   */
  export type media_typeFindManyArgs = {
    /**
     * Select specific fields to fetch from the media_type
     * 
    **/
    select?: media_typeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: media_typeInclude | null
    /**
     * Filter, which media_types to fetch.
     * 
    **/
    where?: media_typeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of media_types to fetch.
     * 
    **/
    orderBy?: Enumerable<media_typeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing media_types.
     * 
    **/
    cursor?: media_typeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` media_types from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` media_types.
     * 
    **/
    skip?: number
    distinct?: Enumerable<Media_typeScalarFieldEnum>
  }


  /**
   * media_type create
   */
  export type media_typeCreateArgs = {
    /**
     * Select specific fields to fetch from the media_type
     * 
    **/
    select?: media_typeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: media_typeInclude | null
    /**
     * The data needed to create a media_type.
     * 
    **/
    data: XOR<media_typeCreateInput, media_typeUncheckedCreateInput>
  }


  /**
   * media_type createMany
   */
  export type media_typeCreateManyArgs = {
    data: Enumerable<media_typeCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * media_type update
   */
  export type media_typeUpdateArgs = {
    /**
     * Select specific fields to fetch from the media_type
     * 
    **/
    select?: media_typeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: media_typeInclude | null
    /**
     * The data needed to update a media_type.
     * 
    **/
    data: XOR<media_typeUpdateInput, media_typeUncheckedUpdateInput>
    /**
     * Choose, which media_type to update.
     * 
    **/
    where: media_typeWhereUniqueInput
  }


  /**
   * media_type updateMany
   */
  export type media_typeUpdateManyArgs = {
    data: XOR<media_typeUpdateManyMutationInput, media_typeUncheckedUpdateManyInput>
    where?: media_typeWhereInput
  }


  /**
   * media_type upsert
   */
  export type media_typeUpsertArgs = {
    /**
     * Select specific fields to fetch from the media_type
     * 
    **/
    select?: media_typeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: media_typeInclude | null
    /**
     * The filter to search for the media_type to update in case it exists.
     * 
    **/
    where: media_typeWhereUniqueInput
    /**
     * In case the media_type found by the `where` argument doesn't exist, create a new media_type with this data.
     * 
    **/
    create: XOR<media_typeCreateInput, media_typeUncheckedCreateInput>
    /**
     * In case the media_type was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<media_typeUpdateInput, media_typeUncheckedUpdateInput>
  }


  /**
   * media_type delete
   */
  export type media_typeDeleteArgs = {
    /**
     * Select specific fields to fetch from the media_type
     * 
    **/
    select?: media_typeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: media_typeInclude | null
    /**
     * Filter which media_type to delete.
     * 
    **/
    where: media_typeWhereUniqueInput
  }


  /**
   * media_type deleteMany
   */
  export type media_typeDeleteManyArgs = {
    where?: media_typeWhereInput
  }


  /**
   * media_type without action
   */
  export type media_typeArgs = {
    /**
     * Select specific fields to fetch from the media_type
     * 
    **/
    select?: media_typeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: media_typeInclude | null
  }



  /**
   * Model ad_type
   */


  export type AggregateAd_type = {
    _count: Ad_typeCountAggregateOutputType | null
    _avg: Ad_typeAvgAggregateOutputType | null
    _sum: Ad_typeSumAggregateOutputType | null
    _min: Ad_typeMinAggregateOutputType | null
    _max: Ad_typeMaxAggregateOutputType | null
  }

  export type Ad_typeAvgAggregateOutputType = {
    id: number | null
    house: number | null
    room: number | null
    garage: number | null
    storage: number | null
    office: number | null
    warehouse: number | null
    building: number | null
    new_building: number | null
  }

  export type Ad_typeSumAggregateOutputType = {
    id: number | null
    house: number | null
    room: number | null
    garage: number | null
    storage: number | null
    office: number | null
    warehouse: number | null
    building: number | null
    new_building: number | null
  }

  export type Ad_typeMinAggregateOutputType = {
    id: number | null
    name: string | null
    house: number | null
    room: number | null
    garage: number | null
    storage: number | null
    office: number | null
    warehouse: number | null
    building: number | null
    new_building: number | null
  }

  export type Ad_typeMaxAggregateOutputType = {
    id: number | null
    name: string | null
    house: number | null
    room: number | null
    garage: number | null
    storage: number | null
    office: number | null
    warehouse: number | null
    building: number | null
    new_building: number | null
  }

  export type Ad_typeCountAggregateOutputType = {
    id: number
    name: number
    house: number
    room: number
    garage: number
    storage: number
    office: number
    warehouse: number
    building: number
    new_building: number
    _all: number
  }


  export type Ad_typeAvgAggregateInputType = {
    id?: true
    house?: true
    room?: true
    garage?: true
    storage?: true
    office?: true
    warehouse?: true
    building?: true
    new_building?: true
  }

  export type Ad_typeSumAggregateInputType = {
    id?: true
    house?: true
    room?: true
    garage?: true
    storage?: true
    office?: true
    warehouse?: true
    building?: true
    new_building?: true
  }

  export type Ad_typeMinAggregateInputType = {
    id?: true
    name?: true
    house?: true
    room?: true
    garage?: true
    storage?: true
    office?: true
    warehouse?: true
    building?: true
    new_building?: true
  }

  export type Ad_typeMaxAggregateInputType = {
    id?: true
    name?: true
    house?: true
    room?: true
    garage?: true
    storage?: true
    office?: true
    warehouse?: true
    building?: true
    new_building?: true
  }

  export type Ad_typeCountAggregateInputType = {
    id?: true
    name?: true
    house?: true
    room?: true
    garage?: true
    storage?: true
    office?: true
    warehouse?: true
    building?: true
    new_building?: true
    _all?: true
  }

  export type Ad_typeAggregateArgs = {
    /**
     * Filter which ad_type to aggregate.
     * 
    **/
    where?: ad_typeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ad_types to fetch.
     * 
    **/
    orderBy?: Enumerable<ad_typeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: ad_typeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ad_types from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ad_types.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ad_types
    **/
    _count?: true | Ad_typeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Ad_typeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Ad_typeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Ad_typeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Ad_typeMaxAggregateInputType
  }

  export type GetAd_typeAggregateType<T extends Ad_typeAggregateArgs> = {
        [P in keyof T & keyof AggregateAd_type]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAd_type[P]>
      : GetScalarType<T[P], AggregateAd_type[P]>
  }




  export type Ad_typeGroupByArgs = {
    where?: ad_typeWhereInput
    orderBy?: Enumerable<ad_typeOrderByWithAggregationInput>
    by: Array<Ad_typeScalarFieldEnum>
    having?: ad_typeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Ad_typeCountAggregateInputType | true
    _avg?: Ad_typeAvgAggregateInputType
    _sum?: Ad_typeSumAggregateInputType
    _min?: Ad_typeMinAggregateInputType
    _max?: Ad_typeMaxAggregateInputType
  }


  export type Ad_typeGroupByOutputType = {
    id: number
    name: string
    house: number
    room: number
    garage: number
    storage: number
    office: number
    warehouse: number
    building: number
    new_building: number
    _count: Ad_typeCountAggregateOutputType | null
    _avg: Ad_typeAvgAggregateOutputType | null
    _sum: Ad_typeSumAggregateOutputType | null
    _min: Ad_typeMinAggregateOutputType | null
    _max: Ad_typeMaxAggregateOutputType | null
  }

  type GetAd_typeGroupByPayload<T extends Ad_typeGroupByArgs> = Promise<
    Array<
      PickArray<Ad_typeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Ad_typeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Ad_typeGroupByOutputType[P]>
            : GetScalarType<T[P], Ad_typeGroupByOutputType[P]>
        }
      >
    >


  export type ad_typeSelect = {
    id?: boolean
    name?: boolean
    house?: boolean
    room?: boolean
    garage?: boolean
    storage?: boolean
    office?: boolean
    warehouse?: boolean
    building?: boolean
    new_building?: boolean
    ads?: boolean | adsFindManyArgs
    _count?: boolean | Ad_typeCountOutputTypeArgs
  }

  export type ad_typeInclude = {
    ads?: boolean | adsFindManyArgs
    _count?: boolean | Ad_typeCountOutputTypeArgs
  }

  export type ad_typeGetPayload<
    S extends boolean | null | undefined | ad_typeArgs,
    U = keyof S
      > = S extends true
        ? ad_type
    : S extends undefined
    ? never
    : S extends ad_typeArgs | ad_typeFindManyArgs
    ?'include' extends U
    ? ad_type  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'ads'
        ? Array < adsGetPayload<S['include'][P]>>  :
        P extends '_count'
        ? Ad_typeCountOutputTypeGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof ad_type ?ad_type [P]
  : 
          P extends 'ads'
        ? Array < adsGetPayload<S['select'][P]>>  :
        P extends '_count'
        ? Ad_typeCountOutputTypeGetPayload<S['select'][P]> : never
  } 
    : ad_type
  : ad_type


  type ad_typeCountArgs = Merge<
    Omit<ad_typeFindManyArgs, 'select' | 'include'> & {
      select?: Ad_typeCountAggregateInputType | true
    }
  >

  export interface ad_typeDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Ad_type that matches the filter.
     * @param {ad_typeFindUniqueArgs} args - Arguments to find a Ad_type
     * @example
     * // Get one Ad_type
     * const ad_type = await prisma.ad_type.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ad_typeFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ad_typeFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'ad_type'> extends True ? CheckSelect<T, Prisma__ad_typeClient<ad_type>, Prisma__ad_typeClient<ad_typeGetPayload<T>>> : CheckSelect<T, Prisma__ad_typeClient<ad_type | null >, Prisma__ad_typeClient<ad_typeGetPayload<T> | null >>

    /**
     * Find the first Ad_type that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ad_typeFindFirstArgs} args - Arguments to find a Ad_type
     * @example
     * // Get one Ad_type
     * const ad_type = await prisma.ad_type.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ad_typeFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ad_typeFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'ad_type'> extends True ? CheckSelect<T, Prisma__ad_typeClient<ad_type>, Prisma__ad_typeClient<ad_typeGetPayload<T>>> : CheckSelect<T, Prisma__ad_typeClient<ad_type | null >, Prisma__ad_typeClient<ad_typeGetPayload<T> | null >>

    /**
     * Find zero or more Ad_types that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ad_typeFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Ad_types
     * const ad_types = await prisma.ad_type.findMany()
     * 
     * // Get first 10 Ad_types
     * const ad_types = await prisma.ad_type.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ad_typeWithIdOnly = await prisma.ad_type.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ad_typeFindManyArgs>(
      args?: SelectSubset<T, ad_typeFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<ad_type>>, PrismaPromise<Array<ad_typeGetPayload<T>>>>

    /**
     * Create a Ad_type.
     * @param {ad_typeCreateArgs} args - Arguments to create a Ad_type.
     * @example
     * // Create one Ad_type
     * const Ad_type = await prisma.ad_type.create({
     *   data: {
     *     // ... data to create a Ad_type
     *   }
     * })
     * 
    **/
    create<T extends ad_typeCreateArgs>(
      args: SelectSubset<T, ad_typeCreateArgs>
    ): CheckSelect<T, Prisma__ad_typeClient<ad_type>, Prisma__ad_typeClient<ad_typeGetPayload<T>>>

    /**
     * Create many Ad_types.
     *     @param {ad_typeCreateManyArgs} args - Arguments to create many Ad_types.
     *     @example
     *     // Create many Ad_types
     *     const ad_type = await prisma.ad_type.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ad_typeCreateManyArgs>(
      args?: SelectSubset<T, ad_typeCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Ad_type.
     * @param {ad_typeDeleteArgs} args - Arguments to delete one Ad_type.
     * @example
     * // Delete one Ad_type
     * const Ad_type = await prisma.ad_type.delete({
     *   where: {
     *     // ... filter to delete one Ad_type
     *   }
     * })
     * 
    **/
    delete<T extends ad_typeDeleteArgs>(
      args: SelectSubset<T, ad_typeDeleteArgs>
    ): CheckSelect<T, Prisma__ad_typeClient<ad_type>, Prisma__ad_typeClient<ad_typeGetPayload<T>>>

    /**
     * Update one Ad_type.
     * @param {ad_typeUpdateArgs} args - Arguments to update one Ad_type.
     * @example
     * // Update one Ad_type
     * const ad_type = await prisma.ad_type.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ad_typeUpdateArgs>(
      args: SelectSubset<T, ad_typeUpdateArgs>
    ): CheckSelect<T, Prisma__ad_typeClient<ad_type>, Prisma__ad_typeClient<ad_typeGetPayload<T>>>

    /**
     * Delete zero or more Ad_types.
     * @param {ad_typeDeleteManyArgs} args - Arguments to filter Ad_types to delete.
     * @example
     * // Delete a few Ad_types
     * const { count } = await prisma.ad_type.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ad_typeDeleteManyArgs>(
      args?: SelectSubset<T, ad_typeDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ad_types.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ad_typeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Ad_types
     * const ad_type = await prisma.ad_type.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ad_typeUpdateManyArgs>(
      args: SelectSubset<T, ad_typeUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Ad_type.
     * @param {ad_typeUpsertArgs} args - Arguments to update or create a Ad_type.
     * @example
     * // Update or create a Ad_type
     * const ad_type = await prisma.ad_type.upsert({
     *   create: {
     *     // ... data to create a Ad_type
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Ad_type we want to update
     *   }
     * })
    **/
    upsert<T extends ad_typeUpsertArgs>(
      args: SelectSubset<T, ad_typeUpsertArgs>
    ): CheckSelect<T, Prisma__ad_typeClient<ad_type>, Prisma__ad_typeClient<ad_typeGetPayload<T>>>

    /**
     * Count the number of Ad_types.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ad_typeCountArgs} args - Arguments to filter Ad_types to count.
     * @example
     * // Count the number of Ad_types
     * const count = await prisma.ad_type.count({
     *   where: {
     *     // ... the filter for the Ad_types we want to count
     *   }
     * })
    **/
    count<T extends ad_typeCountArgs>(
      args?: Subset<T, ad_typeCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Ad_typeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Ad_type.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Ad_typeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Ad_typeAggregateArgs>(args: Subset<T, Ad_typeAggregateArgs>): PrismaPromise<GetAd_typeAggregateType<T>>

    /**
     * Group by Ad_type.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Ad_typeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Ad_typeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Ad_typeGroupByArgs['orderBy'] }
        : { orderBy?: Ad_typeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Ad_typeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAd_typeGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for ad_type.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ad_typeClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    ads<T extends adsFindManyArgs = {}>(args?: Subset<T, adsFindManyArgs>): CheckSelect<T, PrismaPromise<Array<ads>>, PrismaPromise<Array<adsGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * ad_type findUnique
   */
  export type ad_typeFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the ad_type
     * 
    **/
    select?: ad_typeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ad_typeInclude | null
    /**
     * Throw an Error if a ad_type can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which ad_type to fetch.
     * 
    **/
    where: ad_typeWhereUniqueInput
  }


  /**
   * ad_type findFirst
   */
  export type ad_typeFindFirstArgs = {
    /**
     * Select specific fields to fetch from the ad_type
     * 
    **/
    select?: ad_typeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ad_typeInclude | null
    /**
     * Throw an Error if a ad_type can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which ad_type to fetch.
     * 
    **/
    where?: ad_typeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ad_types to fetch.
     * 
    **/
    orderBy?: Enumerable<ad_typeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ad_types.
     * 
    **/
    cursor?: ad_typeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ad_types from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ad_types.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ad_types.
     * 
    **/
    distinct?: Enumerable<Ad_typeScalarFieldEnum>
  }


  /**
   * ad_type findMany
   */
  export type ad_typeFindManyArgs = {
    /**
     * Select specific fields to fetch from the ad_type
     * 
    **/
    select?: ad_typeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ad_typeInclude | null
    /**
     * Filter, which ad_types to fetch.
     * 
    **/
    where?: ad_typeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ad_types to fetch.
     * 
    **/
    orderBy?: Enumerable<ad_typeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ad_types.
     * 
    **/
    cursor?: ad_typeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ad_types from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ad_types.
     * 
    **/
    skip?: number
    distinct?: Enumerable<Ad_typeScalarFieldEnum>
  }


  /**
   * ad_type create
   */
  export type ad_typeCreateArgs = {
    /**
     * Select specific fields to fetch from the ad_type
     * 
    **/
    select?: ad_typeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ad_typeInclude | null
    /**
     * The data needed to create a ad_type.
     * 
    **/
    data: XOR<ad_typeCreateInput, ad_typeUncheckedCreateInput>
  }


  /**
   * ad_type createMany
   */
  export type ad_typeCreateManyArgs = {
    data: Enumerable<ad_typeCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * ad_type update
   */
  export type ad_typeUpdateArgs = {
    /**
     * Select specific fields to fetch from the ad_type
     * 
    **/
    select?: ad_typeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ad_typeInclude | null
    /**
     * The data needed to update a ad_type.
     * 
    **/
    data: XOR<ad_typeUpdateInput, ad_typeUncheckedUpdateInput>
    /**
     * Choose, which ad_type to update.
     * 
    **/
    where: ad_typeWhereUniqueInput
  }


  /**
   * ad_type updateMany
   */
  export type ad_typeUpdateManyArgs = {
    data: XOR<ad_typeUpdateManyMutationInput, ad_typeUncheckedUpdateManyInput>
    where?: ad_typeWhereInput
  }


  /**
   * ad_type upsert
   */
  export type ad_typeUpsertArgs = {
    /**
     * Select specific fields to fetch from the ad_type
     * 
    **/
    select?: ad_typeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ad_typeInclude | null
    /**
     * The filter to search for the ad_type to update in case it exists.
     * 
    **/
    where: ad_typeWhereUniqueInput
    /**
     * In case the ad_type found by the `where` argument doesn't exist, create a new ad_type with this data.
     * 
    **/
    create: XOR<ad_typeCreateInput, ad_typeUncheckedCreateInput>
    /**
     * In case the ad_type was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<ad_typeUpdateInput, ad_typeUncheckedUpdateInput>
  }


  /**
   * ad_type delete
   */
  export type ad_typeDeleteArgs = {
    /**
     * Select specific fields to fetch from the ad_type
     * 
    **/
    select?: ad_typeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ad_typeInclude | null
    /**
     * Filter which ad_type to delete.
     * 
    **/
    where: ad_typeWhereUniqueInput
  }


  /**
   * ad_type deleteMany
   */
  export type ad_typeDeleteManyArgs = {
    where?: ad_typeWhereInput
  }


  /**
   * ad_type without action
   */
  export type ad_typeArgs = {
    /**
     * Select specific fields to fetch from the ad_type
     * 
    **/
    select?: ad_typeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ad_typeInclude | null
  }



  /**
   * Model ads
   */


  export type AggregateAds = {
    _count: AdsCountAggregateOutputType | null
    _avg: AdsAvgAggregateOutputType | null
    _sum: AdsSumAggregateOutputType | null
    _min: AdsMinAggregateOutputType | null
    _max: AdsMaxAggregateOutputType | null
  }

  export type AdsAvgAggregateOutputType = {
    id: number | null
    user_id: number | null
    n_rooms: number | null
    price: number | null
    square_meters: number | null
    n_bathrooms: number | null
    map_lat: Decimal | null
    map_lon: Decimal | null
    ad_type_id: number | null
  }

  export type AdsSumAggregateOutputType = {
    id: number | null
    user_id: number | null
    n_rooms: number | null
    price: number | null
    square_meters: number | null
    n_bathrooms: number | null
    map_lat: Decimal | null
    map_lon: Decimal | null
    ad_type_id: number | null
  }

  export type AdsMinAggregateOutputType = {
    id: number | null
    user_id: number | null
    title: string | null
    description: string | null
    city: string | null
    n_rooms: number | null
    price: number | null
    square_meters: number | null
    n_bathrooms: number | null
    map_lat: Decimal | null
    map_lon: Decimal | null
    ad_type_id: number | null
  }

  export type AdsMaxAggregateOutputType = {
    id: number | null
    user_id: number | null
    title: string | null
    description: string | null
    city: string | null
    n_rooms: number | null
    price: number | null
    square_meters: number | null
    n_bathrooms: number | null
    map_lat: Decimal | null
    map_lon: Decimal | null
    ad_type_id: number | null
  }

  export type AdsCountAggregateOutputType = {
    id: number
    user_id: number
    title: number
    description: number
    city: number
    n_rooms: number
    price: number
    square_meters: number
    n_bathrooms: number
    map_lat: number
    map_lon: number
    ad_type_id: number
    _all: number
  }


  export type AdsAvgAggregateInputType = {
    id?: true
    user_id?: true
    n_rooms?: true
    price?: true
    square_meters?: true
    n_bathrooms?: true
    map_lat?: true
    map_lon?: true
    ad_type_id?: true
  }

  export type AdsSumAggregateInputType = {
    id?: true
    user_id?: true
    n_rooms?: true
    price?: true
    square_meters?: true
    n_bathrooms?: true
    map_lat?: true
    map_lon?: true
    ad_type_id?: true
  }

  export type AdsMinAggregateInputType = {
    id?: true
    user_id?: true
    title?: true
    description?: true
    city?: true
    n_rooms?: true
    price?: true
    square_meters?: true
    n_bathrooms?: true
    map_lat?: true
    map_lon?: true
    ad_type_id?: true
  }

  export type AdsMaxAggregateInputType = {
    id?: true
    user_id?: true
    title?: true
    description?: true
    city?: true
    n_rooms?: true
    price?: true
    square_meters?: true
    n_bathrooms?: true
    map_lat?: true
    map_lon?: true
    ad_type_id?: true
  }

  export type AdsCountAggregateInputType = {
    id?: true
    user_id?: true
    title?: true
    description?: true
    city?: true
    n_rooms?: true
    price?: true
    square_meters?: true
    n_bathrooms?: true
    map_lat?: true
    map_lon?: true
    ad_type_id?: true
    _all?: true
  }

  export type AdsAggregateArgs = {
    /**
     * Filter which ads to aggregate.
     * 
    **/
    where?: adsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ads to fetch.
     * 
    **/
    orderBy?: Enumerable<adsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: adsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ads from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ads.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ads
    **/
    _count?: true | AdsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AdsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AdsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdsMaxAggregateInputType
  }

  export type GetAdsAggregateType<T extends AdsAggregateArgs> = {
        [P in keyof T & keyof AggregateAds]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAds[P]>
      : GetScalarType<T[P], AggregateAds[P]>
  }




  export type AdsGroupByArgs = {
    where?: adsWhereInput
    orderBy?: Enumerable<adsOrderByWithAggregationInput>
    by: Array<AdsScalarFieldEnum>
    having?: adsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdsCountAggregateInputType | true
    _avg?: AdsAvgAggregateInputType
    _sum?: AdsSumAggregateInputType
    _min?: AdsMinAggregateInputType
    _max?: AdsMaxAggregateInputType
  }


  export type AdsGroupByOutputType = {
    id: number
    user_id: number
    title: string
    description: string
    city: string
    n_rooms: number
    price: number
    square_meters: number
    n_bathrooms: number
    map_lat: Decimal
    map_lon: Decimal
    ad_type_id: number
    _count: AdsCountAggregateOutputType | null
    _avg: AdsAvgAggregateOutputType | null
    _sum: AdsSumAggregateOutputType | null
    _min: AdsMinAggregateOutputType | null
    _max: AdsMaxAggregateOutputType | null
  }

  type GetAdsGroupByPayload<T extends AdsGroupByArgs> = Promise<
    Array<
      PickArray<AdsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdsGroupByOutputType[P]>
            : GetScalarType<T[P], AdsGroupByOutputType[P]>
        }
      >
    >


  export type adsSelect = {
    id?: boolean
    user?: boolean | userArgs
    user_id?: boolean
    title?: boolean
    description?: boolean
    city?: boolean
    n_rooms?: boolean
    price?: boolean
    square_meters?: boolean
    n_bathrooms?: boolean
    map_lat?: boolean
    map_lon?: boolean
    ad_type_id?: boolean
    ad_type?: boolean | ad_typeArgs
  }

  export type adsInclude = {
    user?: boolean | userArgs
    ad_type?: boolean | ad_typeArgs
  }

  export type adsGetPayload<
    S extends boolean | null | undefined | adsArgs,
    U = keyof S
      > = S extends true
        ? ads
    : S extends undefined
    ? never
    : S extends adsArgs | adsFindManyArgs
    ?'include' extends U
    ? ads  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'user'
        ? userGetPayload<S['include'][P]> :
        P extends 'ad_type'
        ? ad_typeGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof ads ?ads [P]
  : 
          P extends 'user'
        ? userGetPayload<S['select'][P]> :
        P extends 'ad_type'
        ? ad_typeGetPayload<S['select'][P]> : never
  } 
    : ads
  : ads


  type adsCountArgs = Merge<
    Omit<adsFindManyArgs, 'select' | 'include'> & {
      select?: AdsCountAggregateInputType | true
    }
  >

  export interface adsDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Ads that matches the filter.
     * @param {adsFindUniqueArgs} args - Arguments to find a Ads
     * @example
     * // Get one Ads
     * const ads = await prisma.ads.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends adsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, adsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'ads'> extends True ? CheckSelect<T, Prisma__adsClient<ads>, Prisma__adsClient<adsGetPayload<T>>> : CheckSelect<T, Prisma__adsClient<ads | null >, Prisma__adsClient<adsGetPayload<T> | null >>

    /**
     * Find the first Ads that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {adsFindFirstArgs} args - Arguments to find a Ads
     * @example
     * // Get one Ads
     * const ads = await prisma.ads.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends adsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, adsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'ads'> extends True ? CheckSelect<T, Prisma__adsClient<ads>, Prisma__adsClient<adsGetPayload<T>>> : CheckSelect<T, Prisma__adsClient<ads | null >, Prisma__adsClient<adsGetPayload<T> | null >>

    /**
     * Find zero or more Ads that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {adsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Ads
     * const ads = await prisma.ads.findMany()
     * 
     * // Get first 10 Ads
     * const ads = await prisma.ads.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const adsWithIdOnly = await prisma.ads.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends adsFindManyArgs>(
      args?: SelectSubset<T, adsFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<ads>>, PrismaPromise<Array<adsGetPayload<T>>>>

    /**
     * Create a Ads.
     * @param {adsCreateArgs} args - Arguments to create a Ads.
     * @example
     * // Create one Ads
     * const Ads = await prisma.ads.create({
     *   data: {
     *     // ... data to create a Ads
     *   }
     * })
     * 
    **/
    create<T extends adsCreateArgs>(
      args: SelectSubset<T, adsCreateArgs>
    ): CheckSelect<T, Prisma__adsClient<ads>, Prisma__adsClient<adsGetPayload<T>>>

    /**
     * Create many Ads.
     *     @param {adsCreateManyArgs} args - Arguments to create many Ads.
     *     @example
     *     // Create many Ads
     *     const ads = await prisma.ads.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends adsCreateManyArgs>(
      args?: SelectSubset<T, adsCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Ads.
     * @param {adsDeleteArgs} args - Arguments to delete one Ads.
     * @example
     * // Delete one Ads
     * const Ads = await prisma.ads.delete({
     *   where: {
     *     // ... filter to delete one Ads
     *   }
     * })
     * 
    **/
    delete<T extends adsDeleteArgs>(
      args: SelectSubset<T, adsDeleteArgs>
    ): CheckSelect<T, Prisma__adsClient<ads>, Prisma__adsClient<adsGetPayload<T>>>

    /**
     * Update one Ads.
     * @param {adsUpdateArgs} args - Arguments to update one Ads.
     * @example
     * // Update one Ads
     * const ads = await prisma.ads.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends adsUpdateArgs>(
      args: SelectSubset<T, adsUpdateArgs>
    ): CheckSelect<T, Prisma__adsClient<ads>, Prisma__adsClient<adsGetPayload<T>>>

    /**
     * Delete zero or more Ads.
     * @param {adsDeleteManyArgs} args - Arguments to filter Ads to delete.
     * @example
     * // Delete a few Ads
     * const { count } = await prisma.ads.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends adsDeleteManyArgs>(
      args?: SelectSubset<T, adsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {adsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Ads
     * const ads = await prisma.ads.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends adsUpdateManyArgs>(
      args: SelectSubset<T, adsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Ads.
     * @param {adsUpsertArgs} args - Arguments to update or create a Ads.
     * @example
     * // Update or create a Ads
     * const ads = await prisma.ads.upsert({
     *   create: {
     *     // ... data to create a Ads
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Ads we want to update
     *   }
     * })
    **/
    upsert<T extends adsUpsertArgs>(
      args: SelectSubset<T, adsUpsertArgs>
    ): CheckSelect<T, Prisma__adsClient<ads>, Prisma__adsClient<adsGetPayload<T>>>

    /**
     * Count the number of Ads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {adsCountArgs} args - Arguments to filter Ads to count.
     * @example
     * // Count the number of Ads
     * const count = await prisma.ads.count({
     *   where: {
     *     // ... the filter for the Ads we want to count
     *   }
     * })
    **/
    count<T extends adsCountArgs>(
      args?: Subset<T, adsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Ads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdsAggregateArgs>(args: Subset<T, AdsAggregateArgs>): PrismaPromise<GetAdsAggregateType<T>>

    /**
     * Group by Ads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AdsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdsGroupByArgs['orderBy'] }
        : { orderBy?: AdsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AdsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdsGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for ads.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__adsClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    user<T extends userArgs = {}>(args?: Subset<T, userArgs>): CheckSelect<T, Prisma__userClient<user | null >, Prisma__userClient<userGetPayload<T> | null >>;

    ad_type<T extends ad_typeArgs = {}>(args?: Subset<T, ad_typeArgs>): CheckSelect<T, Prisma__ad_typeClient<ad_type | null >, Prisma__ad_typeClient<ad_typeGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * ads findUnique
   */
  export type adsFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the ads
     * 
    **/
    select?: adsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: adsInclude | null
    /**
     * Throw an Error if a ads can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which ads to fetch.
     * 
    **/
    where: adsWhereUniqueInput
  }


  /**
   * ads findFirst
   */
  export type adsFindFirstArgs = {
    /**
     * Select specific fields to fetch from the ads
     * 
    **/
    select?: adsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: adsInclude | null
    /**
     * Throw an Error if a ads can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which ads to fetch.
     * 
    **/
    where?: adsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ads to fetch.
     * 
    **/
    orderBy?: Enumerable<adsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ads.
     * 
    **/
    cursor?: adsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ads from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ads.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ads.
     * 
    **/
    distinct?: Enumerable<AdsScalarFieldEnum>
  }


  /**
   * ads findMany
   */
  export type adsFindManyArgs = {
    /**
     * Select specific fields to fetch from the ads
     * 
    **/
    select?: adsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: adsInclude | null
    /**
     * Filter, which ads to fetch.
     * 
    **/
    where?: adsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ads to fetch.
     * 
    **/
    orderBy?: Enumerable<adsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ads.
     * 
    **/
    cursor?: adsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ads from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ads.
     * 
    **/
    skip?: number
    distinct?: Enumerable<AdsScalarFieldEnum>
  }


  /**
   * ads create
   */
  export type adsCreateArgs = {
    /**
     * Select specific fields to fetch from the ads
     * 
    **/
    select?: adsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: adsInclude | null
    /**
     * The data needed to create a ads.
     * 
    **/
    data: XOR<adsCreateInput, adsUncheckedCreateInput>
  }


  /**
   * ads createMany
   */
  export type adsCreateManyArgs = {
    data: Enumerable<adsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * ads update
   */
  export type adsUpdateArgs = {
    /**
     * Select specific fields to fetch from the ads
     * 
    **/
    select?: adsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: adsInclude | null
    /**
     * The data needed to update a ads.
     * 
    **/
    data: XOR<adsUpdateInput, adsUncheckedUpdateInput>
    /**
     * Choose, which ads to update.
     * 
    **/
    where: adsWhereUniqueInput
  }


  /**
   * ads updateMany
   */
  export type adsUpdateManyArgs = {
    data: XOR<adsUpdateManyMutationInput, adsUncheckedUpdateManyInput>
    where?: adsWhereInput
  }


  /**
   * ads upsert
   */
  export type adsUpsertArgs = {
    /**
     * Select specific fields to fetch from the ads
     * 
    **/
    select?: adsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: adsInclude | null
    /**
     * The filter to search for the ads to update in case it exists.
     * 
    **/
    where: adsWhereUniqueInput
    /**
     * In case the ads found by the `where` argument doesn't exist, create a new ads with this data.
     * 
    **/
    create: XOR<adsCreateInput, adsUncheckedCreateInput>
    /**
     * In case the ads was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<adsUpdateInput, adsUncheckedUpdateInput>
  }


  /**
   * ads delete
   */
  export type adsDeleteArgs = {
    /**
     * Select specific fields to fetch from the ads
     * 
    **/
    select?: adsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: adsInclude | null
    /**
     * Filter which ads to delete.
     * 
    **/
    where: adsWhereUniqueInput
  }


  /**
   * ads deleteMany
   */
  export type adsDeleteManyArgs = {
    where?: adsWhereInput
  }


  /**
   * ads without action
   */
  export type adsArgs = {
    /**
     * Select specific fields to fetch from the ads
     * 
    **/
    select?: adsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: adsInclude | null
  }



  /**
   * Model level
   */


  export type AggregateLevel = {
    _count: LevelCountAggregateOutputType | null
    _avg: LevelAvgAggregateOutputType | null
    _sum: LevelSumAggregateOutputType | null
    _min: LevelMinAggregateOutputType | null
    _max: LevelMaxAggregateOutputType | null
  }

  export type LevelAvgAggregateOutputType = {
    id: number | null
    parent_id: number | null
    level_type_id: number | null
  }

  export type LevelSumAggregateOutputType = {
    id: number | null
    parent_id: number | null
    level_type_id: number | null
  }

  export type LevelMinAggregateOutputType = {
    id: number | null
    name: string | null
    parent_id: number | null
    level_type_id: number | null
  }

  export type LevelMaxAggregateOutputType = {
    id: number | null
    name: string | null
    parent_id: number | null
    level_type_id: number | null
  }

  export type LevelCountAggregateOutputType = {
    id: number
    name: number
    parent_id: number
    level_type_id: number
    _all: number
  }


  export type LevelAvgAggregateInputType = {
    id?: true
    parent_id?: true
    level_type_id?: true
  }

  export type LevelSumAggregateInputType = {
    id?: true
    parent_id?: true
    level_type_id?: true
  }

  export type LevelMinAggregateInputType = {
    id?: true
    name?: true
    parent_id?: true
    level_type_id?: true
  }

  export type LevelMaxAggregateInputType = {
    id?: true
    name?: true
    parent_id?: true
    level_type_id?: true
  }

  export type LevelCountAggregateInputType = {
    id?: true
    name?: true
    parent_id?: true
    level_type_id?: true
    _all?: true
  }

  export type LevelAggregateArgs = {
    /**
     * Filter which level to aggregate.
     * 
    **/
    where?: levelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of levels to fetch.
     * 
    **/
    orderBy?: Enumerable<levelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: levelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` levels from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` levels.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned levels
    **/
    _count?: true | LevelCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LevelAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LevelSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LevelMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LevelMaxAggregateInputType
  }

  export type GetLevelAggregateType<T extends LevelAggregateArgs> = {
        [P in keyof T & keyof AggregateLevel]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLevel[P]>
      : GetScalarType<T[P], AggregateLevel[P]>
  }




  export type LevelGroupByArgs = {
    where?: levelWhereInput
    orderBy?: Enumerable<levelOrderByWithAggregationInput>
    by: Array<LevelScalarFieldEnum>
    having?: levelScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LevelCountAggregateInputType | true
    _avg?: LevelAvgAggregateInputType
    _sum?: LevelSumAggregateInputType
    _min?: LevelMinAggregateInputType
    _max?: LevelMaxAggregateInputType
  }


  export type LevelGroupByOutputType = {
    id: number
    name: string
    parent_id: number | null
    level_type_id: number
    _count: LevelCountAggregateOutputType | null
    _avg: LevelAvgAggregateOutputType | null
    _sum: LevelSumAggregateOutputType | null
    _min: LevelMinAggregateOutputType | null
    _max: LevelMaxAggregateOutputType | null
  }

  type GetLevelGroupByPayload<T extends LevelGroupByArgs> = Promise<
    Array<
      PickArray<LevelGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LevelGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LevelGroupByOutputType[P]>
            : GetScalarType<T[P], LevelGroupByOutputType[P]>
        }
      >
    >


  export type levelSelect = {
    id?: boolean
    name?: boolean
    parent?: boolean | levelArgs
    parent_id?: boolean
    child?: boolean | levelFindManyArgs
    level_type?: boolean | level_typeArgs
    level_type_id?: boolean
    _count?: boolean | LevelCountOutputTypeArgs
  }

  export type levelInclude = {
    parent?: boolean | levelArgs
    child?: boolean | levelFindManyArgs
    level_type?: boolean | level_typeArgs
    _count?: boolean | LevelCountOutputTypeArgs
  }

  export type levelGetPayload<
    S extends boolean | null | undefined | levelArgs,
    U = keyof S
      > = S extends true
        ? level
    : S extends undefined
    ? never
    : S extends levelArgs | levelFindManyArgs
    ?'include' extends U
    ? level  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'parent'
        ? levelGetPayload<S['include'][P]> | null :
        P extends 'child'
        ? Array < levelGetPayload<S['include'][P]>>  :
        P extends 'level_type'
        ? level_typeGetPayload<S['include'][P]> :
        P extends '_count'
        ? LevelCountOutputTypeGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof level ?level [P]
  : 
          P extends 'parent'
        ? levelGetPayload<S['select'][P]> | null :
        P extends 'child'
        ? Array < levelGetPayload<S['select'][P]>>  :
        P extends 'level_type'
        ? level_typeGetPayload<S['select'][P]> :
        P extends '_count'
        ? LevelCountOutputTypeGetPayload<S['select'][P]> : never
  } 
    : level
  : level


  type levelCountArgs = Merge<
    Omit<levelFindManyArgs, 'select' | 'include'> & {
      select?: LevelCountAggregateInputType | true
    }
  >

  export interface levelDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Level that matches the filter.
     * @param {levelFindUniqueArgs} args - Arguments to find a Level
     * @example
     * // Get one Level
     * const level = await prisma.level.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends levelFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, levelFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'level'> extends True ? CheckSelect<T, Prisma__levelClient<level>, Prisma__levelClient<levelGetPayload<T>>> : CheckSelect<T, Prisma__levelClient<level | null >, Prisma__levelClient<levelGetPayload<T> | null >>

    /**
     * Find the first Level that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {levelFindFirstArgs} args - Arguments to find a Level
     * @example
     * // Get one Level
     * const level = await prisma.level.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends levelFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, levelFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'level'> extends True ? CheckSelect<T, Prisma__levelClient<level>, Prisma__levelClient<levelGetPayload<T>>> : CheckSelect<T, Prisma__levelClient<level | null >, Prisma__levelClient<levelGetPayload<T> | null >>

    /**
     * Find zero or more Levels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {levelFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Levels
     * const levels = await prisma.level.findMany()
     * 
     * // Get first 10 Levels
     * const levels = await prisma.level.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const levelWithIdOnly = await prisma.level.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends levelFindManyArgs>(
      args?: SelectSubset<T, levelFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<level>>, PrismaPromise<Array<levelGetPayload<T>>>>

    /**
     * Create a Level.
     * @param {levelCreateArgs} args - Arguments to create a Level.
     * @example
     * // Create one Level
     * const Level = await prisma.level.create({
     *   data: {
     *     // ... data to create a Level
     *   }
     * })
     * 
    **/
    create<T extends levelCreateArgs>(
      args: SelectSubset<T, levelCreateArgs>
    ): CheckSelect<T, Prisma__levelClient<level>, Prisma__levelClient<levelGetPayload<T>>>

    /**
     * Create many Levels.
     *     @param {levelCreateManyArgs} args - Arguments to create many Levels.
     *     @example
     *     // Create many Levels
     *     const level = await prisma.level.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends levelCreateManyArgs>(
      args?: SelectSubset<T, levelCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Level.
     * @param {levelDeleteArgs} args - Arguments to delete one Level.
     * @example
     * // Delete one Level
     * const Level = await prisma.level.delete({
     *   where: {
     *     // ... filter to delete one Level
     *   }
     * })
     * 
    **/
    delete<T extends levelDeleteArgs>(
      args: SelectSubset<T, levelDeleteArgs>
    ): CheckSelect<T, Prisma__levelClient<level>, Prisma__levelClient<levelGetPayload<T>>>

    /**
     * Update one Level.
     * @param {levelUpdateArgs} args - Arguments to update one Level.
     * @example
     * // Update one Level
     * const level = await prisma.level.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends levelUpdateArgs>(
      args: SelectSubset<T, levelUpdateArgs>
    ): CheckSelect<T, Prisma__levelClient<level>, Prisma__levelClient<levelGetPayload<T>>>

    /**
     * Delete zero or more Levels.
     * @param {levelDeleteManyArgs} args - Arguments to filter Levels to delete.
     * @example
     * // Delete a few Levels
     * const { count } = await prisma.level.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends levelDeleteManyArgs>(
      args?: SelectSubset<T, levelDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Levels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {levelUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Levels
     * const level = await prisma.level.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends levelUpdateManyArgs>(
      args: SelectSubset<T, levelUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Level.
     * @param {levelUpsertArgs} args - Arguments to update or create a Level.
     * @example
     * // Update or create a Level
     * const level = await prisma.level.upsert({
     *   create: {
     *     // ... data to create a Level
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Level we want to update
     *   }
     * })
    **/
    upsert<T extends levelUpsertArgs>(
      args: SelectSubset<T, levelUpsertArgs>
    ): CheckSelect<T, Prisma__levelClient<level>, Prisma__levelClient<levelGetPayload<T>>>

    /**
     * Count the number of Levels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {levelCountArgs} args - Arguments to filter Levels to count.
     * @example
     * // Count the number of Levels
     * const count = await prisma.level.count({
     *   where: {
     *     // ... the filter for the Levels we want to count
     *   }
     * })
    **/
    count<T extends levelCountArgs>(
      args?: Subset<T, levelCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LevelCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Level.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LevelAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LevelAggregateArgs>(args: Subset<T, LevelAggregateArgs>): PrismaPromise<GetLevelAggregateType<T>>

    /**
     * Group by Level.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LevelGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LevelGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LevelGroupByArgs['orderBy'] }
        : { orderBy?: LevelGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LevelGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLevelGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for level.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__levelClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    parent<T extends levelArgs = {}>(args?: Subset<T, levelArgs>): CheckSelect<T, Prisma__levelClient<level | null >, Prisma__levelClient<levelGetPayload<T> | null >>;

    child<T extends levelFindManyArgs = {}>(args?: Subset<T, levelFindManyArgs>): CheckSelect<T, PrismaPromise<Array<level>>, PrismaPromise<Array<levelGetPayload<T>>>>;

    level_type<T extends level_typeArgs = {}>(args?: Subset<T, level_typeArgs>): CheckSelect<T, Prisma__level_typeClient<level_type | null >, Prisma__level_typeClient<level_typeGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * level findUnique
   */
  export type levelFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the level
     * 
    **/
    select?: levelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: levelInclude | null
    /**
     * Throw an Error if a level can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which level to fetch.
     * 
    **/
    where: levelWhereUniqueInput
  }


  /**
   * level findFirst
   */
  export type levelFindFirstArgs = {
    /**
     * Select specific fields to fetch from the level
     * 
    **/
    select?: levelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: levelInclude | null
    /**
     * Throw an Error if a level can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which level to fetch.
     * 
    **/
    where?: levelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of levels to fetch.
     * 
    **/
    orderBy?: Enumerable<levelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for levels.
     * 
    **/
    cursor?: levelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` levels from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` levels.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of levels.
     * 
    **/
    distinct?: Enumerable<LevelScalarFieldEnum>
  }


  /**
   * level findMany
   */
  export type levelFindManyArgs = {
    /**
     * Select specific fields to fetch from the level
     * 
    **/
    select?: levelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: levelInclude | null
    /**
     * Filter, which levels to fetch.
     * 
    **/
    where?: levelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of levels to fetch.
     * 
    **/
    orderBy?: Enumerable<levelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing levels.
     * 
    **/
    cursor?: levelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` levels from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` levels.
     * 
    **/
    skip?: number
    distinct?: Enumerable<LevelScalarFieldEnum>
  }


  /**
   * level create
   */
  export type levelCreateArgs = {
    /**
     * Select specific fields to fetch from the level
     * 
    **/
    select?: levelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: levelInclude | null
    /**
     * The data needed to create a level.
     * 
    **/
    data: XOR<levelCreateInput, levelUncheckedCreateInput>
  }


  /**
   * level createMany
   */
  export type levelCreateManyArgs = {
    data: Enumerable<levelCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * level update
   */
  export type levelUpdateArgs = {
    /**
     * Select specific fields to fetch from the level
     * 
    **/
    select?: levelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: levelInclude | null
    /**
     * The data needed to update a level.
     * 
    **/
    data: XOR<levelUpdateInput, levelUncheckedUpdateInput>
    /**
     * Choose, which level to update.
     * 
    **/
    where: levelWhereUniqueInput
  }


  /**
   * level updateMany
   */
  export type levelUpdateManyArgs = {
    data: XOR<levelUpdateManyMutationInput, levelUncheckedUpdateManyInput>
    where?: levelWhereInput
  }


  /**
   * level upsert
   */
  export type levelUpsertArgs = {
    /**
     * Select specific fields to fetch from the level
     * 
    **/
    select?: levelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: levelInclude | null
    /**
     * The filter to search for the level to update in case it exists.
     * 
    **/
    where: levelWhereUniqueInput
    /**
     * In case the level found by the `where` argument doesn't exist, create a new level with this data.
     * 
    **/
    create: XOR<levelCreateInput, levelUncheckedCreateInput>
    /**
     * In case the level was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<levelUpdateInput, levelUncheckedUpdateInput>
  }


  /**
   * level delete
   */
  export type levelDeleteArgs = {
    /**
     * Select specific fields to fetch from the level
     * 
    **/
    select?: levelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: levelInclude | null
    /**
     * Filter which level to delete.
     * 
    **/
    where: levelWhereUniqueInput
  }


  /**
   * level deleteMany
   */
  export type levelDeleteManyArgs = {
    where?: levelWhereInput
  }


  /**
   * level without action
   */
  export type levelArgs = {
    /**
     * Select specific fields to fetch from the level
     * 
    **/
    select?: levelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: levelInclude | null
  }



  /**
   * Model level_type
   */


  export type AggregateLevel_type = {
    _count: Level_typeCountAggregateOutputType | null
    _avg: Level_typeAvgAggregateOutputType | null
    _sum: Level_typeSumAggregateOutputType | null
    _min: Level_typeMinAggregateOutputType | null
    _max: Level_typeMaxAggregateOutputType | null
  }

  export type Level_typeAvgAggregateOutputType = {
    id: number | null
    country: number | null
    state: number | null
    city: number | null
    town: number | null
    district: number | null
    neighbourhood: number | null
  }

  export type Level_typeSumAggregateOutputType = {
    id: number | null
    country: number | null
    state: number | null
    city: number | null
    town: number | null
    district: number | null
    neighbourhood: number | null
  }

  export type Level_typeMinAggregateOutputType = {
    id: number | null
    name: string | null
    country: number | null
    state: number | null
    city: number | null
    town: number | null
    district: number | null
    neighbourhood: number | null
  }

  export type Level_typeMaxAggregateOutputType = {
    id: number | null
    name: string | null
    country: number | null
    state: number | null
    city: number | null
    town: number | null
    district: number | null
    neighbourhood: number | null
  }

  export type Level_typeCountAggregateOutputType = {
    id: number
    name: number
    country: number
    state: number
    city: number
    town: number
    district: number
    neighbourhood: number
    _all: number
  }


  export type Level_typeAvgAggregateInputType = {
    id?: true
    country?: true
    state?: true
    city?: true
    town?: true
    district?: true
    neighbourhood?: true
  }

  export type Level_typeSumAggregateInputType = {
    id?: true
    country?: true
    state?: true
    city?: true
    town?: true
    district?: true
    neighbourhood?: true
  }

  export type Level_typeMinAggregateInputType = {
    id?: true
    name?: true
    country?: true
    state?: true
    city?: true
    town?: true
    district?: true
    neighbourhood?: true
  }

  export type Level_typeMaxAggregateInputType = {
    id?: true
    name?: true
    country?: true
    state?: true
    city?: true
    town?: true
    district?: true
    neighbourhood?: true
  }

  export type Level_typeCountAggregateInputType = {
    id?: true
    name?: true
    country?: true
    state?: true
    city?: true
    town?: true
    district?: true
    neighbourhood?: true
    _all?: true
  }

  export type Level_typeAggregateArgs = {
    /**
     * Filter which level_type to aggregate.
     * 
    **/
    where?: level_typeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of level_types to fetch.
     * 
    **/
    orderBy?: Enumerable<level_typeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: level_typeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` level_types from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` level_types.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned level_types
    **/
    _count?: true | Level_typeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Level_typeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Level_typeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Level_typeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Level_typeMaxAggregateInputType
  }

  export type GetLevel_typeAggregateType<T extends Level_typeAggregateArgs> = {
        [P in keyof T & keyof AggregateLevel_type]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLevel_type[P]>
      : GetScalarType<T[P], AggregateLevel_type[P]>
  }




  export type Level_typeGroupByArgs = {
    where?: level_typeWhereInput
    orderBy?: Enumerable<level_typeOrderByWithAggregationInput>
    by: Array<Level_typeScalarFieldEnum>
    having?: level_typeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Level_typeCountAggregateInputType | true
    _avg?: Level_typeAvgAggregateInputType
    _sum?: Level_typeSumAggregateInputType
    _min?: Level_typeMinAggregateInputType
    _max?: Level_typeMaxAggregateInputType
  }


  export type Level_typeGroupByOutputType = {
    id: number
    name: string
    country: number
    state: number
    city: number
    town: number
    district: number
    neighbourhood: number
    _count: Level_typeCountAggregateOutputType | null
    _avg: Level_typeAvgAggregateOutputType | null
    _sum: Level_typeSumAggregateOutputType | null
    _min: Level_typeMinAggregateOutputType | null
    _max: Level_typeMaxAggregateOutputType | null
  }

  type GetLevel_typeGroupByPayload<T extends Level_typeGroupByArgs> = Promise<
    Array<
      PickArray<Level_typeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Level_typeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Level_typeGroupByOutputType[P]>
            : GetScalarType<T[P], Level_typeGroupByOutputType[P]>
        }
      >
    >


  export type level_typeSelect = {
    id?: boolean
    name?: boolean
    country?: boolean
    state?: boolean
    city?: boolean
    town?: boolean
    district?: boolean
    neighbourhood?: boolean
    level?: boolean | levelFindManyArgs
    _count?: boolean | Level_typeCountOutputTypeArgs
  }

  export type level_typeInclude = {
    level?: boolean | levelFindManyArgs
    _count?: boolean | Level_typeCountOutputTypeArgs
  }

  export type level_typeGetPayload<
    S extends boolean | null | undefined | level_typeArgs,
    U = keyof S
      > = S extends true
        ? level_type
    : S extends undefined
    ? never
    : S extends level_typeArgs | level_typeFindManyArgs
    ?'include' extends U
    ? level_type  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'level'
        ? Array < levelGetPayload<S['include'][P]>>  :
        P extends '_count'
        ? Level_typeCountOutputTypeGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof level_type ?level_type [P]
  : 
          P extends 'level'
        ? Array < levelGetPayload<S['select'][P]>>  :
        P extends '_count'
        ? Level_typeCountOutputTypeGetPayload<S['select'][P]> : never
  } 
    : level_type
  : level_type


  type level_typeCountArgs = Merge<
    Omit<level_typeFindManyArgs, 'select' | 'include'> & {
      select?: Level_typeCountAggregateInputType | true
    }
  >

  export interface level_typeDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Level_type that matches the filter.
     * @param {level_typeFindUniqueArgs} args - Arguments to find a Level_type
     * @example
     * // Get one Level_type
     * const level_type = await prisma.level_type.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends level_typeFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, level_typeFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'level_type'> extends True ? CheckSelect<T, Prisma__level_typeClient<level_type>, Prisma__level_typeClient<level_typeGetPayload<T>>> : CheckSelect<T, Prisma__level_typeClient<level_type | null >, Prisma__level_typeClient<level_typeGetPayload<T> | null >>

    /**
     * Find the first Level_type that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {level_typeFindFirstArgs} args - Arguments to find a Level_type
     * @example
     * // Get one Level_type
     * const level_type = await prisma.level_type.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends level_typeFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, level_typeFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'level_type'> extends True ? CheckSelect<T, Prisma__level_typeClient<level_type>, Prisma__level_typeClient<level_typeGetPayload<T>>> : CheckSelect<T, Prisma__level_typeClient<level_type | null >, Prisma__level_typeClient<level_typeGetPayload<T> | null >>

    /**
     * Find zero or more Level_types that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {level_typeFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Level_types
     * const level_types = await prisma.level_type.findMany()
     * 
     * // Get first 10 Level_types
     * const level_types = await prisma.level_type.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const level_typeWithIdOnly = await prisma.level_type.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends level_typeFindManyArgs>(
      args?: SelectSubset<T, level_typeFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<level_type>>, PrismaPromise<Array<level_typeGetPayload<T>>>>

    /**
     * Create a Level_type.
     * @param {level_typeCreateArgs} args - Arguments to create a Level_type.
     * @example
     * // Create one Level_type
     * const Level_type = await prisma.level_type.create({
     *   data: {
     *     // ... data to create a Level_type
     *   }
     * })
     * 
    **/
    create<T extends level_typeCreateArgs>(
      args: SelectSubset<T, level_typeCreateArgs>
    ): CheckSelect<T, Prisma__level_typeClient<level_type>, Prisma__level_typeClient<level_typeGetPayload<T>>>

    /**
     * Create many Level_types.
     *     @param {level_typeCreateManyArgs} args - Arguments to create many Level_types.
     *     @example
     *     // Create many Level_types
     *     const level_type = await prisma.level_type.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends level_typeCreateManyArgs>(
      args?: SelectSubset<T, level_typeCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Level_type.
     * @param {level_typeDeleteArgs} args - Arguments to delete one Level_type.
     * @example
     * // Delete one Level_type
     * const Level_type = await prisma.level_type.delete({
     *   where: {
     *     // ... filter to delete one Level_type
     *   }
     * })
     * 
    **/
    delete<T extends level_typeDeleteArgs>(
      args: SelectSubset<T, level_typeDeleteArgs>
    ): CheckSelect<T, Prisma__level_typeClient<level_type>, Prisma__level_typeClient<level_typeGetPayload<T>>>

    /**
     * Update one Level_type.
     * @param {level_typeUpdateArgs} args - Arguments to update one Level_type.
     * @example
     * // Update one Level_type
     * const level_type = await prisma.level_type.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends level_typeUpdateArgs>(
      args: SelectSubset<T, level_typeUpdateArgs>
    ): CheckSelect<T, Prisma__level_typeClient<level_type>, Prisma__level_typeClient<level_typeGetPayload<T>>>

    /**
     * Delete zero or more Level_types.
     * @param {level_typeDeleteManyArgs} args - Arguments to filter Level_types to delete.
     * @example
     * // Delete a few Level_types
     * const { count } = await prisma.level_type.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends level_typeDeleteManyArgs>(
      args?: SelectSubset<T, level_typeDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Level_types.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {level_typeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Level_types
     * const level_type = await prisma.level_type.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends level_typeUpdateManyArgs>(
      args: SelectSubset<T, level_typeUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Level_type.
     * @param {level_typeUpsertArgs} args - Arguments to update or create a Level_type.
     * @example
     * // Update or create a Level_type
     * const level_type = await prisma.level_type.upsert({
     *   create: {
     *     // ... data to create a Level_type
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Level_type we want to update
     *   }
     * })
    **/
    upsert<T extends level_typeUpsertArgs>(
      args: SelectSubset<T, level_typeUpsertArgs>
    ): CheckSelect<T, Prisma__level_typeClient<level_type>, Prisma__level_typeClient<level_typeGetPayload<T>>>

    /**
     * Count the number of Level_types.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {level_typeCountArgs} args - Arguments to filter Level_types to count.
     * @example
     * // Count the number of Level_types
     * const count = await prisma.level_type.count({
     *   where: {
     *     // ... the filter for the Level_types we want to count
     *   }
     * })
    **/
    count<T extends level_typeCountArgs>(
      args?: Subset<T, level_typeCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Level_typeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Level_type.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Level_typeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Level_typeAggregateArgs>(args: Subset<T, Level_typeAggregateArgs>): PrismaPromise<GetLevel_typeAggregateType<T>>

    /**
     * Group by Level_type.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Level_typeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Level_typeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Level_typeGroupByArgs['orderBy'] }
        : { orderBy?: Level_typeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Level_typeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLevel_typeGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for level_type.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__level_typeClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    level<T extends levelFindManyArgs = {}>(args?: Subset<T, levelFindManyArgs>): CheckSelect<T, PrismaPromise<Array<level>>, PrismaPromise<Array<levelGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * level_type findUnique
   */
  export type level_typeFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the level_type
     * 
    **/
    select?: level_typeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: level_typeInclude | null
    /**
     * Throw an Error if a level_type can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which level_type to fetch.
     * 
    **/
    where: level_typeWhereUniqueInput
  }


  /**
   * level_type findFirst
   */
  export type level_typeFindFirstArgs = {
    /**
     * Select specific fields to fetch from the level_type
     * 
    **/
    select?: level_typeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: level_typeInclude | null
    /**
     * Throw an Error if a level_type can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which level_type to fetch.
     * 
    **/
    where?: level_typeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of level_types to fetch.
     * 
    **/
    orderBy?: Enumerable<level_typeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for level_types.
     * 
    **/
    cursor?: level_typeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` level_types from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` level_types.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of level_types.
     * 
    **/
    distinct?: Enumerable<Level_typeScalarFieldEnum>
  }


  /**
   * level_type findMany
   */
  export type level_typeFindManyArgs = {
    /**
     * Select specific fields to fetch from the level_type
     * 
    **/
    select?: level_typeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: level_typeInclude | null
    /**
     * Filter, which level_types to fetch.
     * 
    **/
    where?: level_typeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of level_types to fetch.
     * 
    **/
    orderBy?: Enumerable<level_typeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing level_types.
     * 
    **/
    cursor?: level_typeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` level_types from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` level_types.
     * 
    **/
    skip?: number
    distinct?: Enumerable<Level_typeScalarFieldEnum>
  }


  /**
   * level_type create
   */
  export type level_typeCreateArgs = {
    /**
     * Select specific fields to fetch from the level_type
     * 
    **/
    select?: level_typeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: level_typeInclude | null
    /**
     * The data needed to create a level_type.
     * 
    **/
    data: XOR<level_typeCreateInput, level_typeUncheckedCreateInput>
  }


  /**
   * level_type createMany
   */
  export type level_typeCreateManyArgs = {
    data: Enumerable<level_typeCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * level_type update
   */
  export type level_typeUpdateArgs = {
    /**
     * Select specific fields to fetch from the level_type
     * 
    **/
    select?: level_typeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: level_typeInclude | null
    /**
     * The data needed to update a level_type.
     * 
    **/
    data: XOR<level_typeUpdateInput, level_typeUncheckedUpdateInput>
    /**
     * Choose, which level_type to update.
     * 
    **/
    where: level_typeWhereUniqueInput
  }


  /**
   * level_type updateMany
   */
  export type level_typeUpdateManyArgs = {
    data: XOR<level_typeUpdateManyMutationInput, level_typeUncheckedUpdateManyInput>
    where?: level_typeWhereInput
  }


  /**
   * level_type upsert
   */
  export type level_typeUpsertArgs = {
    /**
     * Select specific fields to fetch from the level_type
     * 
    **/
    select?: level_typeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: level_typeInclude | null
    /**
     * The filter to search for the level_type to update in case it exists.
     * 
    **/
    where: level_typeWhereUniqueInput
    /**
     * In case the level_type found by the `where` argument doesn't exist, create a new level_type with this data.
     * 
    **/
    create: XOR<level_typeCreateInput, level_typeUncheckedCreateInput>
    /**
     * In case the level_type was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<level_typeUpdateInput, level_typeUncheckedUpdateInput>
  }


  /**
   * level_type delete
   */
  export type level_typeDeleteArgs = {
    /**
     * Select specific fields to fetch from the level_type
     * 
    **/
    select?: level_typeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: level_typeInclude | null
    /**
     * Filter which level_type to delete.
     * 
    **/
    where: level_typeWhereUniqueInput
  }


  /**
   * level_type deleteMany
   */
  export type level_typeDeleteManyArgs = {
    where?: level_typeWhereInput
  }


  /**
   * level_type without action
   */
  export type level_typeArgs = {
    /**
     * Select specific fields to fetch from the level_type
     * 
    **/
    select?: level_typeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: level_typeInclude | null
  }



  /**
   * Enums
   */

  // Based on
  // https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275

  export const User_roleScalarFieldEnum: {
    id: 'id',
    name: 'name',
    admin: 'admin',
    manager: 'manager',
    registered: 'registered'
  };

  export type User_roleScalarFieldEnum = (typeof User_roleScalarFieldEnum)[keyof typeof User_roleScalarFieldEnum]


  export const User_statusScalarFieldEnum: {
    id: 'id',
    name: 'name',
    active: 'active',
    pending: 'pending',
    suspended: 'suspended',
    deleted: 'deleted'
  };

  export type User_statusScalarFieldEnum = (typeof User_statusScalarFieldEnum)[keyof typeof User_statusScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    name: 'name',
    lastnames: 'lastnames',
    email: 'email',
    password: 'password',
    created_at: 'created_at',
    updated_at: 'updated_at',
    user_status_id: 'user_status_id',
    user_role_id: 'user_role_id'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const Acces_logScalarFieldEnum: {
    id: 'id',
    login: 'login',
    logout: 'logout',
    user_id: 'user_id'
  };

  export type Acces_logScalarFieldEnum = (typeof Acces_logScalarFieldEnum)[keyof typeof Acces_logScalarFieldEnum]


  export const Recover_password_logScalarFieldEnum: {
    id: 'id',
    created_at: 'created_at',
    password: 'password',
    user_id: 'user_id'
  };

  export type Recover_password_logScalarFieldEnum = (typeof Recover_password_logScalarFieldEnum)[keyof typeof Recover_password_logScalarFieldEnum]


  export const MediaScalarFieldEnum: {
    id: 'id',
    path: 'path',
    mime_type: 'mime_type',
    file_size: 'file_size',
    user_id: 'user_id'
  };

  export type MediaScalarFieldEnum = (typeof MediaScalarFieldEnum)[keyof typeof MediaScalarFieldEnum]


  export const Media_metaScalarFieldEnum: {
    id: 'id',
    path: 'path',
    mime_type: 'mime_type',
    file_size: 'file_size',
    media_id: 'media_id',
    media_type_id: 'media_type_id'
  };

  export type Media_metaScalarFieldEnum = (typeof Media_metaScalarFieldEnum)[keyof typeof Media_metaScalarFieldEnum]


  export const Media_typeScalarFieldEnum: {
    id: 'id',
    name: 'name',
    thumnail: 'thumnail',
    medium: 'medium',
    large: 'large',
    original: 'original'
  };

  export type Media_typeScalarFieldEnum = (typeof Media_typeScalarFieldEnum)[keyof typeof Media_typeScalarFieldEnum]


  export const Ad_typeScalarFieldEnum: {
    id: 'id',
    name: 'name',
    house: 'house',
    room: 'room',
    garage: 'garage',
    storage: 'storage',
    office: 'office',
    warehouse: 'warehouse',
    building: 'building',
    new_building: 'new_building'
  };

  export type Ad_typeScalarFieldEnum = (typeof Ad_typeScalarFieldEnum)[keyof typeof Ad_typeScalarFieldEnum]


  export const AdsScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    title: 'title',
    description: 'description',
    city: 'city',
    n_rooms: 'n_rooms',
    price: 'price',
    square_meters: 'square_meters',
    n_bathrooms: 'n_bathrooms',
    map_lat: 'map_lat',
    map_lon: 'map_lon',
    ad_type_id: 'ad_type_id'
  };

  export type AdsScalarFieldEnum = (typeof AdsScalarFieldEnum)[keyof typeof AdsScalarFieldEnum]


  export const LevelScalarFieldEnum: {
    id: 'id',
    name: 'name',
    parent_id: 'parent_id',
    level_type_id: 'level_type_id'
  };

  export type LevelScalarFieldEnum = (typeof LevelScalarFieldEnum)[keyof typeof LevelScalarFieldEnum]


  export const Level_typeScalarFieldEnum: {
    id: 'id',
    name: 'name',
    country: 'country',
    state: 'state',
    city: 'city',
    town: 'town',
    district: 'district',
    neighbourhood: 'neighbourhood'
  };

  export type Level_typeScalarFieldEnum = (typeof Level_typeScalarFieldEnum)[keyof typeof Level_typeScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  /**
   * Deep Input Types
   */


  export type user_roleWhereInput = {
    AND?: Enumerable<user_roleWhereInput>
    OR?: Enumerable<user_roleWhereInput>
    NOT?: Enumerable<user_roleWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    admin?: BoolFilter | boolean
    manager?: BoolFilter | boolean
    registered?: BoolFilter | boolean
    user?: UserListRelationFilter
  }

  export type user_roleOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    admin?: SortOrder
    manager?: SortOrder
    registered?: SortOrder
    user?: userOrderByRelationAggregateInput
  }

  export type user_roleWhereUniqueInput = {
    id?: number
  }

  export type user_roleOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    admin?: SortOrder
    manager?: SortOrder
    registered?: SortOrder
    _count?: user_roleCountOrderByAggregateInput
    _avg?: user_roleAvgOrderByAggregateInput
    _max?: user_roleMaxOrderByAggregateInput
    _min?: user_roleMinOrderByAggregateInput
    _sum?: user_roleSumOrderByAggregateInput
  }

  export type user_roleScalarWhereWithAggregatesInput = {
    AND?: Enumerable<user_roleScalarWhereWithAggregatesInput>
    OR?: Enumerable<user_roleScalarWhereWithAggregatesInput>
    NOT?: Enumerable<user_roleScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    admin?: BoolWithAggregatesFilter | boolean
    manager?: BoolWithAggregatesFilter | boolean
    registered?: BoolWithAggregatesFilter | boolean
  }

  export type user_statusWhereInput = {
    AND?: Enumerable<user_statusWhereInput>
    OR?: Enumerable<user_statusWhereInput>
    NOT?: Enumerable<user_statusWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    active?: BoolFilter | boolean
    pending?: BoolFilter | boolean
    suspended?: BoolFilter | boolean
    deleted?: BoolFilter | boolean
    user?: UserListRelationFilter
  }

  export type user_statusOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    active?: SortOrder
    pending?: SortOrder
    suspended?: SortOrder
    deleted?: SortOrder
    user?: userOrderByRelationAggregateInput
  }

  export type user_statusWhereUniqueInput = {
    id?: number
  }

  export type user_statusOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    active?: SortOrder
    pending?: SortOrder
    suspended?: SortOrder
    deleted?: SortOrder
    _count?: user_statusCountOrderByAggregateInput
    _avg?: user_statusAvgOrderByAggregateInput
    _max?: user_statusMaxOrderByAggregateInput
    _min?: user_statusMinOrderByAggregateInput
    _sum?: user_statusSumOrderByAggregateInput
  }

  export type user_statusScalarWhereWithAggregatesInput = {
    AND?: Enumerable<user_statusScalarWhereWithAggregatesInput>
    OR?: Enumerable<user_statusScalarWhereWithAggregatesInput>
    NOT?: Enumerable<user_statusScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    active?: BoolWithAggregatesFilter | boolean
    pending?: BoolWithAggregatesFilter | boolean
    suspended?: BoolWithAggregatesFilter | boolean
    deleted?: BoolWithAggregatesFilter | boolean
  }

  export type userWhereInput = {
    AND?: Enumerable<userWhereInput>
    OR?: Enumerable<userWhereInput>
    NOT?: Enumerable<userWhereInput>
    id?: IntFilter | number
    name?: StringNullableFilter | string | null
    lastnames?: StringNullableFilter | string | null
    email?: StringFilter | string
    password?: StringFilter | string
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    user_status?: XOR<User_statusRelationFilter, user_statusWhereInput>
    user_status_id?: IntFilter | number
    user_role?: XOR<User_roleRelationFilter, user_roleWhereInput>
    user_role_id?: IntFilter | number
    acces_log?: Acces_logListRelationFilter
    recover_password_log?: Recover_password_logListRelationFilter
    media?: MediaListRelationFilter
    ads?: AdsListRelationFilter
  }

  export type userOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    lastnames?: SortOrder
    email?: SortOrder
    password?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    user_status?: user_statusOrderByWithRelationInput
    user_status_id?: SortOrder
    user_role?: user_roleOrderByWithRelationInput
    user_role_id?: SortOrder
    acces_log?: acces_logOrderByRelationAggregateInput
    recover_password_log?: recover_password_logOrderByRelationAggregateInput
    media?: mediaOrderByRelationAggregateInput
    ads?: adsOrderByRelationAggregateInput
  }

  export type userWhereUniqueInput = {
    id?: number
    email?: string
  }

  export type userOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    lastnames?: SortOrder
    email?: SortOrder
    password?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    user_status_id?: SortOrder
    user_role_id?: SortOrder
    _count?: userCountOrderByAggregateInput
    _avg?: userAvgOrderByAggregateInput
    _max?: userMaxOrderByAggregateInput
    _min?: userMinOrderByAggregateInput
    _sum?: userSumOrderByAggregateInput
  }

  export type userScalarWhereWithAggregatesInput = {
    AND?: Enumerable<userScalarWhereWithAggregatesInput>
    OR?: Enumerable<userScalarWhereWithAggregatesInput>
    NOT?: Enumerable<userScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringNullableWithAggregatesFilter | string | null
    lastnames?: StringNullableWithAggregatesFilter | string | null
    email?: StringWithAggregatesFilter | string
    password?: StringWithAggregatesFilter | string
    created_at?: DateTimeWithAggregatesFilter | Date | string
    updated_at?: DateTimeWithAggregatesFilter | Date | string
    user_status_id?: IntWithAggregatesFilter | number
    user_role_id?: IntWithAggregatesFilter | number
  }

  export type acces_logWhereInput = {
    AND?: Enumerable<acces_logWhereInput>
    OR?: Enumerable<acces_logWhereInput>
    NOT?: Enumerable<acces_logWhereInput>
    id?: IntFilter | number
    login?: DateTimeFilter | Date | string
    logout?: DateTimeFilter | Date | string
    user?: XOR<UserRelationFilter, userWhereInput>
    user_id?: IntFilter | number
  }

  export type acces_logOrderByWithRelationInput = {
    id?: SortOrder
    login?: SortOrder
    logout?: SortOrder
    user?: userOrderByWithRelationInput
    user_id?: SortOrder
  }

  export type acces_logWhereUniqueInput = {
    id?: number
  }

  export type acces_logOrderByWithAggregationInput = {
    id?: SortOrder
    login?: SortOrder
    logout?: SortOrder
    user_id?: SortOrder
    _count?: acces_logCountOrderByAggregateInput
    _avg?: acces_logAvgOrderByAggregateInput
    _max?: acces_logMaxOrderByAggregateInput
    _min?: acces_logMinOrderByAggregateInput
    _sum?: acces_logSumOrderByAggregateInput
  }

  export type acces_logScalarWhereWithAggregatesInput = {
    AND?: Enumerable<acces_logScalarWhereWithAggregatesInput>
    OR?: Enumerable<acces_logScalarWhereWithAggregatesInput>
    NOT?: Enumerable<acces_logScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    login?: DateTimeWithAggregatesFilter | Date | string
    logout?: DateTimeWithAggregatesFilter | Date | string
    user_id?: IntWithAggregatesFilter | number
  }

  export type recover_password_logWhereInput = {
    AND?: Enumerable<recover_password_logWhereInput>
    OR?: Enumerable<recover_password_logWhereInput>
    NOT?: Enumerable<recover_password_logWhereInput>
    id?: IntFilter | number
    created_at?: DateTimeFilter | Date | string
    password?: StringFilter | string
    user?: XOR<UserRelationFilter, userWhereInput>
    user_id?: IntFilter | number
  }

  export type recover_password_logOrderByWithRelationInput = {
    id?: SortOrder
    created_at?: SortOrder
    password?: SortOrder
    user?: userOrderByWithRelationInput
    user_id?: SortOrder
  }

  export type recover_password_logWhereUniqueInput = {
    id?: number
  }

  export type recover_password_logOrderByWithAggregationInput = {
    id?: SortOrder
    created_at?: SortOrder
    password?: SortOrder
    user_id?: SortOrder
    _count?: recover_password_logCountOrderByAggregateInput
    _avg?: recover_password_logAvgOrderByAggregateInput
    _max?: recover_password_logMaxOrderByAggregateInput
    _min?: recover_password_logMinOrderByAggregateInput
    _sum?: recover_password_logSumOrderByAggregateInput
  }

  export type recover_password_logScalarWhereWithAggregatesInput = {
    AND?: Enumerable<recover_password_logScalarWhereWithAggregatesInput>
    OR?: Enumerable<recover_password_logScalarWhereWithAggregatesInput>
    NOT?: Enumerable<recover_password_logScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    created_at?: DateTimeWithAggregatesFilter | Date | string
    password?: StringWithAggregatesFilter | string
    user_id?: IntWithAggregatesFilter | number
  }

  export type mediaWhereInput = {
    AND?: Enumerable<mediaWhereInput>
    OR?: Enumerable<mediaWhereInput>
    NOT?: Enumerable<mediaWhereInput>
    id?: IntFilter | number
    path?: StringFilter | string
    mime_type?: StringFilter | string
    file_size?: StringFilter | string
    user?: XOR<UserRelationFilter, userWhereInput>
    user_id?: IntFilter | number
    media_meta?: Media_metaListRelationFilter
  }

  export type mediaOrderByWithRelationInput = {
    id?: SortOrder
    path?: SortOrder
    mime_type?: SortOrder
    file_size?: SortOrder
    user?: userOrderByWithRelationInput
    user_id?: SortOrder
    media_meta?: media_metaOrderByRelationAggregateInput
  }

  export type mediaWhereUniqueInput = {
    id?: number
  }

  export type mediaOrderByWithAggregationInput = {
    id?: SortOrder
    path?: SortOrder
    mime_type?: SortOrder
    file_size?: SortOrder
    user_id?: SortOrder
    _count?: mediaCountOrderByAggregateInput
    _avg?: mediaAvgOrderByAggregateInput
    _max?: mediaMaxOrderByAggregateInput
    _min?: mediaMinOrderByAggregateInput
    _sum?: mediaSumOrderByAggregateInput
  }

  export type mediaScalarWhereWithAggregatesInput = {
    AND?: Enumerable<mediaScalarWhereWithAggregatesInput>
    OR?: Enumerable<mediaScalarWhereWithAggregatesInput>
    NOT?: Enumerable<mediaScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    path?: StringWithAggregatesFilter | string
    mime_type?: StringWithAggregatesFilter | string
    file_size?: StringWithAggregatesFilter | string
    user_id?: IntWithAggregatesFilter | number
  }

  export type media_metaWhereInput = {
    AND?: Enumerable<media_metaWhereInput>
    OR?: Enumerable<media_metaWhereInput>
    NOT?: Enumerable<media_metaWhereInput>
    id?: IntFilter | number
    path?: StringFilter | string
    mime_type?: StringFilter | string
    file_size?: StringFilter | string
    media?: XOR<MediaRelationFilter, mediaWhereInput>
    media_id?: IntFilter | number
    media_type?: XOR<Media_typeRelationFilter, media_typeWhereInput>
    media_type_id?: IntFilter | number
  }

  export type media_metaOrderByWithRelationInput = {
    id?: SortOrder
    path?: SortOrder
    mime_type?: SortOrder
    file_size?: SortOrder
    media?: mediaOrderByWithRelationInput
    media_id?: SortOrder
    media_type?: media_typeOrderByWithRelationInput
    media_type_id?: SortOrder
  }

  export type media_metaWhereUniqueInput = {
    id?: number
  }

  export type media_metaOrderByWithAggregationInput = {
    id?: SortOrder
    path?: SortOrder
    mime_type?: SortOrder
    file_size?: SortOrder
    media_id?: SortOrder
    media_type_id?: SortOrder
    _count?: media_metaCountOrderByAggregateInput
    _avg?: media_metaAvgOrderByAggregateInput
    _max?: media_metaMaxOrderByAggregateInput
    _min?: media_metaMinOrderByAggregateInput
    _sum?: media_metaSumOrderByAggregateInput
  }

  export type media_metaScalarWhereWithAggregatesInput = {
    AND?: Enumerable<media_metaScalarWhereWithAggregatesInput>
    OR?: Enumerable<media_metaScalarWhereWithAggregatesInput>
    NOT?: Enumerable<media_metaScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    path?: StringWithAggregatesFilter | string
    mime_type?: StringWithAggregatesFilter | string
    file_size?: StringWithAggregatesFilter | string
    media_id?: IntWithAggregatesFilter | number
    media_type_id?: IntWithAggregatesFilter | number
  }

  export type media_typeWhereInput = {
    AND?: Enumerable<media_typeWhereInput>
    OR?: Enumerable<media_typeWhereInput>
    NOT?: Enumerable<media_typeWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    thumnail?: BoolFilter | boolean
    medium?: BoolFilter | boolean
    large?: BoolFilter | boolean
    original?: BoolFilter | boolean
    media_meta?: Media_metaListRelationFilter
  }

  export type media_typeOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    thumnail?: SortOrder
    medium?: SortOrder
    large?: SortOrder
    original?: SortOrder
    media_meta?: media_metaOrderByRelationAggregateInput
  }

  export type media_typeWhereUniqueInput = {
    id?: number
  }

  export type media_typeOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    thumnail?: SortOrder
    medium?: SortOrder
    large?: SortOrder
    original?: SortOrder
    _count?: media_typeCountOrderByAggregateInput
    _avg?: media_typeAvgOrderByAggregateInput
    _max?: media_typeMaxOrderByAggregateInput
    _min?: media_typeMinOrderByAggregateInput
    _sum?: media_typeSumOrderByAggregateInput
  }

  export type media_typeScalarWhereWithAggregatesInput = {
    AND?: Enumerable<media_typeScalarWhereWithAggregatesInput>
    OR?: Enumerable<media_typeScalarWhereWithAggregatesInput>
    NOT?: Enumerable<media_typeScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    thumnail?: BoolWithAggregatesFilter | boolean
    medium?: BoolWithAggregatesFilter | boolean
    large?: BoolWithAggregatesFilter | boolean
    original?: BoolWithAggregatesFilter | boolean
  }

  export type ad_typeWhereInput = {
    AND?: Enumerable<ad_typeWhereInput>
    OR?: Enumerable<ad_typeWhereInput>
    NOT?: Enumerable<ad_typeWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    house?: IntFilter | number
    room?: IntFilter | number
    garage?: IntFilter | number
    storage?: IntFilter | number
    office?: IntFilter | number
    warehouse?: IntFilter | number
    building?: IntFilter | number
    new_building?: IntFilter | number
    ads?: AdsListRelationFilter
  }

  export type ad_typeOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    house?: SortOrder
    room?: SortOrder
    garage?: SortOrder
    storage?: SortOrder
    office?: SortOrder
    warehouse?: SortOrder
    building?: SortOrder
    new_building?: SortOrder
    ads?: adsOrderByRelationAggregateInput
  }

  export type ad_typeWhereUniqueInput = {
    id?: number
  }

  export type ad_typeOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    house?: SortOrder
    room?: SortOrder
    garage?: SortOrder
    storage?: SortOrder
    office?: SortOrder
    warehouse?: SortOrder
    building?: SortOrder
    new_building?: SortOrder
    _count?: ad_typeCountOrderByAggregateInput
    _avg?: ad_typeAvgOrderByAggregateInput
    _max?: ad_typeMaxOrderByAggregateInput
    _min?: ad_typeMinOrderByAggregateInput
    _sum?: ad_typeSumOrderByAggregateInput
  }

  export type ad_typeScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ad_typeScalarWhereWithAggregatesInput>
    OR?: Enumerable<ad_typeScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ad_typeScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    house?: IntWithAggregatesFilter | number
    room?: IntWithAggregatesFilter | number
    garage?: IntWithAggregatesFilter | number
    storage?: IntWithAggregatesFilter | number
    office?: IntWithAggregatesFilter | number
    warehouse?: IntWithAggregatesFilter | number
    building?: IntWithAggregatesFilter | number
    new_building?: IntWithAggregatesFilter | number
  }

  export type adsWhereInput = {
    AND?: Enumerable<adsWhereInput>
    OR?: Enumerable<adsWhereInput>
    NOT?: Enumerable<adsWhereInput>
    id?: IntFilter | number
    user?: XOR<UserRelationFilter, userWhereInput>
    user_id?: IntFilter | number
    title?: StringFilter | string
    description?: StringFilter | string
    city?: StringFilter | string
    n_rooms?: IntFilter | number
    price?: IntFilter | number
    square_meters?: IntFilter | number
    n_bathrooms?: IntFilter | number
    map_lat?: DecimalFilter | Decimal | number | string
    map_lon?: DecimalFilter | Decimal | number | string
    ad_type_id?: IntFilter | number
    ad_type?: XOR<Ad_typeRelationFilter, ad_typeWhereInput>
  }

  export type adsOrderByWithRelationInput = {
    id?: SortOrder
    user?: userOrderByWithRelationInput
    user_id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    city?: SortOrder
    n_rooms?: SortOrder
    price?: SortOrder
    square_meters?: SortOrder
    n_bathrooms?: SortOrder
    map_lat?: SortOrder
    map_lon?: SortOrder
    ad_type_id?: SortOrder
    ad_type?: ad_typeOrderByWithRelationInput
  }

  export type adsWhereUniqueInput = {
    id?: number
  }

  export type adsOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    city?: SortOrder
    n_rooms?: SortOrder
    price?: SortOrder
    square_meters?: SortOrder
    n_bathrooms?: SortOrder
    map_lat?: SortOrder
    map_lon?: SortOrder
    ad_type_id?: SortOrder
    _count?: adsCountOrderByAggregateInput
    _avg?: adsAvgOrderByAggregateInput
    _max?: adsMaxOrderByAggregateInput
    _min?: adsMinOrderByAggregateInput
    _sum?: adsSumOrderByAggregateInput
  }

  export type adsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<adsScalarWhereWithAggregatesInput>
    OR?: Enumerable<adsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<adsScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    user_id?: IntWithAggregatesFilter | number
    title?: StringWithAggregatesFilter | string
    description?: StringWithAggregatesFilter | string
    city?: StringWithAggregatesFilter | string
    n_rooms?: IntWithAggregatesFilter | number
    price?: IntWithAggregatesFilter | number
    square_meters?: IntWithAggregatesFilter | number
    n_bathrooms?: IntWithAggregatesFilter | number
    map_lat?: DecimalWithAggregatesFilter | Decimal | number | string
    map_lon?: DecimalWithAggregatesFilter | Decimal | number | string
    ad_type_id?: IntWithAggregatesFilter | number
  }

  export type levelWhereInput = {
    AND?: Enumerable<levelWhereInput>
    OR?: Enumerable<levelWhereInput>
    NOT?: Enumerable<levelWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    parent?: XOR<LevelRelationFilter, levelWhereInput> | null
    parent_id?: IntNullableFilter | number | null
    child?: LevelListRelationFilter
    level_type?: XOR<Level_typeRelationFilter, level_typeWhereInput>
    level_type_id?: IntFilter | number
  }

  export type levelOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    parent?: levelOrderByWithRelationInput
    parent_id?: SortOrder
    child?: levelOrderByRelationAggregateInput
    level_type?: level_typeOrderByWithRelationInput
    level_type_id?: SortOrder
  }

  export type levelWhereUniqueInput = {
    id?: number
  }

  export type levelOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    parent_id?: SortOrder
    level_type_id?: SortOrder
    _count?: levelCountOrderByAggregateInput
    _avg?: levelAvgOrderByAggregateInput
    _max?: levelMaxOrderByAggregateInput
    _min?: levelMinOrderByAggregateInput
    _sum?: levelSumOrderByAggregateInput
  }

  export type levelScalarWhereWithAggregatesInput = {
    AND?: Enumerable<levelScalarWhereWithAggregatesInput>
    OR?: Enumerable<levelScalarWhereWithAggregatesInput>
    NOT?: Enumerable<levelScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    parent_id?: IntNullableWithAggregatesFilter | number | null
    level_type_id?: IntWithAggregatesFilter | number
  }

  export type level_typeWhereInput = {
    AND?: Enumerable<level_typeWhereInput>
    OR?: Enumerable<level_typeWhereInput>
    NOT?: Enumerable<level_typeWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    country?: IntFilter | number
    state?: IntFilter | number
    city?: IntFilter | number
    town?: IntFilter | number
    district?: IntFilter | number
    neighbourhood?: IntFilter | number
    level?: LevelListRelationFilter
  }

  export type level_typeOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    country?: SortOrder
    state?: SortOrder
    city?: SortOrder
    town?: SortOrder
    district?: SortOrder
    neighbourhood?: SortOrder
    level?: levelOrderByRelationAggregateInput
  }

  export type level_typeWhereUniqueInput = {
    id?: number
  }

  export type level_typeOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    country?: SortOrder
    state?: SortOrder
    city?: SortOrder
    town?: SortOrder
    district?: SortOrder
    neighbourhood?: SortOrder
    _count?: level_typeCountOrderByAggregateInput
    _avg?: level_typeAvgOrderByAggregateInput
    _max?: level_typeMaxOrderByAggregateInput
    _min?: level_typeMinOrderByAggregateInput
    _sum?: level_typeSumOrderByAggregateInput
  }

  export type level_typeScalarWhereWithAggregatesInput = {
    AND?: Enumerable<level_typeScalarWhereWithAggregatesInput>
    OR?: Enumerable<level_typeScalarWhereWithAggregatesInput>
    NOT?: Enumerable<level_typeScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    country?: IntWithAggregatesFilter | number
    state?: IntWithAggregatesFilter | number
    city?: IntWithAggregatesFilter | number
    town?: IntWithAggregatesFilter | number
    district?: IntWithAggregatesFilter | number
    neighbourhood?: IntWithAggregatesFilter | number
  }

  export type user_roleCreateInput = {
    name: string
    admin?: boolean
    manager?: boolean
    registered?: boolean
    user?: userCreateNestedManyWithoutUser_roleInput
  }

  export type user_roleUncheckedCreateInput = {
    id?: number
    name: string
    admin?: boolean
    manager?: boolean
    registered?: boolean
    user?: userUncheckedCreateNestedManyWithoutUser_roleInput
  }

  export type user_roleUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    admin?: BoolFieldUpdateOperationsInput | boolean
    manager?: BoolFieldUpdateOperationsInput | boolean
    registered?: BoolFieldUpdateOperationsInput | boolean
    user?: userUpdateManyWithoutUser_roleInput
  }

  export type user_roleUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    admin?: BoolFieldUpdateOperationsInput | boolean
    manager?: BoolFieldUpdateOperationsInput | boolean
    registered?: BoolFieldUpdateOperationsInput | boolean
    user?: userUncheckedUpdateManyWithoutUser_roleInput
  }

  export type user_roleCreateManyInput = {
    id?: number
    name: string
    admin?: boolean
    manager?: boolean
    registered?: boolean
  }

  export type user_roleUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    admin?: BoolFieldUpdateOperationsInput | boolean
    manager?: BoolFieldUpdateOperationsInput | boolean
    registered?: BoolFieldUpdateOperationsInput | boolean
  }

  export type user_roleUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    admin?: BoolFieldUpdateOperationsInput | boolean
    manager?: BoolFieldUpdateOperationsInput | boolean
    registered?: BoolFieldUpdateOperationsInput | boolean
  }

  export type user_statusCreateInput = {
    name: string
    active?: boolean
    pending?: boolean
    suspended?: boolean
    deleted?: boolean
    user?: userCreateNestedManyWithoutUser_statusInput
  }

  export type user_statusUncheckedCreateInput = {
    id?: number
    name: string
    active?: boolean
    pending?: boolean
    suspended?: boolean
    deleted?: boolean
    user?: userUncheckedCreateNestedManyWithoutUser_statusInput
  }

  export type user_statusUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    pending?: BoolFieldUpdateOperationsInput | boolean
    suspended?: BoolFieldUpdateOperationsInput | boolean
    deleted?: BoolFieldUpdateOperationsInput | boolean
    user?: userUpdateManyWithoutUser_statusInput
  }

  export type user_statusUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    pending?: BoolFieldUpdateOperationsInput | boolean
    suspended?: BoolFieldUpdateOperationsInput | boolean
    deleted?: BoolFieldUpdateOperationsInput | boolean
    user?: userUncheckedUpdateManyWithoutUser_statusInput
  }

  export type user_statusCreateManyInput = {
    id?: number
    name: string
    active?: boolean
    pending?: boolean
    suspended?: boolean
    deleted?: boolean
  }

  export type user_statusUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    pending?: BoolFieldUpdateOperationsInput | boolean
    suspended?: BoolFieldUpdateOperationsInput | boolean
    deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type user_statusUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    pending?: BoolFieldUpdateOperationsInput | boolean
    suspended?: BoolFieldUpdateOperationsInput | boolean
    deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type userCreateInput = {
    name?: string | null
    lastnames?: string | null
    email: string
    password: string
    created_at?: Date | string
    updated_at?: Date | string
    user_status: user_statusCreateNestedOneWithoutUserInput
    user_role: user_roleCreateNestedOneWithoutUserInput
    acces_log?: acces_logCreateNestedManyWithoutUserInput
    recover_password_log?: recover_password_logCreateNestedManyWithoutUserInput
    media?: mediaCreateNestedManyWithoutUserInput
    ads?: adsCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateInput = {
    id?: number
    name?: string | null
    lastnames?: string | null
    email: string
    password: string
    created_at?: Date | string
    updated_at?: Date | string
    user_status_id: number
    user_role_id: number
    acces_log?: acces_logUncheckedCreateNestedManyWithoutUserInput
    recover_password_log?: recover_password_logUncheckedCreateNestedManyWithoutUserInput
    media?: mediaUncheckedCreateNestedManyWithoutUserInput
    ads?: adsUncheckedCreateNestedManyWithoutUserInput
  }

  export type userUpdateInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    lastnames?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user_status?: user_statusUpdateOneRequiredWithoutUserInput
    user_role?: user_roleUpdateOneRequiredWithoutUserInput
    acces_log?: acces_logUpdateManyWithoutUserInput
    recover_password_log?: recover_password_logUpdateManyWithoutUserInput
    media?: mediaUpdateManyWithoutUserInput
    ads?: adsUpdateManyWithoutUserInput
  }

  export type userUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    lastnames?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user_status_id?: IntFieldUpdateOperationsInput | number
    user_role_id?: IntFieldUpdateOperationsInput | number
    acces_log?: acces_logUncheckedUpdateManyWithoutUserInput
    recover_password_log?: recover_password_logUncheckedUpdateManyWithoutUserInput
    media?: mediaUncheckedUpdateManyWithoutUserInput
    ads?: adsUncheckedUpdateManyWithoutUserInput
  }

  export type userCreateManyInput = {
    id?: number
    name?: string | null
    lastnames?: string | null
    email: string
    password: string
    created_at?: Date | string
    updated_at?: Date | string
    user_status_id: number
    user_role_id: number
  }

  export type userUpdateManyMutationInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    lastnames?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type userUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    lastnames?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user_status_id?: IntFieldUpdateOperationsInput | number
    user_role_id?: IntFieldUpdateOperationsInput | number
  }

  export type acces_logCreateInput = {
    login: Date | string
    logout: Date | string
    user: userCreateNestedOneWithoutAcces_logInput
  }

  export type acces_logUncheckedCreateInput = {
    id?: number
    login: Date | string
    logout: Date | string
    user_id: number
  }

  export type acces_logUpdateInput = {
    login?: DateTimeFieldUpdateOperationsInput | Date | string
    logout?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: userUpdateOneRequiredWithoutAcces_logInput
  }

  export type acces_logUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    login?: DateTimeFieldUpdateOperationsInput | Date | string
    logout?: DateTimeFieldUpdateOperationsInput | Date | string
    user_id?: IntFieldUpdateOperationsInput | number
  }

  export type acces_logCreateManyInput = {
    id?: number
    login: Date | string
    logout: Date | string
    user_id: number
  }

  export type acces_logUpdateManyMutationInput = {
    login?: DateTimeFieldUpdateOperationsInput | Date | string
    logout?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type acces_logUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    login?: DateTimeFieldUpdateOperationsInput | Date | string
    logout?: DateTimeFieldUpdateOperationsInput | Date | string
    user_id?: IntFieldUpdateOperationsInput | number
  }

  export type recover_password_logCreateInput = {
    created_at?: Date | string
    password: string
    user: userCreateNestedOneWithoutRecover_password_logInput
  }

  export type recover_password_logUncheckedCreateInput = {
    id?: number
    created_at?: Date | string
    password: string
    user_id: number
  }

  export type recover_password_logUpdateInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    password?: StringFieldUpdateOperationsInput | string
    user?: userUpdateOneRequiredWithoutRecover_password_logInput
  }

  export type recover_password_logUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    password?: StringFieldUpdateOperationsInput | string
    user_id?: IntFieldUpdateOperationsInput | number
  }

  export type recover_password_logCreateManyInput = {
    id?: number
    created_at?: Date | string
    password: string
    user_id: number
  }

  export type recover_password_logUpdateManyMutationInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    password?: StringFieldUpdateOperationsInput | string
  }

  export type recover_password_logUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    password?: StringFieldUpdateOperationsInput | string
    user_id?: IntFieldUpdateOperationsInput | number
  }

  export type mediaCreateInput = {
    path: string
    mime_type: string
    file_size: string
    user: userCreateNestedOneWithoutMediaInput
    media_meta?: media_metaCreateNestedManyWithoutMediaInput
  }

  export type mediaUncheckedCreateInput = {
    id?: number
    path: string
    mime_type: string
    file_size: string
    user_id: number
    media_meta?: media_metaUncheckedCreateNestedManyWithoutMediaInput
  }

  export type mediaUpdateInput = {
    path?: StringFieldUpdateOperationsInput | string
    mime_type?: StringFieldUpdateOperationsInput | string
    file_size?: StringFieldUpdateOperationsInput | string
    user?: userUpdateOneRequiredWithoutMediaInput
    media_meta?: media_metaUpdateManyWithoutMediaInput
  }

  export type mediaUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    path?: StringFieldUpdateOperationsInput | string
    mime_type?: StringFieldUpdateOperationsInput | string
    file_size?: StringFieldUpdateOperationsInput | string
    user_id?: IntFieldUpdateOperationsInput | number
    media_meta?: media_metaUncheckedUpdateManyWithoutMediaInput
  }

  export type mediaCreateManyInput = {
    id?: number
    path: string
    mime_type: string
    file_size: string
    user_id: number
  }

  export type mediaUpdateManyMutationInput = {
    path?: StringFieldUpdateOperationsInput | string
    mime_type?: StringFieldUpdateOperationsInput | string
    file_size?: StringFieldUpdateOperationsInput | string
  }

  export type mediaUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    path?: StringFieldUpdateOperationsInput | string
    mime_type?: StringFieldUpdateOperationsInput | string
    file_size?: StringFieldUpdateOperationsInput | string
    user_id?: IntFieldUpdateOperationsInput | number
  }

  export type media_metaCreateInput = {
    path: string
    mime_type: string
    file_size: string
    media: mediaCreateNestedOneWithoutMedia_metaInput
    media_type: media_typeCreateNestedOneWithoutMedia_metaInput
  }

  export type media_metaUncheckedCreateInput = {
    id?: number
    path: string
    mime_type: string
    file_size: string
    media_id: number
    media_type_id: number
  }

  export type media_metaUpdateInput = {
    path?: StringFieldUpdateOperationsInput | string
    mime_type?: StringFieldUpdateOperationsInput | string
    file_size?: StringFieldUpdateOperationsInput | string
    media?: mediaUpdateOneRequiredWithoutMedia_metaInput
    media_type?: media_typeUpdateOneRequiredWithoutMedia_metaInput
  }

  export type media_metaUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    path?: StringFieldUpdateOperationsInput | string
    mime_type?: StringFieldUpdateOperationsInput | string
    file_size?: StringFieldUpdateOperationsInput | string
    media_id?: IntFieldUpdateOperationsInput | number
    media_type_id?: IntFieldUpdateOperationsInput | number
  }

  export type media_metaCreateManyInput = {
    id?: number
    path: string
    mime_type: string
    file_size: string
    media_id: number
    media_type_id: number
  }

  export type media_metaUpdateManyMutationInput = {
    path?: StringFieldUpdateOperationsInput | string
    mime_type?: StringFieldUpdateOperationsInput | string
    file_size?: StringFieldUpdateOperationsInput | string
  }

  export type media_metaUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    path?: StringFieldUpdateOperationsInput | string
    mime_type?: StringFieldUpdateOperationsInput | string
    file_size?: StringFieldUpdateOperationsInput | string
    media_id?: IntFieldUpdateOperationsInput | number
    media_type_id?: IntFieldUpdateOperationsInput | number
  }

  export type media_typeCreateInput = {
    name: string
    thumnail: boolean
    medium: boolean
    large: boolean
    original: boolean
    media_meta?: media_metaCreateNestedManyWithoutMedia_typeInput
  }

  export type media_typeUncheckedCreateInput = {
    id?: number
    name: string
    thumnail: boolean
    medium: boolean
    large: boolean
    original: boolean
    media_meta?: media_metaUncheckedCreateNestedManyWithoutMedia_typeInput
  }

  export type media_typeUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    thumnail?: BoolFieldUpdateOperationsInput | boolean
    medium?: BoolFieldUpdateOperationsInput | boolean
    large?: BoolFieldUpdateOperationsInput | boolean
    original?: BoolFieldUpdateOperationsInput | boolean
    media_meta?: media_metaUpdateManyWithoutMedia_typeInput
  }

  export type media_typeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    thumnail?: BoolFieldUpdateOperationsInput | boolean
    medium?: BoolFieldUpdateOperationsInput | boolean
    large?: BoolFieldUpdateOperationsInput | boolean
    original?: BoolFieldUpdateOperationsInput | boolean
    media_meta?: media_metaUncheckedUpdateManyWithoutMedia_typeInput
  }

  export type media_typeCreateManyInput = {
    id?: number
    name: string
    thumnail: boolean
    medium: boolean
    large: boolean
    original: boolean
  }

  export type media_typeUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    thumnail?: BoolFieldUpdateOperationsInput | boolean
    medium?: BoolFieldUpdateOperationsInput | boolean
    large?: BoolFieldUpdateOperationsInput | boolean
    original?: BoolFieldUpdateOperationsInput | boolean
  }

  export type media_typeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    thumnail?: BoolFieldUpdateOperationsInput | boolean
    medium?: BoolFieldUpdateOperationsInput | boolean
    large?: BoolFieldUpdateOperationsInput | boolean
    original?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ad_typeCreateInput = {
    name: string
    house: number
    room: number
    garage: number
    storage: number
    office: number
    warehouse: number
    building: number
    new_building: number
    ads?: adsCreateNestedManyWithoutAd_typeInput
  }

  export type ad_typeUncheckedCreateInput = {
    id?: number
    name: string
    house: number
    room: number
    garage: number
    storage: number
    office: number
    warehouse: number
    building: number
    new_building: number
    ads?: adsUncheckedCreateNestedManyWithoutAd_typeInput
  }

  export type ad_typeUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    house?: IntFieldUpdateOperationsInput | number
    room?: IntFieldUpdateOperationsInput | number
    garage?: IntFieldUpdateOperationsInput | number
    storage?: IntFieldUpdateOperationsInput | number
    office?: IntFieldUpdateOperationsInput | number
    warehouse?: IntFieldUpdateOperationsInput | number
    building?: IntFieldUpdateOperationsInput | number
    new_building?: IntFieldUpdateOperationsInput | number
    ads?: adsUpdateManyWithoutAd_typeInput
  }

  export type ad_typeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    house?: IntFieldUpdateOperationsInput | number
    room?: IntFieldUpdateOperationsInput | number
    garage?: IntFieldUpdateOperationsInput | number
    storage?: IntFieldUpdateOperationsInput | number
    office?: IntFieldUpdateOperationsInput | number
    warehouse?: IntFieldUpdateOperationsInput | number
    building?: IntFieldUpdateOperationsInput | number
    new_building?: IntFieldUpdateOperationsInput | number
    ads?: adsUncheckedUpdateManyWithoutAd_typeInput
  }

  export type ad_typeCreateManyInput = {
    id?: number
    name: string
    house: number
    room: number
    garage: number
    storage: number
    office: number
    warehouse: number
    building: number
    new_building: number
  }

  export type ad_typeUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    house?: IntFieldUpdateOperationsInput | number
    room?: IntFieldUpdateOperationsInput | number
    garage?: IntFieldUpdateOperationsInput | number
    storage?: IntFieldUpdateOperationsInput | number
    office?: IntFieldUpdateOperationsInput | number
    warehouse?: IntFieldUpdateOperationsInput | number
    building?: IntFieldUpdateOperationsInput | number
    new_building?: IntFieldUpdateOperationsInput | number
  }

  export type ad_typeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    house?: IntFieldUpdateOperationsInput | number
    room?: IntFieldUpdateOperationsInput | number
    garage?: IntFieldUpdateOperationsInput | number
    storage?: IntFieldUpdateOperationsInput | number
    office?: IntFieldUpdateOperationsInput | number
    warehouse?: IntFieldUpdateOperationsInput | number
    building?: IntFieldUpdateOperationsInput | number
    new_building?: IntFieldUpdateOperationsInput | number
  }

  export type adsCreateInput = {
    title: string
    description: string
    city: string
    n_rooms: number
    price: number
    square_meters: number
    n_bathrooms: number
    map_lat: Decimal | number | string
    map_lon: Decimal | number | string
    user: userCreateNestedOneWithoutAdsInput
    ad_type: ad_typeCreateNestedOneWithoutAdsInput
  }

  export type adsUncheckedCreateInput = {
    id?: number
    user_id: number
    title: string
    description: string
    city: string
    n_rooms: number
    price: number
    square_meters: number
    n_bathrooms: number
    map_lat: Decimal | number | string
    map_lon: Decimal | number | string
    ad_type_id: number
  }

  export type adsUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    n_rooms?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    square_meters?: IntFieldUpdateOperationsInput | number
    n_bathrooms?: IntFieldUpdateOperationsInput | number
    map_lat?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    map_lon?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    user?: userUpdateOneRequiredWithoutAdsInput
    ad_type?: ad_typeUpdateOneRequiredWithoutAdsInput
  }

  export type adsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    n_rooms?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    square_meters?: IntFieldUpdateOperationsInput | number
    n_bathrooms?: IntFieldUpdateOperationsInput | number
    map_lat?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    map_lon?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    ad_type_id?: IntFieldUpdateOperationsInput | number
  }

  export type adsCreateManyInput = {
    id?: number
    user_id: number
    title: string
    description: string
    city: string
    n_rooms: number
    price: number
    square_meters: number
    n_bathrooms: number
    map_lat: Decimal | number | string
    map_lon: Decimal | number | string
    ad_type_id: number
  }

  export type adsUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    n_rooms?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    square_meters?: IntFieldUpdateOperationsInput | number
    n_bathrooms?: IntFieldUpdateOperationsInput | number
    map_lat?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    map_lon?: DecimalFieldUpdateOperationsInput | Decimal | number | string
  }

  export type adsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    n_rooms?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    square_meters?: IntFieldUpdateOperationsInput | number
    n_bathrooms?: IntFieldUpdateOperationsInput | number
    map_lat?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    map_lon?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    ad_type_id?: IntFieldUpdateOperationsInput | number
  }

  export type levelCreateInput = {
    name: string
    parent?: levelCreateNestedOneWithoutChildInput
    child?: levelCreateNestedManyWithoutParentInput
    level_type: level_typeCreateNestedOneWithoutLevelInput
  }

  export type levelUncheckedCreateInput = {
    id?: number
    name: string
    parent_id?: number | null
    level_type_id: number
    child?: levelUncheckedCreateNestedManyWithoutParentInput
  }

  export type levelUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    parent?: levelUpdateOneWithoutChildInput
    child?: levelUpdateManyWithoutParentInput
    level_type?: level_typeUpdateOneRequiredWithoutLevelInput
  }

  export type levelUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    parent_id?: NullableIntFieldUpdateOperationsInput | number | null
    level_type_id?: IntFieldUpdateOperationsInput | number
    child?: levelUncheckedUpdateManyWithoutParentInput
  }

  export type levelCreateManyInput = {
    id?: number
    name: string
    parent_id?: number | null
    level_type_id: number
  }

  export type levelUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type levelUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    parent_id?: NullableIntFieldUpdateOperationsInput | number | null
    level_type_id?: IntFieldUpdateOperationsInput | number
  }

  export type level_typeCreateInput = {
    name: string
    country: number
    state: number
    city: number
    town: number
    district: number
    neighbourhood: number
    level?: levelCreateNestedManyWithoutLevel_typeInput
  }

  export type level_typeUncheckedCreateInput = {
    id?: number
    name: string
    country: number
    state: number
    city: number
    town: number
    district: number
    neighbourhood: number
    level?: levelUncheckedCreateNestedManyWithoutLevel_typeInput
  }

  export type level_typeUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    country?: IntFieldUpdateOperationsInput | number
    state?: IntFieldUpdateOperationsInput | number
    city?: IntFieldUpdateOperationsInput | number
    town?: IntFieldUpdateOperationsInput | number
    district?: IntFieldUpdateOperationsInput | number
    neighbourhood?: IntFieldUpdateOperationsInput | number
    level?: levelUpdateManyWithoutLevel_typeInput
  }

  export type level_typeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    country?: IntFieldUpdateOperationsInput | number
    state?: IntFieldUpdateOperationsInput | number
    city?: IntFieldUpdateOperationsInput | number
    town?: IntFieldUpdateOperationsInput | number
    district?: IntFieldUpdateOperationsInput | number
    neighbourhood?: IntFieldUpdateOperationsInput | number
    level?: levelUncheckedUpdateManyWithoutLevel_typeInput
  }

  export type level_typeCreateManyInput = {
    id?: number
    name: string
    country: number
    state: number
    city: number
    town: number
    district: number
    neighbourhood: number
  }

  export type level_typeUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    country?: IntFieldUpdateOperationsInput | number
    state?: IntFieldUpdateOperationsInput | number
    city?: IntFieldUpdateOperationsInput | number
    town?: IntFieldUpdateOperationsInput | number
    district?: IntFieldUpdateOperationsInput | number
    neighbourhood?: IntFieldUpdateOperationsInput | number
  }

  export type level_typeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    country?: IntFieldUpdateOperationsInput | number
    state?: IntFieldUpdateOperationsInput | number
    city?: IntFieldUpdateOperationsInput | number
    town?: IntFieldUpdateOperationsInput | number
    district?: IntFieldUpdateOperationsInput | number
    neighbourhood?: IntFieldUpdateOperationsInput | number
  }

  export type IntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type StringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringFilter | string
  }

  export type BoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type UserListRelationFilter = {
    every?: userWhereInput
    some?: userWhereInput
    none?: userWhereInput
  }

  export type userOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type user_roleCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    admin?: SortOrder
    manager?: SortOrder
    registered?: SortOrder
  }

  export type user_roleAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type user_roleMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    admin?: SortOrder
    manager?: SortOrder
    registered?: SortOrder
  }

  export type user_roleMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    admin?: SortOrder
    manager?: SortOrder
    registered?: SortOrder
  }

  export type user_roleSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type StringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type BoolWithAggregatesFilter = {
    equals?: boolean
    not?: NestedBoolWithAggregatesFilter | boolean
    _count?: NestedIntFilter
    _min?: NestedBoolFilter
    _max?: NestedBoolFilter
  }

  export type user_statusCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    active?: SortOrder
    pending?: SortOrder
    suspended?: SortOrder
    deleted?: SortOrder
  }

  export type user_statusAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type user_statusMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    active?: SortOrder
    pending?: SortOrder
    suspended?: SortOrder
    deleted?: SortOrder
  }

  export type user_statusMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    active?: SortOrder
    pending?: SortOrder
    suspended?: SortOrder
    deleted?: SortOrder
  }

  export type user_statusSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type StringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringNullableFilter | string | null
  }

  export type DateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type User_statusRelationFilter = {
    is?: user_statusWhereInput
    isNot?: user_statusWhereInput
  }

  export type User_roleRelationFilter = {
    is?: user_roleWhereInput
    isNot?: user_roleWhereInput
  }

  export type Acces_logListRelationFilter = {
    every?: acces_logWhereInput
    some?: acces_logWhereInput
    none?: acces_logWhereInput
  }

  export type Recover_password_logListRelationFilter = {
    every?: recover_password_logWhereInput
    some?: recover_password_logWhereInput
    none?: recover_password_logWhereInput
  }

  export type MediaListRelationFilter = {
    every?: mediaWhereInput
    some?: mediaWhereInput
    none?: mediaWhereInput
  }

  export type AdsListRelationFilter = {
    every?: adsWhereInput
    some?: adsWhereInput
    none?: adsWhereInput
  }

  export type acces_logOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type recover_password_logOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type mediaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type adsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type userCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    lastnames?: SortOrder
    email?: SortOrder
    password?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    user_status_id?: SortOrder
    user_role_id?: SortOrder
  }

  export type userAvgOrderByAggregateInput = {
    id?: SortOrder
    user_status_id?: SortOrder
    user_role_id?: SortOrder
  }

  export type userMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    lastnames?: SortOrder
    email?: SortOrder
    password?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    user_status_id?: SortOrder
    user_role_id?: SortOrder
  }

  export type userMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    lastnames?: SortOrder
    email?: SortOrder
    password?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    user_status_id?: SortOrder
    user_role_id?: SortOrder
  }

  export type userSumOrderByAggregateInput = {
    id?: SortOrder
    user_status_id?: SortOrder
    user_role_id?: SortOrder
  }

  export type StringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type DateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type UserRelationFilter = {
    is?: userWhereInput
    isNot?: userWhereInput
  }

  export type acces_logCountOrderByAggregateInput = {
    id?: SortOrder
    login?: SortOrder
    logout?: SortOrder
    user_id?: SortOrder
  }

  export type acces_logAvgOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
  }

  export type acces_logMaxOrderByAggregateInput = {
    id?: SortOrder
    login?: SortOrder
    logout?: SortOrder
    user_id?: SortOrder
  }

  export type acces_logMinOrderByAggregateInput = {
    id?: SortOrder
    login?: SortOrder
    logout?: SortOrder
    user_id?: SortOrder
  }

  export type acces_logSumOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
  }

  export type recover_password_logCountOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    password?: SortOrder
    user_id?: SortOrder
  }

  export type recover_password_logAvgOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
  }

  export type recover_password_logMaxOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    password?: SortOrder
    user_id?: SortOrder
  }

  export type recover_password_logMinOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    password?: SortOrder
    user_id?: SortOrder
  }

  export type recover_password_logSumOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
  }

  export type Media_metaListRelationFilter = {
    every?: media_metaWhereInput
    some?: media_metaWhereInput
    none?: media_metaWhereInput
  }

  export type media_metaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type mediaCountOrderByAggregateInput = {
    id?: SortOrder
    path?: SortOrder
    mime_type?: SortOrder
    file_size?: SortOrder
    user_id?: SortOrder
  }

  export type mediaAvgOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
  }

  export type mediaMaxOrderByAggregateInput = {
    id?: SortOrder
    path?: SortOrder
    mime_type?: SortOrder
    file_size?: SortOrder
    user_id?: SortOrder
  }

  export type mediaMinOrderByAggregateInput = {
    id?: SortOrder
    path?: SortOrder
    mime_type?: SortOrder
    file_size?: SortOrder
    user_id?: SortOrder
  }

  export type mediaSumOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
  }

  export type MediaRelationFilter = {
    is?: mediaWhereInput
    isNot?: mediaWhereInput
  }

  export type Media_typeRelationFilter = {
    is?: media_typeWhereInput
    isNot?: media_typeWhereInput
  }

  export type media_metaCountOrderByAggregateInput = {
    id?: SortOrder
    path?: SortOrder
    mime_type?: SortOrder
    file_size?: SortOrder
    media_id?: SortOrder
    media_type_id?: SortOrder
  }

  export type media_metaAvgOrderByAggregateInput = {
    id?: SortOrder
    media_id?: SortOrder
    media_type_id?: SortOrder
  }

  export type media_metaMaxOrderByAggregateInput = {
    id?: SortOrder
    path?: SortOrder
    mime_type?: SortOrder
    file_size?: SortOrder
    media_id?: SortOrder
    media_type_id?: SortOrder
  }

  export type media_metaMinOrderByAggregateInput = {
    id?: SortOrder
    path?: SortOrder
    mime_type?: SortOrder
    file_size?: SortOrder
    media_id?: SortOrder
    media_type_id?: SortOrder
  }

  export type media_metaSumOrderByAggregateInput = {
    id?: SortOrder
    media_id?: SortOrder
    media_type_id?: SortOrder
  }

  export type media_typeCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    thumnail?: SortOrder
    medium?: SortOrder
    large?: SortOrder
    original?: SortOrder
  }

  export type media_typeAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type media_typeMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    thumnail?: SortOrder
    medium?: SortOrder
    large?: SortOrder
    original?: SortOrder
  }

  export type media_typeMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    thumnail?: SortOrder
    medium?: SortOrder
    large?: SortOrder
    original?: SortOrder
  }

  export type media_typeSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ad_typeCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    house?: SortOrder
    room?: SortOrder
    garage?: SortOrder
    storage?: SortOrder
    office?: SortOrder
    warehouse?: SortOrder
    building?: SortOrder
    new_building?: SortOrder
  }

  export type ad_typeAvgOrderByAggregateInput = {
    id?: SortOrder
    house?: SortOrder
    room?: SortOrder
    garage?: SortOrder
    storage?: SortOrder
    office?: SortOrder
    warehouse?: SortOrder
    building?: SortOrder
    new_building?: SortOrder
  }

  export type ad_typeMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    house?: SortOrder
    room?: SortOrder
    garage?: SortOrder
    storage?: SortOrder
    office?: SortOrder
    warehouse?: SortOrder
    building?: SortOrder
    new_building?: SortOrder
  }

  export type ad_typeMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    house?: SortOrder
    room?: SortOrder
    garage?: SortOrder
    storage?: SortOrder
    office?: SortOrder
    warehouse?: SortOrder
    building?: SortOrder
    new_building?: SortOrder
  }

  export type ad_typeSumOrderByAggregateInput = {
    id?: SortOrder
    house?: SortOrder
    room?: SortOrder
    garage?: SortOrder
    storage?: SortOrder
    office?: SortOrder
    warehouse?: SortOrder
    building?: SortOrder
    new_building?: SortOrder
  }

  export type DecimalFilter = {
    equals?: Decimal | number | string
    in?: Enumerable<Decimal> | Enumerable<number> | Enumerable<string>
    notIn?: Enumerable<Decimal> | Enumerable<number> | Enumerable<string>
    lt?: Decimal | number | string
    lte?: Decimal | number | string
    gt?: Decimal | number | string
    gte?: Decimal | number | string
    not?: NestedDecimalFilter | Decimal | number | string
  }

  export type Ad_typeRelationFilter = {
    is?: ad_typeWhereInput
    isNot?: ad_typeWhereInput
  }

  export type adsCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    city?: SortOrder
    n_rooms?: SortOrder
    price?: SortOrder
    square_meters?: SortOrder
    n_bathrooms?: SortOrder
    map_lat?: SortOrder
    map_lon?: SortOrder
    ad_type_id?: SortOrder
  }

  export type adsAvgOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    n_rooms?: SortOrder
    price?: SortOrder
    square_meters?: SortOrder
    n_bathrooms?: SortOrder
    map_lat?: SortOrder
    map_lon?: SortOrder
    ad_type_id?: SortOrder
  }

  export type adsMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    city?: SortOrder
    n_rooms?: SortOrder
    price?: SortOrder
    square_meters?: SortOrder
    n_bathrooms?: SortOrder
    map_lat?: SortOrder
    map_lon?: SortOrder
    ad_type_id?: SortOrder
  }

  export type adsMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    city?: SortOrder
    n_rooms?: SortOrder
    price?: SortOrder
    square_meters?: SortOrder
    n_bathrooms?: SortOrder
    map_lat?: SortOrder
    map_lon?: SortOrder
    ad_type_id?: SortOrder
  }

  export type adsSumOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    n_rooms?: SortOrder
    price?: SortOrder
    square_meters?: SortOrder
    n_bathrooms?: SortOrder
    map_lat?: SortOrder
    map_lon?: SortOrder
    ad_type_id?: SortOrder
  }

  export type DecimalWithAggregatesFilter = {
    equals?: Decimal | number | string
    in?: Enumerable<Decimal> | Enumerable<number> | Enumerable<string>
    notIn?: Enumerable<Decimal> | Enumerable<number> | Enumerable<string>
    lt?: Decimal | number | string
    lte?: Decimal | number | string
    gt?: Decimal | number | string
    gte?: Decimal | number | string
    not?: NestedDecimalWithAggregatesFilter | Decimal | number | string
    _count?: NestedIntFilter
    _avg?: NestedDecimalFilter
    _sum?: NestedDecimalFilter
    _min?: NestedDecimalFilter
    _max?: NestedDecimalFilter
  }

  export type LevelRelationFilter = {
    is?: levelWhereInput | null
    isNot?: levelWhereInput | null
  }

  export type IntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type LevelListRelationFilter = {
    every?: levelWhereInput
    some?: levelWhereInput
    none?: levelWhereInput
  }

  export type Level_typeRelationFilter = {
    is?: level_typeWhereInput
    isNot?: level_typeWhereInput
  }

  export type levelOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type levelCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    parent_id?: SortOrder
    level_type_id?: SortOrder
  }

  export type levelAvgOrderByAggregateInput = {
    id?: SortOrder
    parent_id?: SortOrder
    level_type_id?: SortOrder
  }

  export type levelMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    parent_id?: SortOrder
    level_type_id?: SortOrder
  }

  export type levelMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    parent_id?: SortOrder
    level_type_id?: SortOrder
  }

  export type levelSumOrderByAggregateInput = {
    id?: SortOrder
    parent_id?: SortOrder
    level_type_id?: SortOrder
  }

  export type IntNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedIntNullableFilter
    _min?: NestedIntNullableFilter
    _max?: NestedIntNullableFilter
  }

  export type level_typeCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    country?: SortOrder
    state?: SortOrder
    city?: SortOrder
    town?: SortOrder
    district?: SortOrder
    neighbourhood?: SortOrder
  }

  export type level_typeAvgOrderByAggregateInput = {
    id?: SortOrder
    country?: SortOrder
    state?: SortOrder
    city?: SortOrder
    town?: SortOrder
    district?: SortOrder
    neighbourhood?: SortOrder
  }

  export type level_typeMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    country?: SortOrder
    state?: SortOrder
    city?: SortOrder
    town?: SortOrder
    district?: SortOrder
    neighbourhood?: SortOrder
  }

  export type level_typeMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    country?: SortOrder
    state?: SortOrder
    city?: SortOrder
    town?: SortOrder
    district?: SortOrder
    neighbourhood?: SortOrder
  }

  export type level_typeSumOrderByAggregateInput = {
    id?: SortOrder
    country?: SortOrder
    state?: SortOrder
    city?: SortOrder
    town?: SortOrder
    district?: SortOrder
    neighbourhood?: SortOrder
  }

  export type userCreateNestedManyWithoutUser_roleInput = {
    create?: XOR<Enumerable<userCreateWithoutUser_roleInput>, Enumerable<userUncheckedCreateWithoutUser_roleInput>>
    connectOrCreate?: Enumerable<userCreateOrConnectWithoutUser_roleInput>
    createMany?: userCreateManyUser_roleInputEnvelope
    connect?: Enumerable<userWhereUniqueInput>
  }

  export type userUncheckedCreateNestedManyWithoutUser_roleInput = {
    create?: XOR<Enumerable<userCreateWithoutUser_roleInput>, Enumerable<userUncheckedCreateWithoutUser_roleInput>>
    connectOrCreate?: Enumerable<userCreateOrConnectWithoutUser_roleInput>
    createMany?: userCreateManyUser_roleInputEnvelope
    connect?: Enumerable<userWhereUniqueInput>
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type userUpdateManyWithoutUser_roleInput = {
    create?: XOR<Enumerable<userCreateWithoutUser_roleInput>, Enumerable<userUncheckedCreateWithoutUser_roleInput>>
    connectOrCreate?: Enumerable<userCreateOrConnectWithoutUser_roleInput>
    upsert?: Enumerable<userUpsertWithWhereUniqueWithoutUser_roleInput>
    createMany?: userCreateManyUser_roleInputEnvelope
    set?: Enumerable<userWhereUniqueInput>
    disconnect?: Enumerable<userWhereUniqueInput>
    delete?: Enumerable<userWhereUniqueInput>
    connect?: Enumerable<userWhereUniqueInput>
    update?: Enumerable<userUpdateWithWhereUniqueWithoutUser_roleInput>
    updateMany?: Enumerable<userUpdateManyWithWhereWithoutUser_roleInput>
    deleteMany?: Enumerable<userScalarWhereInput>
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type userUncheckedUpdateManyWithoutUser_roleInput = {
    create?: XOR<Enumerable<userCreateWithoutUser_roleInput>, Enumerable<userUncheckedCreateWithoutUser_roleInput>>
    connectOrCreate?: Enumerable<userCreateOrConnectWithoutUser_roleInput>
    upsert?: Enumerable<userUpsertWithWhereUniqueWithoutUser_roleInput>
    createMany?: userCreateManyUser_roleInputEnvelope
    set?: Enumerable<userWhereUniqueInput>
    disconnect?: Enumerable<userWhereUniqueInput>
    delete?: Enumerable<userWhereUniqueInput>
    connect?: Enumerable<userWhereUniqueInput>
    update?: Enumerable<userUpdateWithWhereUniqueWithoutUser_roleInput>
    updateMany?: Enumerable<userUpdateManyWithWhereWithoutUser_roleInput>
    deleteMany?: Enumerable<userScalarWhereInput>
  }

  export type userCreateNestedManyWithoutUser_statusInput = {
    create?: XOR<Enumerable<userCreateWithoutUser_statusInput>, Enumerable<userUncheckedCreateWithoutUser_statusInput>>
    connectOrCreate?: Enumerable<userCreateOrConnectWithoutUser_statusInput>
    createMany?: userCreateManyUser_statusInputEnvelope
    connect?: Enumerable<userWhereUniqueInput>
  }

  export type userUncheckedCreateNestedManyWithoutUser_statusInput = {
    create?: XOR<Enumerable<userCreateWithoutUser_statusInput>, Enumerable<userUncheckedCreateWithoutUser_statusInput>>
    connectOrCreate?: Enumerable<userCreateOrConnectWithoutUser_statusInput>
    createMany?: userCreateManyUser_statusInputEnvelope
    connect?: Enumerable<userWhereUniqueInput>
  }

  export type userUpdateManyWithoutUser_statusInput = {
    create?: XOR<Enumerable<userCreateWithoutUser_statusInput>, Enumerable<userUncheckedCreateWithoutUser_statusInput>>
    connectOrCreate?: Enumerable<userCreateOrConnectWithoutUser_statusInput>
    upsert?: Enumerable<userUpsertWithWhereUniqueWithoutUser_statusInput>
    createMany?: userCreateManyUser_statusInputEnvelope
    set?: Enumerable<userWhereUniqueInput>
    disconnect?: Enumerable<userWhereUniqueInput>
    delete?: Enumerable<userWhereUniqueInput>
    connect?: Enumerable<userWhereUniqueInput>
    update?: Enumerable<userUpdateWithWhereUniqueWithoutUser_statusInput>
    updateMany?: Enumerable<userUpdateManyWithWhereWithoutUser_statusInput>
    deleteMany?: Enumerable<userScalarWhereInput>
  }

  export type userUncheckedUpdateManyWithoutUser_statusInput = {
    create?: XOR<Enumerable<userCreateWithoutUser_statusInput>, Enumerable<userUncheckedCreateWithoutUser_statusInput>>
    connectOrCreate?: Enumerable<userCreateOrConnectWithoutUser_statusInput>
    upsert?: Enumerable<userUpsertWithWhereUniqueWithoutUser_statusInput>
    createMany?: userCreateManyUser_statusInputEnvelope
    set?: Enumerable<userWhereUniqueInput>
    disconnect?: Enumerable<userWhereUniqueInput>
    delete?: Enumerable<userWhereUniqueInput>
    connect?: Enumerable<userWhereUniqueInput>
    update?: Enumerable<userUpdateWithWhereUniqueWithoutUser_statusInput>
    updateMany?: Enumerable<userUpdateManyWithWhereWithoutUser_statusInput>
    deleteMany?: Enumerable<userScalarWhereInput>
  }

  export type user_statusCreateNestedOneWithoutUserInput = {
    create?: XOR<user_statusCreateWithoutUserInput, user_statusUncheckedCreateWithoutUserInput>
    connectOrCreate?: user_statusCreateOrConnectWithoutUserInput
    connect?: user_statusWhereUniqueInput
  }

  export type user_roleCreateNestedOneWithoutUserInput = {
    create?: XOR<user_roleCreateWithoutUserInput, user_roleUncheckedCreateWithoutUserInput>
    connectOrCreate?: user_roleCreateOrConnectWithoutUserInput
    connect?: user_roleWhereUniqueInput
  }

  export type acces_logCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<acces_logCreateWithoutUserInput>, Enumerable<acces_logUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<acces_logCreateOrConnectWithoutUserInput>
    createMany?: acces_logCreateManyUserInputEnvelope
    connect?: Enumerable<acces_logWhereUniqueInput>
  }

  export type recover_password_logCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<recover_password_logCreateWithoutUserInput>, Enumerable<recover_password_logUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<recover_password_logCreateOrConnectWithoutUserInput>
    createMany?: recover_password_logCreateManyUserInputEnvelope
    connect?: Enumerable<recover_password_logWhereUniqueInput>
  }

  export type mediaCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<mediaCreateWithoutUserInput>, Enumerable<mediaUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<mediaCreateOrConnectWithoutUserInput>
    createMany?: mediaCreateManyUserInputEnvelope
    connect?: Enumerable<mediaWhereUniqueInput>
  }

  export type adsCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<adsCreateWithoutUserInput>, Enumerable<adsUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<adsCreateOrConnectWithoutUserInput>
    createMany?: adsCreateManyUserInputEnvelope
    connect?: Enumerable<adsWhereUniqueInput>
  }

  export type acces_logUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<acces_logCreateWithoutUserInput>, Enumerable<acces_logUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<acces_logCreateOrConnectWithoutUserInput>
    createMany?: acces_logCreateManyUserInputEnvelope
    connect?: Enumerable<acces_logWhereUniqueInput>
  }

  export type recover_password_logUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<recover_password_logCreateWithoutUserInput>, Enumerable<recover_password_logUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<recover_password_logCreateOrConnectWithoutUserInput>
    createMany?: recover_password_logCreateManyUserInputEnvelope
    connect?: Enumerable<recover_password_logWhereUniqueInput>
  }

  export type mediaUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<mediaCreateWithoutUserInput>, Enumerable<mediaUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<mediaCreateOrConnectWithoutUserInput>
    createMany?: mediaCreateManyUserInputEnvelope
    connect?: Enumerable<mediaWhereUniqueInput>
  }

  export type adsUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<adsCreateWithoutUserInput>, Enumerable<adsUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<adsCreateOrConnectWithoutUserInput>
    createMany?: adsCreateManyUserInputEnvelope
    connect?: Enumerable<adsWhereUniqueInput>
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type user_statusUpdateOneRequiredWithoutUserInput = {
    create?: XOR<user_statusCreateWithoutUserInput, user_statusUncheckedCreateWithoutUserInput>
    connectOrCreate?: user_statusCreateOrConnectWithoutUserInput
    upsert?: user_statusUpsertWithoutUserInput
    connect?: user_statusWhereUniqueInput
    update?: XOR<user_statusUpdateWithoutUserInput, user_statusUncheckedUpdateWithoutUserInput>
  }

  export type user_roleUpdateOneRequiredWithoutUserInput = {
    create?: XOR<user_roleCreateWithoutUserInput, user_roleUncheckedCreateWithoutUserInput>
    connectOrCreate?: user_roleCreateOrConnectWithoutUserInput
    upsert?: user_roleUpsertWithoutUserInput
    connect?: user_roleWhereUniqueInput
    update?: XOR<user_roleUpdateWithoutUserInput, user_roleUncheckedUpdateWithoutUserInput>
  }

  export type acces_logUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<acces_logCreateWithoutUserInput>, Enumerable<acces_logUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<acces_logCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<acces_logUpsertWithWhereUniqueWithoutUserInput>
    createMany?: acces_logCreateManyUserInputEnvelope
    set?: Enumerable<acces_logWhereUniqueInput>
    disconnect?: Enumerable<acces_logWhereUniqueInput>
    delete?: Enumerable<acces_logWhereUniqueInput>
    connect?: Enumerable<acces_logWhereUniqueInput>
    update?: Enumerable<acces_logUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<acces_logUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<acces_logScalarWhereInput>
  }

  export type recover_password_logUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<recover_password_logCreateWithoutUserInput>, Enumerable<recover_password_logUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<recover_password_logCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<recover_password_logUpsertWithWhereUniqueWithoutUserInput>
    createMany?: recover_password_logCreateManyUserInputEnvelope
    set?: Enumerable<recover_password_logWhereUniqueInput>
    disconnect?: Enumerable<recover_password_logWhereUniqueInput>
    delete?: Enumerable<recover_password_logWhereUniqueInput>
    connect?: Enumerable<recover_password_logWhereUniqueInput>
    update?: Enumerable<recover_password_logUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<recover_password_logUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<recover_password_logScalarWhereInput>
  }

  export type mediaUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<mediaCreateWithoutUserInput>, Enumerable<mediaUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<mediaCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<mediaUpsertWithWhereUniqueWithoutUserInput>
    createMany?: mediaCreateManyUserInputEnvelope
    set?: Enumerable<mediaWhereUniqueInput>
    disconnect?: Enumerable<mediaWhereUniqueInput>
    delete?: Enumerable<mediaWhereUniqueInput>
    connect?: Enumerable<mediaWhereUniqueInput>
    update?: Enumerable<mediaUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<mediaUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<mediaScalarWhereInput>
  }

  export type adsUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<adsCreateWithoutUserInput>, Enumerable<adsUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<adsCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<adsUpsertWithWhereUniqueWithoutUserInput>
    createMany?: adsCreateManyUserInputEnvelope
    set?: Enumerable<adsWhereUniqueInput>
    disconnect?: Enumerable<adsWhereUniqueInput>
    delete?: Enumerable<adsWhereUniqueInput>
    connect?: Enumerable<adsWhereUniqueInput>
    update?: Enumerable<adsUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<adsUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<adsScalarWhereInput>
  }

  export type acces_logUncheckedUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<acces_logCreateWithoutUserInput>, Enumerable<acces_logUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<acces_logCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<acces_logUpsertWithWhereUniqueWithoutUserInput>
    createMany?: acces_logCreateManyUserInputEnvelope
    set?: Enumerable<acces_logWhereUniqueInput>
    disconnect?: Enumerable<acces_logWhereUniqueInput>
    delete?: Enumerable<acces_logWhereUniqueInput>
    connect?: Enumerable<acces_logWhereUniqueInput>
    update?: Enumerable<acces_logUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<acces_logUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<acces_logScalarWhereInput>
  }

  export type recover_password_logUncheckedUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<recover_password_logCreateWithoutUserInput>, Enumerable<recover_password_logUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<recover_password_logCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<recover_password_logUpsertWithWhereUniqueWithoutUserInput>
    createMany?: recover_password_logCreateManyUserInputEnvelope
    set?: Enumerable<recover_password_logWhereUniqueInput>
    disconnect?: Enumerable<recover_password_logWhereUniqueInput>
    delete?: Enumerable<recover_password_logWhereUniqueInput>
    connect?: Enumerable<recover_password_logWhereUniqueInput>
    update?: Enumerable<recover_password_logUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<recover_password_logUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<recover_password_logScalarWhereInput>
  }

  export type mediaUncheckedUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<mediaCreateWithoutUserInput>, Enumerable<mediaUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<mediaCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<mediaUpsertWithWhereUniqueWithoutUserInput>
    createMany?: mediaCreateManyUserInputEnvelope
    set?: Enumerable<mediaWhereUniqueInput>
    disconnect?: Enumerable<mediaWhereUniqueInput>
    delete?: Enumerable<mediaWhereUniqueInput>
    connect?: Enumerable<mediaWhereUniqueInput>
    update?: Enumerable<mediaUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<mediaUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<mediaScalarWhereInput>
  }

  export type adsUncheckedUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<adsCreateWithoutUserInput>, Enumerable<adsUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<adsCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<adsUpsertWithWhereUniqueWithoutUserInput>
    createMany?: adsCreateManyUserInputEnvelope
    set?: Enumerable<adsWhereUniqueInput>
    disconnect?: Enumerable<adsWhereUniqueInput>
    delete?: Enumerable<adsWhereUniqueInput>
    connect?: Enumerable<adsWhereUniqueInput>
    update?: Enumerable<adsUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<adsUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<adsScalarWhereInput>
  }

  export type userCreateNestedOneWithoutAcces_logInput = {
    create?: XOR<userCreateWithoutAcces_logInput, userUncheckedCreateWithoutAcces_logInput>
    connectOrCreate?: userCreateOrConnectWithoutAcces_logInput
    connect?: userWhereUniqueInput
  }

  export type userUpdateOneRequiredWithoutAcces_logInput = {
    create?: XOR<userCreateWithoutAcces_logInput, userUncheckedCreateWithoutAcces_logInput>
    connectOrCreate?: userCreateOrConnectWithoutAcces_logInput
    upsert?: userUpsertWithoutAcces_logInput
    connect?: userWhereUniqueInput
    update?: XOR<userUpdateWithoutAcces_logInput, userUncheckedUpdateWithoutAcces_logInput>
  }

  export type userCreateNestedOneWithoutRecover_password_logInput = {
    create?: XOR<userCreateWithoutRecover_password_logInput, userUncheckedCreateWithoutRecover_password_logInput>
    connectOrCreate?: userCreateOrConnectWithoutRecover_password_logInput
    connect?: userWhereUniqueInput
  }

  export type userUpdateOneRequiredWithoutRecover_password_logInput = {
    create?: XOR<userCreateWithoutRecover_password_logInput, userUncheckedCreateWithoutRecover_password_logInput>
    connectOrCreate?: userCreateOrConnectWithoutRecover_password_logInput
    upsert?: userUpsertWithoutRecover_password_logInput
    connect?: userWhereUniqueInput
    update?: XOR<userUpdateWithoutRecover_password_logInput, userUncheckedUpdateWithoutRecover_password_logInput>
  }

  export type userCreateNestedOneWithoutMediaInput = {
    create?: XOR<userCreateWithoutMediaInput, userUncheckedCreateWithoutMediaInput>
    connectOrCreate?: userCreateOrConnectWithoutMediaInput
    connect?: userWhereUniqueInput
  }

  export type media_metaCreateNestedManyWithoutMediaInput = {
    create?: XOR<Enumerable<media_metaCreateWithoutMediaInput>, Enumerable<media_metaUncheckedCreateWithoutMediaInput>>
    connectOrCreate?: Enumerable<media_metaCreateOrConnectWithoutMediaInput>
    createMany?: media_metaCreateManyMediaInputEnvelope
    connect?: Enumerable<media_metaWhereUniqueInput>
  }

  export type media_metaUncheckedCreateNestedManyWithoutMediaInput = {
    create?: XOR<Enumerable<media_metaCreateWithoutMediaInput>, Enumerable<media_metaUncheckedCreateWithoutMediaInput>>
    connectOrCreate?: Enumerable<media_metaCreateOrConnectWithoutMediaInput>
    createMany?: media_metaCreateManyMediaInputEnvelope
    connect?: Enumerable<media_metaWhereUniqueInput>
  }

  export type userUpdateOneRequiredWithoutMediaInput = {
    create?: XOR<userCreateWithoutMediaInput, userUncheckedCreateWithoutMediaInput>
    connectOrCreate?: userCreateOrConnectWithoutMediaInput
    upsert?: userUpsertWithoutMediaInput
    connect?: userWhereUniqueInput
    update?: XOR<userUpdateWithoutMediaInput, userUncheckedUpdateWithoutMediaInput>
  }

  export type media_metaUpdateManyWithoutMediaInput = {
    create?: XOR<Enumerable<media_metaCreateWithoutMediaInput>, Enumerable<media_metaUncheckedCreateWithoutMediaInput>>
    connectOrCreate?: Enumerable<media_metaCreateOrConnectWithoutMediaInput>
    upsert?: Enumerable<media_metaUpsertWithWhereUniqueWithoutMediaInput>
    createMany?: media_metaCreateManyMediaInputEnvelope
    set?: Enumerable<media_metaWhereUniqueInput>
    disconnect?: Enumerable<media_metaWhereUniqueInput>
    delete?: Enumerable<media_metaWhereUniqueInput>
    connect?: Enumerable<media_metaWhereUniqueInput>
    update?: Enumerable<media_metaUpdateWithWhereUniqueWithoutMediaInput>
    updateMany?: Enumerable<media_metaUpdateManyWithWhereWithoutMediaInput>
    deleteMany?: Enumerable<media_metaScalarWhereInput>
  }

  export type media_metaUncheckedUpdateManyWithoutMediaInput = {
    create?: XOR<Enumerable<media_metaCreateWithoutMediaInput>, Enumerable<media_metaUncheckedCreateWithoutMediaInput>>
    connectOrCreate?: Enumerable<media_metaCreateOrConnectWithoutMediaInput>
    upsert?: Enumerable<media_metaUpsertWithWhereUniqueWithoutMediaInput>
    createMany?: media_metaCreateManyMediaInputEnvelope
    set?: Enumerable<media_metaWhereUniqueInput>
    disconnect?: Enumerable<media_metaWhereUniqueInput>
    delete?: Enumerable<media_metaWhereUniqueInput>
    connect?: Enumerable<media_metaWhereUniqueInput>
    update?: Enumerable<media_metaUpdateWithWhereUniqueWithoutMediaInput>
    updateMany?: Enumerable<media_metaUpdateManyWithWhereWithoutMediaInput>
    deleteMany?: Enumerable<media_metaScalarWhereInput>
  }

  export type mediaCreateNestedOneWithoutMedia_metaInput = {
    create?: XOR<mediaCreateWithoutMedia_metaInput, mediaUncheckedCreateWithoutMedia_metaInput>
    connectOrCreate?: mediaCreateOrConnectWithoutMedia_metaInput
    connect?: mediaWhereUniqueInput
  }

  export type media_typeCreateNestedOneWithoutMedia_metaInput = {
    create?: XOR<media_typeCreateWithoutMedia_metaInput, media_typeUncheckedCreateWithoutMedia_metaInput>
    connectOrCreate?: media_typeCreateOrConnectWithoutMedia_metaInput
    connect?: media_typeWhereUniqueInput
  }

  export type mediaUpdateOneRequiredWithoutMedia_metaInput = {
    create?: XOR<mediaCreateWithoutMedia_metaInput, mediaUncheckedCreateWithoutMedia_metaInput>
    connectOrCreate?: mediaCreateOrConnectWithoutMedia_metaInput
    upsert?: mediaUpsertWithoutMedia_metaInput
    connect?: mediaWhereUniqueInput
    update?: XOR<mediaUpdateWithoutMedia_metaInput, mediaUncheckedUpdateWithoutMedia_metaInput>
  }

  export type media_typeUpdateOneRequiredWithoutMedia_metaInput = {
    create?: XOR<media_typeCreateWithoutMedia_metaInput, media_typeUncheckedCreateWithoutMedia_metaInput>
    connectOrCreate?: media_typeCreateOrConnectWithoutMedia_metaInput
    upsert?: media_typeUpsertWithoutMedia_metaInput
    connect?: media_typeWhereUniqueInput
    update?: XOR<media_typeUpdateWithoutMedia_metaInput, media_typeUncheckedUpdateWithoutMedia_metaInput>
  }

  export type media_metaCreateNestedManyWithoutMedia_typeInput = {
    create?: XOR<Enumerable<media_metaCreateWithoutMedia_typeInput>, Enumerable<media_metaUncheckedCreateWithoutMedia_typeInput>>
    connectOrCreate?: Enumerable<media_metaCreateOrConnectWithoutMedia_typeInput>
    createMany?: media_metaCreateManyMedia_typeInputEnvelope
    connect?: Enumerable<media_metaWhereUniqueInput>
  }

  export type media_metaUncheckedCreateNestedManyWithoutMedia_typeInput = {
    create?: XOR<Enumerable<media_metaCreateWithoutMedia_typeInput>, Enumerable<media_metaUncheckedCreateWithoutMedia_typeInput>>
    connectOrCreate?: Enumerable<media_metaCreateOrConnectWithoutMedia_typeInput>
    createMany?: media_metaCreateManyMedia_typeInputEnvelope
    connect?: Enumerable<media_metaWhereUniqueInput>
  }

  export type media_metaUpdateManyWithoutMedia_typeInput = {
    create?: XOR<Enumerable<media_metaCreateWithoutMedia_typeInput>, Enumerable<media_metaUncheckedCreateWithoutMedia_typeInput>>
    connectOrCreate?: Enumerable<media_metaCreateOrConnectWithoutMedia_typeInput>
    upsert?: Enumerable<media_metaUpsertWithWhereUniqueWithoutMedia_typeInput>
    createMany?: media_metaCreateManyMedia_typeInputEnvelope
    set?: Enumerable<media_metaWhereUniqueInput>
    disconnect?: Enumerable<media_metaWhereUniqueInput>
    delete?: Enumerable<media_metaWhereUniqueInput>
    connect?: Enumerable<media_metaWhereUniqueInput>
    update?: Enumerable<media_metaUpdateWithWhereUniqueWithoutMedia_typeInput>
    updateMany?: Enumerable<media_metaUpdateManyWithWhereWithoutMedia_typeInput>
    deleteMany?: Enumerable<media_metaScalarWhereInput>
  }

  export type media_metaUncheckedUpdateManyWithoutMedia_typeInput = {
    create?: XOR<Enumerable<media_metaCreateWithoutMedia_typeInput>, Enumerable<media_metaUncheckedCreateWithoutMedia_typeInput>>
    connectOrCreate?: Enumerable<media_metaCreateOrConnectWithoutMedia_typeInput>
    upsert?: Enumerable<media_metaUpsertWithWhereUniqueWithoutMedia_typeInput>
    createMany?: media_metaCreateManyMedia_typeInputEnvelope
    set?: Enumerable<media_metaWhereUniqueInput>
    disconnect?: Enumerable<media_metaWhereUniqueInput>
    delete?: Enumerable<media_metaWhereUniqueInput>
    connect?: Enumerable<media_metaWhereUniqueInput>
    update?: Enumerable<media_metaUpdateWithWhereUniqueWithoutMedia_typeInput>
    updateMany?: Enumerable<media_metaUpdateManyWithWhereWithoutMedia_typeInput>
    deleteMany?: Enumerable<media_metaScalarWhereInput>
  }

  export type adsCreateNestedManyWithoutAd_typeInput = {
    create?: XOR<Enumerable<adsCreateWithoutAd_typeInput>, Enumerable<adsUncheckedCreateWithoutAd_typeInput>>
    connectOrCreate?: Enumerable<adsCreateOrConnectWithoutAd_typeInput>
    createMany?: adsCreateManyAd_typeInputEnvelope
    connect?: Enumerable<adsWhereUniqueInput>
  }

  export type adsUncheckedCreateNestedManyWithoutAd_typeInput = {
    create?: XOR<Enumerable<adsCreateWithoutAd_typeInput>, Enumerable<adsUncheckedCreateWithoutAd_typeInput>>
    connectOrCreate?: Enumerable<adsCreateOrConnectWithoutAd_typeInput>
    createMany?: adsCreateManyAd_typeInputEnvelope
    connect?: Enumerable<adsWhereUniqueInput>
  }

  export type adsUpdateManyWithoutAd_typeInput = {
    create?: XOR<Enumerable<adsCreateWithoutAd_typeInput>, Enumerable<adsUncheckedCreateWithoutAd_typeInput>>
    connectOrCreate?: Enumerable<adsCreateOrConnectWithoutAd_typeInput>
    upsert?: Enumerable<adsUpsertWithWhereUniqueWithoutAd_typeInput>
    createMany?: adsCreateManyAd_typeInputEnvelope
    set?: Enumerable<adsWhereUniqueInput>
    disconnect?: Enumerable<adsWhereUniqueInput>
    delete?: Enumerable<adsWhereUniqueInput>
    connect?: Enumerable<adsWhereUniqueInput>
    update?: Enumerable<adsUpdateWithWhereUniqueWithoutAd_typeInput>
    updateMany?: Enumerable<adsUpdateManyWithWhereWithoutAd_typeInput>
    deleteMany?: Enumerable<adsScalarWhereInput>
  }

  export type adsUncheckedUpdateManyWithoutAd_typeInput = {
    create?: XOR<Enumerable<adsCreateWithoutAd_typeInput>, Enumerable<adsUncheckedCreateWithoutAd_typeInput>>
    connectOrCreate?: Enumerable<adsCreateOrConnectWithoutAd_typeInput>
    upsert?: Enumerable<adsUpsertWithWhereUniqueWithoutAd_typeInput>
    createMany?: adsCreateManyAd_typeInputEnvelope
    set?: Enumerable<adsWhereUniqueInput>
    disconnect?: Enumerable<adsWhereUniqueInput>
    delete?: Enumerable<adsWhereUniqueInput>
    connect?: Enumerable<adsWhereUniqueInput>
    update?: Enumerable<adsUpdateWithWhereUniqueWithoutAd_typeInput>
    updateMany?: Enumerable<adsUpdateManyWithWhereWithoutAd_typeInput>
    deleteMany?: Enumerable<adsScalarWhereInput>
  }

  export type userCreateNestedOneWithoutAdsInput = {
    create?: XOR<userCreateWithoutAdsInput, userUncheckedCreateWithoutAdsInput>
    connectOrCreate?: userCreateOrConnectWithoutAdsInput
    connect?: userWhereUniqueInput
  }

  export type ad_typeCreateNestedOneWithoutAdsInput = {
    create?: XOR<ad_typeCreateWithoutAdsInput, ad_typeUncheckedCreateWithoutAdsInput>
    connectOrCreate?: ad_typeCreateOrConnectWithoutAdsInput
    connect?: ad_typeWhereUniqueInput
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | number | string
    increment?: Decimal | number | string
    decrement?: Decimal | number | string
    multiply?: Decimal | number | string
    divide?: Decimal | number | string
  }

  export type userUpdateOneRequiredWithoutAdsInput = {
    create?: XOR<userCreateWithoutAdsInput, userUncheckedCreateWithoutAdsInput>
    connectOrCreate?: userCreateOrConnectWithoutAdsInput
    upsert?: userUpsertWithoutAdsInput
    connect?: userWhereUniqueInput
    update?: XOR<userUpdateWithoutAdsInput, userUncheckedUpdateWithoutAdsInput>
  }

  export type ad_typeUpdateOneRequiredWithoutAdsInput = {
    create?: XOR<ad_typeCreateWithoutAdsInput, ad_typeUncheckedCreateWithoutAdsInput>
    connectOrCreate?: ad_typeCreateOrConnectWithoutAdsInput
    upsert?: ad_typeUpsertWithoutAdsInput
    connect?: ad_typeWhereUniqueInput
    update?: XOR<ad_typeUpdateWithoutAdsInput, ad_typeUncheckedUpdateWithoutAdsInput>
  }

  export type levelCreateNestedOneWithoutChildInput = {
    create?: XOR<levelCreateWithoutChildInput, levelUncheckedCreateWithoutChildInput>
    connectOrCreate?: levelCreateOrConnectWithoutChildInput
    connect?: levelWhereUniqueInput
  }

  export type levelCreateNestedManyWithoutParentInput = {
    create?: XOR<Enumerable<levelCreateWithoutParentInput>, Enumerable<levelUncheckedCreateWithoutParentInput>>
    connectOrCreate?: Enumerable<levelCreateOrConnectWithoutParentInput>
    createMany?: levelCreateManyParentInputEnvelope
    connect?: Enumerable<levelWhereUniqueInput>
  }

  export type level_typeCreateNestedOneWithoutLevelInput = {
    create?: XOR<level_typeCreateWithoutLevelInput, level_typeUncheckedCreateWithoutLevelInput>
    connectOrCreate?: level_typeCreateOrConnectWithoutLevelInput
    connect?: level_typeWhereUniqueInput
  }

  export type levelUncheckedCreateNestedManyWithoutParentInput = {
    create?: XOR<Enumerable<levelCreateWithoutParentInput>, Enumerable<levelUncheckedCreateWithoutParentInput>>
    connectOrCreate?: Enumerable<levelCreateOrConnectWithoutParentInput>
    createMany?: levelCreateManyParentInputEnvelope
    connect?: Enumerable<levelWhereUniqueInput>
  }

  export type levelUpdateOneWithoutChildInput = {
    create?: XOR<levelCreateWithoutChildInput, levelUncheckedCreateWithoutChildInput>
    connectOrCreate?: levelCreateOrConnectWithoutChildInput
    upsert?: levelUpsertWithoutChildInput
    disconnect?: boolean
    delete?: boolean
    connect?: levelWhereUniqueInput
    update?: XOR<levelUpdateWithoutChildInput, levelUncheckedUpdateWithoutChildInput>
  }

  export type levelUpdateManyWithoutParentInput = {
    create?: XOR<Enumerable<levelCreateWithoutParentInput>, Enumerable<levelUncheckedCreateWithoutParentInput>>
    connectOrCreate?: Enumerable<levelCreateOrConnectWithoutParentInput>
    upsert?: Enumerable<levelUpsertWithWhereUniqueWithoutParentInput>
    createMany?: levelCreateManyParentInputEnvelope
    set?: Enumerable<levelWhereUniqueInput>
    disconnect?: Enumerable<levelWhereUniqueInput>
    delete?: Enumerable<levelWhereUniqueInput>
    connect?: Enumerable<levelWhereUniqueInput>
    update?: Enumerable<levelUpdateWithWhereUniqueWithoutParentInput>
    updateMany?: Enumerable<levelUpdateManyWithWhereWithoutParentInput>
    deleteMany?: Enumerable<levelScalarWhereInput>
  }

  export type level_typeUpdateOneRequiredWithoutLevelInput = {
    create?: XOR<level_typeCreateWithoutLevelInput, level_typeUncheckedCreateWithoutLevelInput>
    connectOrCreate?: level_typeCreateOrConnectWithoutLevelInput
    upsert?: level_typeUpsertWithoutLevelInput
    connect?: level_typeWhereUniqueInput
    update?: XOR<level_typeUpdateWithoutLevelInput, level_typeUncheckedUpdateWithoutLevelInput>
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type levelUncheckedUpdateManyWithoutParentInput = {
    create?: XOR<Enumerable<levelCreateWithoutParentInput>, Enumerable<levelUncheckedCreateWithoutParentInput>>
    connectOrCreate?: Enumerable<levelCreateOrConnectWithoutParentInput>
    upsert?: Enumerable<levelUpsertWithWhereUniqueWithoutParentInput>
    createMany?: levelCreateManyParentInputEnvelope
    set?: Enumerable<levelWhereUniqueInput>
    disconnect?: Enumerable<levelWhereUniqueInput>
    delete?: Enumerable<levelWhereUniqueInput>
    connect?: Enumerable<levelWhereUniqueInput>
    update?: Enumerable<levelUpdateWithWhereUniqueWithoutParentInput>
    updateMany?: Enumerable<levelUpdateManyWithWhereWithoutParentInput>
    deleteMany?: Enumerable<levelScalarWhereInput>
  }

  export type levelCreateNestedManyWithoutLevel_typeInput = {
    create?: XOR<Enumerable<levelCreateWithoutLevel_typeInput>, Enumerable<levelUncheckedCreateWithoutLevel_typeInput>>
    connectOrCreate?: Enumerable<levelCreateOrConnectWithoutLevel_typeInput>
    createMany?: levelCreateManyLevel_typeInputEnvelope
    connect?: Enumerable<levelWhereUniqueInput>
  }

  export type levelUncheckedCreateNestedManyWithoutLevel_typeInput = {
    create?: XOR<Enumerable<levelCreateWithoutLevel_typeInput>, Enumerable<levelUncheckedCreateWithoutLevel_typeInput>>
    connectOrCreate?: Enumerable<levelCreateOrConnectWithoutLevel_typeInput>
    createMany?: levelCreateManyLevel_typeInputEnvelope
    connect?: Enumerable<levelWhereUniqueInput>
  }

  export type levelUpdateManyWithoutLevel_typeInput = {
    create?: XOR<Enumerable<levelCreateWithoutLevel_typeInput>, Enumerable<levelUncheckedCreateWithoutLevel_typeInput>>
    connectOrCreate?: Enumerable<levelCreateOrConnectWithoutLevel_typeInput>
    upsert?: Enumerable<levelUpsertWithWhereUniqueWithoutLevel_typeInput>
    createMany?: levelCreateManyLevel_typeInputEnvelope
    set?: Enumerable<levelWhereUniqueInput>
    disconnect?: Enumerable<levelWhereUniqueInput>
    delete?: Enumerable<levelWhereUniqueInput>
    connect?: Enumerable<levelWhereUniqueInput>
    update?: Enumerable<levelUpdateWithWhereUniqueWithoutLevel_typeInput>
    updateMany?: Enumerable<levelUpdateManyWithWhereWithoutLevel_typeInput>
    deleteMany?: Enumerable<levelScalarWhereInput>
  }

  export type levelUncheckedUpdateManyWithoutLevel_typeInput = {
    create?: XOR<Enumerable<levelCreateWithoutLevel_typeInput>, Enumerable<levelUncheckedCreateWithoutLevel_typeInput>>
    connectOrCreate?: Enumerable<levelCreateOrConnectWithoutLevel_typeInput>
    upsert?: Enumerable<levelUpsertWithWhereUniqueWithoutLevel_typeInput>
    createMany?: levelCreateManyLevel_typeInputEnvelope
    set?: Enumerable<levelWhereUniqueInput>
    disconnect?: Enumerable<levelWhereUniqueInput>
    delete?: Enumerable<levelWhereUniqueInput>
    connect?: Enumerable<levelWhereUniqueInput>
    update?: Enumerable<levelUpdateWithWhereUniqueWithoutLevel_typeInput>
    updateMany?: Enumerable<levelUpdateManyWithWhereWithoutLevel_typeInput>
    deleteMany?: Enumerable<levelScalarWhereInput>
  }

  export type NestedIntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type NestedStringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringFilter | string
  }

  export type NestedBoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type NestedIntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type NestedFloatFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatFilter | number
  }

  export type NestedStringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type NestedBoolWithAggregatesFilter = {
    equals?: boolean
    not?: NestedBoolWithAggregatesFilter | boolean
    _count?: NestedIntFilter
    _min?: NestedBoolFilter
    _max?: NestedBoolFilter
  }

  export type NestedStringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableFilter | string | null
  }

  export type NestedDateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type NestedStringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type NestedIntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type NestedDateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type NestedDecimalFilter = {
    equals?: Decimal | number | string
    in?: Enumerable<Decimal> | Enumerable<number> | Enumerable<string>
    notIn?: Enumerable<Decimal> | Enumerable<number> | Enumerable<string>
    lt?: Decimal | number | string
    lte?: Decimal | number | string
    gt?: Decimal | number | string
    gte?: Decimal | number | string
    not?: NestedDecimalFilter | Decimal | number | string
  }

  export type NestedDecimalWithAggregatesFilter = {
    equals?: Decimal | number | string
    in?: Enumerable<Decimal> | Enumerable<number> | Enumerable<string>
    notIn?: Enumerable<Decimal> | Enumerable<number> | Enumerable<string>
    lt?: Decimal | number | string
    lte?: Decimal | number | string
    gt?: Decimal | number | string
    gte?: Decimal | number | string
    not?: NestedDecimalWithAggregatesFilter | Decimal | number | string
    _count?: NestedIntFilter
    _avg?: NestedDecimalFilter
    _sum?: NestedDecimalFilter
    _min?: NestedDecimalFilter
    _max?: NestedDecimalFilter
  }

  export type NestedIntNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedIntNullableFilter
    _min?: NestedIntNullableFilter
    _max?: NestedIntNullableFilter
  }

  export type NestedFloatNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableFilter | number | null
  }

  export type userCreateWithoutUser_roleInput = {
    name?: string | null
    lastnames?: string | null
    email: string
    password: string
    created_at?: Date | string
    updated_at?: Date | string
    user_status: user_statusCreateNestedOneWithoutUserInput
    acces_log?: acces_logCreateNestedManyWithoutUserInput
    recover_password_log?: recover_password_logCreateNestedManyWithoutUserInput
    media?: mediaCreateNestedManyWithoutUserInput
    ads?: adsCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutUser_roleInput = {
    id?: number
    name?: string | null
    lastnames?: string | null
    email: string
    password: string
    created_at?: Date | string
    updated_at?: Date | string
    user_status_id: number
    acces_log?: acces_logUncheckedCreateNestedManyWithoutUserInput
    recover_password_log?: recover_password_logUncheckedCreateNestedManyWithoutUserInput
    media?: mediaUncheckedCreateNestedManyWithoutUserInput
    ads?: adsUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutUser_roleInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutUser_roleInput, userUncheckedCreateWithoutUser_roleInput>
  }

  export type userCreateManyUser_roleInputEnvelope = {
    data: Enumerable<userCreateManyUser_roleInput>
    skipDuplicates?: boolean
  }

  export type userUpsertWithWhereUniqueWithoutUser_roleInput = {
    where: userWhereUniqueInput
    update: XOR<userUpdateWithoutUser_roleInput, userUncheckedUpdateWithoutUser_roleInput>
    create: XOR<userCreateWithoutUser_roleInput, userUncheckedCreateWithoutUser_roleInput>
  }

  export type userUpdateWithWhereUniqueWithoutUser_roleInput = {
    where: userWhereUniqueInput
    data: XOR<userUpdateWithoutUser_roleInput, userUncheckedUpdateWithoutUser_roleInput>
  }

  export type userUpdateManyWithWhereWithoutUser_roleInput = {
    where: userScalarWhereInput
    data: XOR<userUpdateManyMutationInput, userUncheckedUpdateManyWithoutUserInput>
  }

  export type userScalarWhereInput = {
    AND?: Enumerable<userScalarWhereInput>
    OR?: Enumerable<userScalarWhereInput>
    NOT?: Enumerable<userScalarWhereInput>
    id?: IntFilter | number
    name?: StringNullableFilter | string | null
    lastnames?: StringNullableFilter | string | null
    email?: StringFilter | string
    password?: StringFilter | string
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    user_status_id?: IntFilter | number
    user_role_id?: IntFilter | number
  }

  export type userCreateWithoutUser_statusInput = {
    name?: string | null
    lastnames?: string | null
    email: string
    password: string
    created_at?: Date | string
    updated_at?: Date | string
    user_role: user_roleCreateNestedOneWithoutUserInput
    acces_log?: acces_logCreateNestedManyWithoutUserInput
    recover_password_log?: recover_password_logCreateNestedManyWithoutUserInput
    media?: mediaCreateNestedManyWithoutUserInput
    ads?: adsCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutUser_statusInput = {
    id?: number
    name?: string | null
    lastnames?: string | null
    email: string
    password: string
    created_at?: Date | string
    updated_at?: Date | string
    user_role_id: number
    acces_log?: acces_logUncheckedCreateNestedManyWithoutUserInput
    recover_password_log?: recover_password_logUncheckedCreateNestedManyWithoutUserInput
    media?: mediaUncheckedCreateNestedManyWithoutUserInput
    ads?: adsUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutUser_statusInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutUser_statusInput, userUncheckedCreateWithoutUser_statusInput>
  }

  export type userCreateManyUser_statusInputEnvelope = {
    data: Enumerable<userCreateManyUser_statusInput>
    skipDuplicates?: boolean
  }

  export type userUpsertWithWhereUniqueWithoutUser_statusInput = {
    where: userWhereUniqueInput
    update: XOR<userUpdateWithoutUser_statusInput, userUncheckedUpdateWithoutUser_statusInput>
    create: XOR<userCreateWithoutUser_statusInput, userUncheckedCreateWithoutUser_statusInput>
  }

  export type userUpdateWithWhereUniqueWithoutUser_statusInput = {
    where: userWhereUniqueInput
    data: XOR<userUpdateWithoutUser_statusInput, userUncheckedUpdateWithoutUser_statusInput>
  }

  export type userUpdateManyWithWhereWithoutUser_statusInput = {
    where: userScalarWhereInput
    data: XOR<userUpdateManyMutationInput, userUncheckedUpdateManyWithoutUserInput>
  }

  export type user_statusCreateWithoutUserInput = {
    name: string
    active?: boolean
    pending?: boolean
    suspended?: boolean
    deleted?: boolean
  }

  export type user_statusUncheckedCreateWithoutUserInput = {
    id?: number
    name: string
    active?: boolean
    pending?: boolean
    suspended?: boolean
    deleted?: boolean
  }

  export type user_statusCreateOrConnectWithoutUserInput = {
    where: user_statusWhereUniqueInput
    create: XOR<user_statusCreateWithoutUserInput, user_statusUncheckedCreateWithoutUserInput>
  }

  export type user_roleCreateWithoutUserInput = {
    name: string
    admin?: boolean
    manager?: boolean
    registered?: boolean
  }

  export type user_roleUncheckedCreateWithoutUserInput = {
    id?: number
    name: string
    admin?: boolean
    manager?: boolean
    registered?: boolean
  }

  export type user_roleCreateOrConnectWithoutUserInput = {
    where: user_roleWhereUniqueInput
    create: XOR<user_roleCreateWithoutUserInput, user_roleUncheckedCreateWithoutUserInput>
  }

  export type acces_logCreateWithoutUserInput = {
    login: Date | string
    logout: Date | string
  }

  export type acces_logUncheckedCreateWithoutUserInput = {
    id?: number
    login: Date | string
    logout: Date | string
  }

  export type acces_logCreateOrConnectWithoutUserInput = {
    where: acces_logWhereUniqueInput
    create: XOR<acces_logCreateWithoutUserInput, acces_logUncheckedCreateWithoutUserInput>
  }

  export type acces_logCreateManyUserInputEnvelope = {
    data: Enumerable<acces_logCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type recover_password_logCreateWithoutUserInput = {
    created_at?: Date | string
    password: string
  }

  export type recover_password_logUncheckedCreateWithoutUserInput = {
    id?: number
    created_at?: Date | string
    password: string
  }

  export type recover_password_logCreateOrConnectWithoutUserInput = {
    where: recover_password_logWhereUniqueInput
    create: XOR<recover_password_logCreateWithoutUserInput, recover_password_logUncheckedCreateWithoutUserInput>
  }

  export type recover_password_logCreateManyUserInputEnvelope = {
    data: Enumerable<recover_password_logCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type mediaCreateWithoutUserInput = {
    path: string
    mime_type: string
    file_size: string
    media_meta?: media_metaCreateNestedManyWithoutMediaInput
  }

  export type mediaUncheckedCreateWithoutUserInput = {
    id?: number
    path: string
    mime_type: string
    file_size: string
    media_meta?: media_metaUncheckedCreateNestedManyWithoutMediaInput
  }

  export type mediaCreateOrConnectWithoutUserInput = {
    where: mediaWhereUniqueInput
    create: XOR<mediaCreateWithoutUserInput, mediaUncheckedCreateWithoutUserInput>
  }

  export type mediaCreateManyUserInputEnvelope = {
    data: Enumerable<mediaCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type adsCreateWithoutUserInput = {
    title: string
    description: string
    city: string
    n_rooms: number
    price: number
    square_meters: number
    n_bathrooms: number
    map_lat: Decimal | number | string
    map_lon: Decimal | number | string
    ad_type: ad_typeCreateNestedOneWithoutAdsInput
  }

  export type adsUncheckedCreateWithoutUserInput = {
    id?: number
    title: string
    description: string
    city: string
    n_rooms: number
    price: number
    square_meters: number
    n_bathrooms: number
    map_lat: Decimal | number | string
    map_lon: Decimal | number | string
    ad_type_id: number
  }

  export type adsCreateOrConnectWithoutUserInput = {
    where: adsWhereUniqueInput
    create: XOR<adsCreateWithoutUserInput, adsUncheckedCreateWithoutUserInput>
  }

  export type adsCreateManyUserInputEnvelope = {
    data: Enumerable<adsCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type user_statusUpsertWithoutUserInput = {
    update: XOR<user_statusUpdateWithoutUserInput, user_statusUncheckedUpdateWithoutUserInput>
    create: XOR<user_statusCreateWithoutUserInput, user_statusUncheckedCreateWithoutUserInput>
  }

  export type user_statusUpdateWithoutUserInput = {
    name?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    pending?: BoolFieldUpdateOperationsInput | boolean
    suspended?: BoolFieldUpdateOperationsInput | boolean
    deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type user_statusUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    pending?: BoolFieldUpdateOperationsInput | boolean
    suspended?: BoolFieldUpdateOperationsInput | boolean
    deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type user_roleUpsertWithoutUserInput = {
    update: XOR<user_roleUpdateWithoutUserInput, user_roleUncheckedUpdateWithoutUserInput>
    create: XOR<user_roleCreateWithoutUserInput, user_roleUncheckedCreateWithoutUserInput>
  }

  export type user_roleUpdateWithoutUserInput = {
    name?: StringFieldUpdateOperationsInput | string
    admin?: BoolFieldUpdateOperationsInput | boolean
    manager?: BoolFieldUpdateOperationsInput | boolean
    registered?: BoolFieldUpdateOperationsInput | boolean
  }

  export type user_roleUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    admin?: BoolFieldUpdateOperationsInput | boolean
    manager?: BoolFieldUpdateOperationsInput | boolean
    registered?: BoolFieldUpdateOperationsInput | boolean
  }

  export type acces_logUpsertWithWhereUniqueWithoutUserInput = {
    where: acces_logWhereUniqueInput
    update: XOR<acces_logUpdateWithoutUserInput, acces_logUncheckedUpdateWithoutUserInput>
    create: XOR<acces_logCreateWithoutUserInput, acces_logUncheckedCreateWithoutUserInput>
  }

  export type acces_logUpdateWithWhereUniqueWithoutUserInput = {
    where: acces_logWhereUniqueInput
    data: XOR<acces_logUpdateWithoutUserInput, acces_logUncheckedUpdateWithoutUserInput>
  }

  export type acces_logUpdateManyWithWhereWithoutUserInput = {
    where: acces_logScalarWhereInput
    data: XOR<acces_logUpdateManyMutationInput, acces_logUncheckedUpdateManyWithoutAcces_logInput>
  }

  export type acces_logScalarWhereInput = {
    AND?: Enumerable<acces_logScalarWhereInput>
    OR?: Enumerable<acces_logScalarWhereInput>
    NOT?: Enumerable<acces_logScalarWhereInput>
    id?: IntFilter | number
    login?: DateTimeFilter | Date | string
    logout?: DateTimeFilter | Date | string
    user_id?: IntFilter | number
  }

  export type recover_password_logUpsertWithWhereUniqueWithoutUserInput = {
    where: recover_password_logWhereUniqueInput
    update: XOR<recover_password_logUpdateWithoutUserInput, recover_password_logUncheckedUpdateWithoutUserInput>
    create: XOR<recover_password_logCreateWithoutUserInput, recover_password_logUncheckedCreateWithoutUserInput>
  }

  export type recover_password_logUpdateWithWhereUniqueWithoutUserInput = {
    where: recover_password_logWhereUniqueInput
    data: XOR<recover_password_logUpdateWithoutUserInput, recover_password_logUncheckedUpdateWithoutUserInput>
  }

  export type recover_password_logUpdateManyWithWhereWithoutUserInput = {
    where: recover_password_logScalarWhereInput
    data: XOR<recover_password_logUpdateManyMutationInput, recover_password_logUncheckedUpdateManyWithoutRecover_password_logInput>
  }

  export type recover_password_logScalarWhereInput = {
    AND?: Enumerable<recover_password_logScalarWhereInput>
    OR?: Enumerable<recover_password_logScalarWhereInput>
    NOT?: Enumerable<recover_password_logScalarWhereInput>
    id?: IntFilter | number
    created_at?: DateTimeFilter | Date | string
    password?: StringFilter | string
    user_id?: IntFilter | number
  }

  export type mediaUpsertWithWhereUniqueWithoutUserInput = {
    where: mediaWhereUniqueInput
    update: XOR<mediaUpdateWithoutUserInput, mediaUncheckedUpdateWithoutUserInput>
    create: XOR<mediaCreateWithoutUserInput, mediaUncheckedCreateWithoutUserInput>
  }

  export type mediaUpdateWithWhereUniqueWithoutUserInput = {
    where: mediaWhereUniqueInput
    data: XOR<mediaUpdateWithoutUserInput, mediaUncheckedUpdateWithoutUserInput>
  }

  export type mediaUpdateManyWithWhereWithoutUserInput = {
    where: mediaScalarWhereInput
    data: XOR<mediaUpdateManyMutationInput, mediaUncheckedUpdateManyWithoutMediaInput>
  }

  export type mediaScalarWhereInput = {
    AND?: Enumerable<mediaScalarWhereInput>
    OR?: Enumerable<mediaScalarWhereInput>
    NOT?: Enumerable<mediaScalarWhereInput>
    id?: IntFilter | number
    path?: StringFilter | string
    mime_type?: StringFilter | string
    file_size?: StringFilter | string
    user_id?: IntFilter | number
  }

  export type adsUpsertWithWhereUniqueWithoutUserInput = {
    where: adsWhereUniqueInput
    update: XOR<adsUpdateWithoutUserInput, adsUncheckedUpdateWithoutUserInput>
    create: XOR<adsCreateWithoutUserInput, adsUncheckedCreateWithoutUserInput>
  }

  export type adsUpdateWithWhereUniqueWithoutUserInput = {
    where: adsWhereUniqueInput
    data: XOR<adsUpdateWithoutUserInput, adsUncheckedUpdateWithoutUserInput>
  }

  export type adsUpdateManyWithWhereWithoutUserInput = {
    where: adsScalarWhereInput
    data: XOR<adsUpdateManyMutationInput, adsUncheckedUpdateManyWithoutAdsInput>
  }

  export type adsScalarWhereInput = {
    AND?: Enumerable<adsScalarWhereInput>
    OR?: Enumerable<adsScalarWhereInput>
    NOT?: Enumerable<adsScalarWhereInput>
    id?: IntFilter | number
    user_id?: IntFilter | number
    title?: StringFilter | string
    description?: StringFilter | string
    city?: StringFilter | string
    n_rooms?: IntFilter | number
    price?: IntFilter | number
    square_meters?: IntFilter | number
    n_bathrooms?: IntFilter | number
    map_lat?: DecimalFilter | Decimal | number | string
    map_lon?: DecimalFilter | Decimal | number | string
    ad_type_id?: IntFilter | number
  }

  export type userCreateWithoutAcces_logInput = {
    name?: string | null
    lastnames?: string | null
    email: string
    password: string
    created_at?: Date | string
    updated_at?: Date | string
    user_status: user_statusCreateNestedOneWithoutUserInput
    user_role: user_roleCreateNestedOneWithoutUserInput
    recover_password_log?: recover_password_logCreateNestedManyWithoutUserInput
    media?: mediaCreateNestedManyWithoutUserInput
    ads?: adsCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutAcces_logInput = {
    id?: number
    name?: string | null
    lastnames?: string | null
    email: string
    password: string
    created_at?: Date | string
    updated_at?: Date | string
    user_status_id: number
    user_role_id: number
    recover_password_log?: recover_password_logUncheckedCreateNestedManyWithoutUserInput
    media?: mediaUncheckedCreateNestedManyWithoutUserInput
    ads?: adsUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutAcces_logInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutAcces_logInput, userUncheckedCreateWithoutAcces_logInput>
  }

  export type userUpsertWithoutAcces_logInput = {
    update: XOR<userUpdateWithoutAcces_logInput, userUncheckedUpdateWithoutAcces_logInput>
    create: XOR<userCreateWithoutAcces_logInput, userUncheckedCreateWithoutAcces_logInput>
  }

  export type userUpdateWithoutAcces_logInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    lastnames?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user_status?: user_statusUpdateOneRequiredWithoutUserInput
    user_role?: user_roleUpdateOneRequiredWithoutUserInput
    recover_password_log?: recover_password_logUpdateManyWithoutUserInput
    media?: mediaUpdateManyWithoutUserInput
    ads?: adsUpdateManyWithoutUserInput
  }

  export type userUncheckedUpdateWithoutAcces_logInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    lastnames?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user_status_id?: IntFieldUpdateOperationsInput | number
    user_role_id?: IntFieldUpdateOperationsInput | number
    recover_password_log?: recover_password_logUncheckedUpdateManyWithoutUserInput
    media?: mediaUncheckedUpdateManyWithoutUserInput
    ads?: adsUncheckedUpdateManyWithoutUserInput
  }

  export type userCreateWithoutRecover_password_logInput = {
    name?: string | null
    lastnames?: string | null
    email: string
    password: string
    created_at?: Date | string
    updated_at?: Date | string
    user_status: user_statusCreateNestedOneWithoutUserInput
    user_role: user_roleCreateNestedOneWithoutUserInput
    acces_log?: acces_logCreateNestedManyWithoutUserInput
    media?: mediaCreateNestedManyWithoutUserInput
    ads?: adsCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutRecover_password_logInput = {
    id?: number
    name?: string | null
    lastnames?: string | null
    email: string
    password: string
    created_at?: Date | string
    updated_at?: Date | string
    user_status_id: number
    user_role_id: number
    acces_log?: acces_logUncheckedCreateNestedManyWithoutUserInput
    media?: mediaUncheckedCreateNestedManyWithoutUserInput
    ads?: adsUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutRecover_password_logInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutRecover_password_logInput, userUncheckedCreateWithoutRecover_password_logInput>
  }

  export type userUpsertWithoutRecover_password_logInput = {
    update: XOR<userUpdateWithoutRecover_password_logInput, userUncheckedUpdateWithoutRecover_password_logInput>
    create: XOR<userCreateWithoutRecover_password_logInput, userUncheckedCreateWithoutRecover_password_logInput>
  }

  export type userUpdateWithoutRecover_password_logInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    lastnames?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user_status?: user_statusUpdateOneRequiredWithoutUserInput
    user_role?: user_roleUpdateOneRequiredWithoutUserInput
    acces_log?: acces_logUpdateManyWithoutUserInput
    media?: mediaUpdateManyWithoutUserInput
    ads?: adsUpdateManyWithoutUserInput
  }

  export type userUncheckedUpdateWithoutRecover_password_logInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    lastnames?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user_status_id?: IntFieldUpdateOperationsInput | number
    user_role_id?: IntFieldUpdateOperationsInput | number
    acces_log?: acces_logUncheckedUpdateManyWithoutUserInput
    media?: mediaUncheckedUpdateManyWithoutUserInput
    ads?: adsUncheckedUpdateManyWithoutUserInput
  }

  export type userCreateWithoutMediaInput = {
    name?: string | null
    lastnames?: string | null
    email: string
    password: string
    created_at?: Date | string
    updated_at?: Date | string
    user_status: user_statusCreateNestedOneWithoutUserInput
    user_role: user_roleCreateNestedOneWithoutUserInput
    acces_log?: acces_logCreateNestedManyWithoutUserInput
    recover_password_log?: recover_password_logCreateNestedManyWithoutUserInput
    ads?: adsCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutMediaInput = {
    id?: number
    name?: string | null
    lastnames?: string | null
    email: string
    password: string
    created_at?: Date | string
    updated_at?: Date | string
    user_status_id: number
    user_role_id: number
    acces_log?: acces_logUncheckedCreateNestedManyWithoutUserInput
    recover_password_log?: recover_password_logUncheckedCreateNestedManyWithoutUserInput
    ads?: adsUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutMediaInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutMediaInput, userUncheckedCreateWithoutMediaInput>
  }

  export type media_metaCreateWithoutMediaInput = {
    path: string
    mime_type: string
    file_size: string
    media_type: media_typeCreateNestedOneWithoutMedia_metaInput
  }

  export type media_metaUncheckedCreateWithoutMediaInput = {
    id?: number
    path: string
    mime_type: string
    file_size: string
    media_type_id: number
  }

  export type media_metaCreateOrConnectWithoutMediaInput = {
    where: media_metaWhereUniqueInput
    create: XOR<media_metaCreateWithoutMediaInput, media_metaUncheckedCreateWithoutMediaInput>
  }

  export type media_metaCreateManyMediaInputEnvelope = {
    data: Enumerable<media_metaCreateManyMediaInput>
    skipDuplicates?: boolean
  }

  export type userUpsertWithoutMediaInput = {
    update: XOR<userUpdateWithoutMediaInput, userUncheckedUpdateWithoutMediaInput>
    create: XOR<userCreateWithoutMediaInput, userUncheckedCreateWithoutMediaInput>
  }

  export type userUpdateWithoutMediaInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    lastnames?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user_status?: user_statusUpdateOneRequiredWithoutUserInput
    user_role?: user_roleUpdateOneRequiredWithoutUserInput
    acces_log?: acces_logUpdateManyWithoutUserInput
    recover_password_log?: recover_password_logUpdateManyWithoutUserInput
    ads?: adsUpdateManyWithoutUserInput
  }

  export type userUncheckedUpdateWithoutMediaInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    lastnames?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user_status_id?: IntFieldUpdateOperationsInput | number
    user_role_id?: IntFieldUpdateOperationsInput | number
    acces_log?: acces_logUncheckedUpdateManyWithoutUserInput
    recover_password_log?: recover_password_logUncheckedUpdateManyWithoutUserInput
    ads?: adsUncheckedUpdateManyWithoutUserInput
  }

  export type media_metaUpsertWithWhereUniqueWithoutMediaInput = {
    where: media_metaWhereUniqueInput
    update: XOR<media_metaUpdateWithoutMediaInput, media_metaUncheckedUpdateWithoutMediaInput>
    create: XOR<media_metaCreateWithoutMediaInput, media_metaUncheckedCreateWithoutMediaInput>
  }

  export type media_metaUpdateWithWhereUniqueWithoutMediaInput = {
    where: media_metaWhereUniqueInput
    data: XOR<media_metaUpdateWithoutMediaInput, media_metaUncheckedUpdateWithoutMediaInput>
  }

  export type media_metaUpdateManyWithWhereWithoutMediaInput = {
    where: media_metaScalarWhereInput
    data: XOR<media_metaUpdateManyMutationInput, media_metaUncheckedUpdateManyWithoutMedia_metaInput>
  }

  export type media_metaScalarWhereInput = {
    AND?: Enumerable<media_metaScalarWhereInput>
    OR?: Enumerable<media_metaScalarWhereInput>
    NOT?: Enumerable<media_metaScalarWhereInput>
    id?: IntFilter | number
    path?: StringFilter | string
    mime_type?: StringFilter | string
    file_size?: StringFilter | string
    media_id?: IntFilter | number
    media_type_id?: IntFilter | number
  }

  export type mediaCreateWithoutMedia_metaInput = {
    path: string
    mime_type: string
    file_size: string
    user: userCreateNestedOneWithoutMediaInput
  }

  export type mediaUncheckedCreateWithoutMedia_metaInput = {
    id?: number
    path: string
    mime_type: string
    file_size: string
    user_id: number
  }

  export type mediaCreateOrConnectWithoutMedia_metaInput = {
    where: mediaWhereUniqueInput
    create: XOR<mediaCreateWithoutMedia_metaInput, mediaUncheckedCreateWithoutMedia_metaInput>
  }

  export type media_typeCreateWithoutMedia_metaInput = {
    name: string
    thumnail: boolean
    medium: boolean
    large: boolean
    original: boolean
  }

  export type media_typeUncheckedCreateWithoutMedia_metaInput = {
    id?: number
    name: string
    thumnail: boolean
    medium: boolean
    large: boolean
    original: boolean
  }

  export type media_typeCreateOrConnectWithoutMedia_metaInput = {
    where: media_typeWhereUniqueInput
    create: XOR<media_typeCreateWithoutMedia_metaInput, media_typeUncheckedCreateWithoutMedia_metaInput>
  }

  export type mediaUpsertWithoutMedia_metaInput = {
    update: XOR<mediaUpdateWithoutMedia_metaInput, mediaUncheckedUpdateWithoutMedia_metaInput>
    create: XOR<mediaCreateWithoutMedia_metaInput, mediaUncheckedCreateWithoutMedia_metaInput>
  }

  export type mediaUpdateWithoutMedia_metaInput = {
    path?: StringFieldUpdateOperationsInput | string
    mime_type?: StringFieldUpdateOperationsInput | string
    file_size?: StringFieldUpdateOperationsInput | string
    user?: userUpdateOneRequiredWithoutMediaInput
  }

  export type mediaUncheckedUpdateWithoutMedia_metaInput = {
    id?: IntFieldUpdateOperationsInput | number
    path?: StringFieldUpdateOperationsInput | string
    mime_type?: StringFieldUpdateOperationsInput | string
    file_size?: StringFieldUpdateOperationsInput | string
    user_id?: IntFieldUpdateOperationsInput | number
  }

  export type media_typeUpsertWithoutMedia_metaInput = {
    update: XOR<media_typeUpdateWithoutMedia_metaInput, media_typeUncheckedUpdateWithoutMedia_metaInput>
    create: XOR<media_typeCreateWithoutMedia_metaInput, media_typeUncheckedCreateWithoutMedia_metaInput>
  }

  export type media_typeUpdateWithoutMedia_metaInput = {
    name?: StringFieldUpdateOperationsInput | string
    thumnail?: BoolFieldUpdateOperationsInput | boolean
    medium?: BoolFieldUpdateOperationsInput | boolean
    large?: BoolFieldUpdateOperationsInput | boolean
    original?: BoolFieldUpdateOperationsInput | boolean
  }

  export type media_typeUncheckedUpdateWithoutMedia_metaInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    thumnail?: BoolFieldUpdateOperationsInput | boolean
    medium?: BoolFieldUpdateOperationsInput | boolean
    large?: BoolFieldUpdateOperationsInput | boolean
    original?: BoolFieldUpdateOperationsInput | boolean
  }

  export type media_metaCreateWithoutMedia_typeInput = {
    path: string
    mime_type: string
    file_size: string
    media: mediaCreateNestedOneWithoutMedia_metaInput
  }

  export type media_metaUncheckedCreateWithoutMedia_typeInput = {
    id?: number
    path: string
    mime_type: string
    file_size: string
    media_id: number
  }

  export type media_metaCreateOrConnectWithoutMedia_typeInput = {
    where: media_metaWhereUniqueInput
    create: XOR<media_metaCreateWithoutMedia_typeInput, media_metaUncheckedCreateWithoutMedia_typeInput>
  }

  export type media_metaCreateManyMedia_typeInputEnvelope = {
    data: Enumerable<media_metaCreateManyMedia_typeInput>
    skipDuplicates?: boolean
  }

  export type media_metaUpsertWithWhereUniqueWithoutMedia_typeInput = {
    where: media_metaWhereUniqueInput
    update: XOR<media_metaUpdateWithoutMedia_typeInput, media_metaUncheckedUpdateWithoutMedia_typeInput>
    create: XOR<media_metaCreateWithoutMedia_typeInput, media_metaUncheckedCreateWithoutMedia_typeInput>
  }

  export type media_metaUpdateWithWhereUniqueWithoutMedia_typeInput = {
    where: media_metaWhereUniqueInput
    data: XOR<media_metaUpdateWithoutMedia_typeInput, media_metaUncheckedUpdateWithoutMedia_typeInput>
  }

  export type media_metaUpdateManyWithWhereWithoutMedia_typeInput = {
    where: media_metaScalarWhereInput
    data: XOR<media_metaUpdateManyMutationInput, media_metaUncheckedUpdateManyWithoutMedia_metaInput>
  }

  export type adsCreateWithoutAd_typeInput = {
    title: string
    description: string
    city: string
    n_rooms: number
    price: number
    square_meters: number
    n_bathrooms: number
    map_lat: Decimal | number | string
    map_lon: Decimal | number | string
    user: userCreateNestedOneWithoutAdsInput
  }

  export type adsUncheckedCreateWithoutAd_typeInput = {
    id?: number
    user_id: number
    title: string
    description: string
    city: string
    n_rooms: number
    price: number
    square_meters: number
    n_bathrooms: number
    map_lat: Decimal | number | string
    map_lon: Decimal | number | string
  }

  export type adsCreateOrConnectWithoutAd_typeInput = {
    where: adsWhereUniqueInput
    create: XOR<adsCreateWithoutAd_typeInput, adsUncheckedCreateWithoutAd_typeInput>
  }

  export type adsCreateManyAd_typeInputEnvelope = {
    data: Enumerable<adsCreateManyAd_typeInput>
    skipDuplicates?: boolean
  }

  export type adsUpsertWithWhereUniqueWithoutAd_typeInput = {
    where: adsWhereUniqueInput
    update: XOR<adsUpdateWithoutAd_typeInput, adsUncheckedUpdateWithoutAd_typeInput>
    create: XOR<adsCreateWithoutAd_typeInput, adsUncheckedCreateWithoutAd_typeInput>
  }

  export type adsUpdateWithWhereUniqueWithoutAd_typeInput = {
    where: adsWhereUniqueInput
    data: XOR<adsUpdateWithoutAd_typeInput, adsUncheckedUpdateWithoutAd_typeInput>
  }

  export type adsUpdateManyWithWhereWithoutAd_typeInput = {
    where: adsScalarWhereInput
    data: XOR<adsUpdateManyMutationInput, adsUncheckedUpdateManyWithoutAdsInput>
  }

  export type userCreateWithoutAdsInput = {
    name?: string | null
    lastnames?: string | null
    email: string
    password: string
    created_at?: Date | string
    updated_at?: Date | string
    user_status: user_statusCreateNestedOneWithoutUserInput
    user_role: user_roleCreateNestedOneWithoutUserInput
    acces_log?: acces_logCreateNestedManyWithoutUserInput
    recover_password_log?: recover_password_logCreateNestedManyWithoutUserInput
    media?: mediaCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutAdsInput = {
    id?: number
    name?: string | null
    lastnames?: string | null
    email: string
    password: string
    created_at?: Date | string
    updated_at?: Date | string
    user_status_id: number
    user_role_id: number
    acces_log?: acces_logUncheckedCreateNestedManyWithoutUserInput
    recover_password_log?: recover_password_logUncheckedCreateNestedManyWithoutUserInput
    media?: mediaUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutAdsInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutAdsInput, userUncheckedCreateWithoutAdsInput>
  }

  export type ad_typeCreateWithoutAdsInput = {
    name: string
    house: number
    room: number
    garage: number
    storage: number
    office: number
    warehouse: number
    building: number
    new_building: number
  }

  export type ad_typeUncheckedCreateWithoutAdsInput = {
    id?: number
    name: string
    house: number
    room: number
    garage: number
    storage: number
    office: number
    warehouse: number
    building: number
    new_building: number
  }

  export type ad_typeCreateOrConnectWithoutAdsInput = {
    where: ad_typeWhereUniqueInput
    create: XOR<ad_typeCreateWithoutAdsInput, ad_typeUncheckedCreateWithoutAdsInput>
  }

  export type userUpsertWithoutAdsInput = {
    update: XOR<userUpdateWithoutAdsInput, userUncheckedUpdateWithoutAdsInput>
    create: XOR<userCreateWithoutAdsInput, userUncheckedCreateWithoutAdsInput>
  }

  export type userUpdateWithoutAdsInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    lastnames?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user_status?: user_statusUpdateOneRequiredWithoutUserInput
    user_role?: user_roleUpdateOneRequiredWithoutUserInput
    acces_log?: acces_logUpdateManyWithoutUserInput
    recover_password_log?: recover_password_logUpdateManyWithoutUserInput
    media?: mediaUpdateManyWithoutUserInput
  }

  export type userUncheckedUpdateWithoutAdsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    lastnames?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user_status_id?: IntFieldUpdateOperationsInput | number
    user_role_id?: IntFieldUpdateOperationsInput | number
    acces_log?: acces_logUncheckedUpdateManyWithoutUserInput
    recover_password_log?: recover_password_logUncheckedUpdateManyWithoutUserInput
    media?: mediaUncheckedUpdateManyWithoutUserInput
  }

  export type ad_typeUpsertWithoutAdsInput = {
    update: XOR<ad_typeUpdateWithoutAdsInput, ad_typeUncheckedUpdateWithoutAdsInput>
    create: XOR<ad_typeCreateWithoutAdsInput, ad_typeUncheckedCreateWithoutAdsInput>
  }

  export type ad_typeUpdateWithoutAdsInput = {
    name?: StringFieldUpdateOperationsInput | string
    house?: IntFieldUpdateOperationsInput | number
    room?: IntFieldUpdateOperationsInput | number
    garage?: IntFieldUpdateOperationsInput | number
    storage?: IntFieldUpdateOperationsInput | number
    office?: IntFieldUpdateOperationsInput | number
    warehouse?: IntFieldUpdateOperationsInput | number
    building?: IntFieldUpdateOperationsInput | number
    new_building?: IntFieldUpdateOperationsInput | number
  }

  export type ad_typeUncheckedUpdateWithoutAdsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    house?: IntFieldUpdateOperationsInput | number
    room?: IntFieldUpdateOperationsInput | number
    garage?: IntFieldUpdateOperationsInput | number
    storage?: IntFieldUpdateOperationsInput | number
    office?: IntFieldUpdateOperationsInput | number
    warehouse?: IntFieldUpdateOperationsInput | number
    building?: IntFieldUpdateOperationsInput | number
    new_building?: IntFieldUpdateOperationsInput | number
  }

  export type levelCreateWithoutChildInput = {
    name: string
    parent?: levelCreateNestedOneWithoutChildInput
    level_type: level_typeCreateNestedOneWithoutLevelInput
  }

  export type levelUncheckedCreateWithoutChildInput = {
    id?: number
    name: string
    parent_id?: number | null
    level_type_id: number
  }

  export type levelCreateOrConnectWithoutChildInput = {
    where: levelWhereUniqueInput
    create: XOR<levelCreateWithoutChildInput, levelUncheckedCreateWithoutChildInput>
  }

  export type levelCreateWithoutParentInput = {
    name: string
    child?: levelCreateNestedManyWithoutParentInput
    level_type: level_typeCreateNestedOneWithoutLevelInput
  }

  export type levelUncheckedCreateWithoutParentInput = {
    id?: number
    name: string
    level_type_id: number
    child?: levelUncheckedCreateNestedManyWithoutParentInput
  }

  export type levelCreateOrConnectWithoutParentInput = {
    where: levelWhereUniqueInput
    create: XOR<levelCreateWithoutParentInput, levelUncheckedCreateWithoutParentInput>
  }

  export type levelCreateManyParentInputEnvelope = {
    data: Enumerable<levelCreateManyParentInput>
    skipDuplicates?: boolean
  }

  export type level_typeCreateWithoutLevelInput = {
    name: string
    country: number
    state: number
    city: number
    town: number
    district: number
    neighbourhood: number
  }

  export type level_typeUncheckedCreateWithoutLevelInput = {
    id?: number
    name: string
    country: number
    state: number
    city: number
    town: number
    district: number
    neighbourhood: number
  }

  export type level_typeCreateOrConnectWithoutLevelInput = {
    where: level_typeWhereUniqueInput
    create: XOR<level_typeCreateWithoutLevelInput, level_typeUncheckedCreateWithoutLevelInput>
  }

  export type levelUpsertWithoutChildInput = {
    update: XOR<levelUpdateWithoutChildInput, levelUncheckedUpdateWithoutChildInput>
    create: XOR<levelCreateWithoutChildInput, levelUncheckedCreateWithoutChildInput>
  }

  export type levelUpdateWithoutChildInput = {
    name?: StringFieldUpdateOperationsInput | string
    parent?: levelUpdateOneWithoutChildInput
    level_type?: level_typeUpdateOneRequiredWithoutLevelInput
  }

  export type levelUncheckedUpdateWithoutChildInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    parent_id?: NullableIntFieldUpdateOperationsInput | number | null
    level_type_id?: IntFieldUpdateOperationsInput | number
  }

  export type levelUpsertWithWhereUniqueWithoutParentInput = {
    where: levelWhereUniqueInput
    update: XOR<levelUpdateWithoutParentInput, levelUncheckedUpdateWithoutParentInput>
    create: XOR<levelCreateWithoutParentInput, levelUncheckedCreateWithoutParentInput>
  }

  export type levelUpdateWithWhereUniqueWithoutParentInput = {
    where: levelWhereUniqueInput
    data: XOR<levelUpdateWithoutParentInput, levelUncheckedUpdateWithoutParentInput>
  }

  export type levelUpdateManyWithWhereWithoutParentInput = {
    where: levelScalarWhereInput
    data: XOR<levelUpdateManyMutationInput, levelUncheckedUpdateManyWithoutChildInput>
  }

  export type levelScalarWhereInput = {
    AND?: Enumerable<levelScalarWhereInput>
    OR?: Enumerable<levelScalarWhereInput>
    NOT?: Enumerable<levelScalarWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    parent_id?: IntNullableFilter | number | null
    level_type_id?: IntFilter | number
  }

  export type level_typeUpsertWithoutLevelInput = {
    update: XOR<level_typeUpdateWithoutLevelInput, level_typeUncheckedUpdateWithoutLevelInput>
    create: XOR<level_typeCreateWithoutLevelInput, level_typeUncheckedCreateWithoutLevelInput>
  }

  export type level_typeUpdateWithoutLevelInput = {
    name?: StringFieldUpdateOperationsInput | string
    country?: IntFieldUpdateOperationsInput | number
    state?: IntFieldUpdateOperationsInput | number
    city?: IntFieldUpdateOperationsInput | number
    town?: IntFieldUpdateOperationsInput | number
    district?: IntFieldUpdateOperationsInput | number
    neighbourhood?: IntFieldUpdateOperationsInput | number
  }

  export type level_typeUncheckedUpdateWithoutLevelInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    country?: IntFieldUpdateOperationsInput | number
    state?: IntFieldUpdateOperationsInput | number
    city?: IntFieldUpdateOperationsInput | number
    town?: IntFieldUpdateOperationsInput | number
    district?: IntFieldUpdateOperationsInput | number
    neighbourhood?: IntFieldUpdateOperationsInput | number
  }

  export type levelCreateWithoutLevel_typeInput = {
    name: string
    parent?: levelCreateNestedOneWithoutChildInput
    child?: levelCreateNestedManyWithoutParentInput
  }

  export type levelUncheckedCreateWithoutLevel_typeInput = {
    id?: number
    name: string
    parent_id?: number | null
    child?: levelUncheckedCreateNestedManyWithoutParentInput
  }

  export type levelCreateOrConnectWithoutLevel_typeInput = {
    where: levelWhereUniqueInput
    create: XOR<levelCreateWithoutLevel_typeInput, levelUncheckedCreateWithoutLevel_typeInput>
  }

  export type levelCreateManyLevel_typeInputEnvelope = {
    data: Enumerable<levelCreateManyLevel_typeInput>
    skipDuplicates?: boolean
  }

  export type levelUpsertWithWhereUniqueWithoutLevel_typeInput = {
    where: levelWhereUniqueInput
    update: XOR<levelUpdateWithoutLevel_typeInput, levelUncheckedUpdateWithoutLevel_typeInput>
    create: XOR<levelCreateWithoutLevel_typeInput, levelUncheckedCreateWithoutLevel_typeInput>
  }

  export type levelUpdateWithWhereUniqueWithoutLevel_typeInput = {
    where: levelWhereUniqueInput
    data: XOR<levelUpdateWithoutLevel_typeInput, levelUncheckedUpdateWithoutLevel_typeInput>
  }

  export type levelUpdateManyWithWhereWithoutLevel_typeInput = {
    where: levelScalarWhereInput
    data: XOR<levelUpdateManyMutationInput, levelUncheckedUpdateManyWithoutLevelInput>
  }

  export type userCreateManyUser_roleInput = {
    id?: number
    name?: string | null
    lastnames?: string | null
    email: string
    password: string
    created_at?: Date | string
    updated_at?: Date | string
    user_status_id: number
  }

  export type userUpdateWithoutUser_roleInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    lastnames?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user_status?: user_statusUpdateOneRequiredWithoutUserInput
    acces_log?: acces_logUpdateManyWithoutUserInput
    recover_password_log?: recover_password_logUpdateManyWithoutUserInput
    media?: mediaUpdateManyWithoutUserInput
    ads?: adsUpdateManyWithoutUserInput
  }

  export type userUncheckedUpdateWithoutUser_roleInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    lastnames?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user_status_id?: IntFieldUpdateOperationsInput | number
    acces_log?: acces_logUncheckedUpdateManyWithoutUserInput
    recover_password_log?: recover_password_logUncheckedUpdateManyWithoutUserInput
    media?: mediaUncheckedUpdateManyWithoutUserInput
    ads?: adsUncheckedUpdateManyWithoutUserInput
  }

  export type userUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    lastnames?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user_status_id?: IntFieldUpdateOperationsInput | number
  }

  export type userCreateManyUser_statusInput = {
    id?: number
    name?: string | null
    lastnames?: string | null
    email: string
    password: string
    created_at?: Date | string
    updated_at?: Date | string
    user_role_id: number
  }

  export type userUpdateWithoutUser_statusInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    lastnames?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user_role?: user_roleUpdateOneRequiredWithoutUserInput
    acces_log?: acces_logUpdateManyWithoutUserInput
    recover_password_log?: recover_password_logUpdateManyWithoutUserInput
    media?: mediaUpdateManyWithoutUserInput
    ads?: adsUpdateManyWithoutUserInput
  }

  export type userUncheckedUpdateWithoutUser_statusInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    lastnames?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user_role_id?: IntFieldUpdateOperationsInput | number
    acces_log?: acces_logUncheckedUpdateManyWithoutUserInput
    recover_password_log?: recover_password_logUncheckedUpdateManyWithoutUserInput
    media?: mediaUncheckedUpdateManyWithoutUserInput
    ads?: adsUncheckedUpdateManyWithoutUserInput
  }

  export type acces_logCreateManyUserInput = {
    id?: number
    login: Date | string
    logout: Date | string
  }

  export type recover_password_logCreateManyUserInput = {
    id?: number
    created_at?: Date | string
    password: string
  }

  export type mediaCreateManyUserInput = {
    id?: number
    path: string
    mime_type: string
    file_size: string
  }

  export type adsCreateManyUserInput = {
    id?: number
    title: string
    description: string
    city: string
    n_rooms: number
    price: number
    square_meters: number
    n_bathrooms: number
    map_lat: Decimal | number | string
    map_lon: Decimal | number | string
    ad_type_id: number
  }

  export type acces_logUpdateWithoutUserInput = {
    login?: DateTimeFieldUpdateOperationsInput | Date | string
    logout?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type acces_logUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    login?: DateTimeFieldUpdateOperationsInput | Date | string
    logout?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type acces_logUncheckedUpdateManyWithoutAcces_logInput = {
    id?: IntFieldUpdateOperationsInput | number
    login?: DateTimeFieldUpdateOperationsInput | Date | string
    logout?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type recover_password_logUpdateWithoutUserInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    password?: StringFieldUpdateOperationsInput | string
  }

  export type recover_password_logUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    password?: StringFieldUpdateOperationsInput | string
  }

  export type recover_password_logUncheckedUpdateManyWithoutRecover_password_logInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    password?: StringFieldUpdateOperationsInput | string
  }

  export type mediaUpdateWithoutUserInput = {
    path?: StringFieldUpdateOperationsInput | string
    mime_type?: StringFieldUpdateOperationsInput | string
    file_size?: StringFieldUpdateOperationsInput | string
    media_meta?: media_metaUpdateManyWithoutMediaInput
  }

  export type mediaUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    path?: StringFieldUpdateOperationsInput | string
    mime_type?: StringFieldUpdateOperationsInput | string
    file_size?: StringFieldUpdateOperationsInput | string
    media_meta?: media_metaUncheckedUpdateManyWithoutMediaInput
  }

  export type mediaUncheckedUpdateManyWithoutMediaInput = {
    id?: IntFieldUpdateOperationsInput | number
    path?: StringFieldUpdateOperationsInput | string
    mime_type?: StringFieldUpdateOperationsInput | string
    file_size?: StringFieldUpdateOperationsInput | string
  }

  export type adsUpdateWithoutUserInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    n_rooms?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    square_meters?: IntFieldUpdateOperationsInput | number
    n_bathrooms?: IntFieldUpdateOperationsInput | number
    map_lat?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    map_lon?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    ad_type?: ad_typeUpdateOneRequiredWithoutAdsInput
  }

  export type adsUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    n_rooms?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    square_meters?: IntFieldUpdateOperationsInput | number
    n_bathrooms?: IntFieldUpdateOperationsInput | number
    map_lat?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    map_lon?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    ad_type_id?: IntFieldUpdateOperationsInput | number
  }

  export type adsUncheckedUpdateManyWithoutAdsInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    n_rooms?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    square_meters?: IntFieldUpdateOperationsInput | number
    n_bathrooms?: IntFieldUpdateOperationsInput | number
    map_lat?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    map_lon?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    ad_type_id?: IntFieldUpdateOperationsInput | number
  }

  export type media_metaCreateManyMediaInput = {
    id?: number
    path: string
    mime_type: string
    file_size: string
    media_type_id: number
  }

  export type media_metaUpdateWithoutMediaInput = {
    path?: StringFieldUpdateOperationsInput | string
    mime_type?: StringFieldUpdateOperationsInput | string
    file_size?: StringFieldUpdateOperationsInput | string
    media_type?: media_typeUpdateOneRequiredWithoutMedia_metaInput
  }

  export type media_metaUncheckedUpdateWithoutMediaInput = {
    id?: IntFieldUpdateOperationsInput | number
    path?: StringFieldUpdateOperationsInput | string
    mime_type?: StringFieldUpdateOperationsInput | string
    file_size?: StringFieldUpdateOperationsInput | string
    media_type_id?: IntFieldUpdateOperationsInput | number
  }

  export type media_metaUncheckedUpdateManyWithoutMedia_metaInput = {
    id?: IntFieldUpdateOperationsInput | number
    path?: StringFieldUpdateOperationsInput | string
    mime_type?: StringFieldUpdateOperationsInput | string
    file_size?: StringFieldUpdateOperationsInput | string
    media_type_id?: IntFieldUpdateOperationsInput | number
  }

  export type media_metaCreateManyMedia_typeInput = {
    id?: number
    path: string
    mime_type: string
    file_size: string
    media_id: number
  }

  export type media_metaUpdateWithoutMedia_typeInput = {
    path?: StringFieldUpdateOperationsInput | string
    mime_type?: StringFieldUpdateOperationsInput | string
    file_size?: StringFieldUpdateOperationsInput | string
    media?: mediaUpdateOneRequiredWithoutMedia_metaInput
  }

  export type media_metaUncheckedUpdateWithoutMedia_typeInput = {
    id?: IntFieldUpdateOperationsInput | number
    path?: StringFieldUpdateOperationsInput | string
    mime_type?: StringFieldUpdateOperationsInput | string
    file_size?: StringFieldUpdateOperationsInput | string
    media_id?: IntFieldUpdateOperationsInput | number
  }

  export type adsCreateManyAd_typeInput = {
    id?: number
    user_id: number
    title: string
    description: string
    city: string
    n_rooms: number
    price: number
    square_meters: number
    n_bathrooms: number
    map_lat: Decimal | number | string
    map_lon: Decimal | number | string
  }

  export type adsUpdateWithoutAd_typeInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    n_rooms?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    square_meters?: IntFieldUpdateOperationsInput | number
    n_bathrooms?: IntFieldUpdateOperationsInput | number
    map_lat?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    map_lon?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    user?: userUpdateOneRequiredWithoutAdsInput
  }

  export type adsUncheckedUpdateWithoutAd_typeInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    n_rooms?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    square_meters?: IntFieldUpdateOperationsInput | number
    n_bathrooms?: IntFieldUpdateOperationsInput | number
    map_lat?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    map_lon?: DecimalFieldUpdateOperationsInput | Decimal | number | string
  }

  export type levelCreateManyParentInput = {
    id?: number
    name: string
    level_type_id: number
  }

  export type levelUpdateWithoutParentInput = {
    name?: StringFieldUpdateOperationsInput | string
    child?: levelUpdateManyWithoutParentInput
    level_type?: level_typeUpdateOneRequiredWithoutLevelInput
  }

  export type levelUncheckedUpdateWithoutParentInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    level_type_id?: IntFieldUpdateOperationsInput | number
    child?: levelUncheckedUpdateManyWithoutParentInput
  }

  export type levelUncheckedUpdateManyWithoutChildInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    level_type_id?: IntFieldUpdateOperationsInput | number
  }

  export type levelCreateManyLevel_typeInput = {
    id?: number
    name: string
    parent_id?: number | null
  }

  export type levelUpdateWithoutLevel_typeInput = {
    name?: StringFieldUpdateOperationsInput | string
    parent?: levelUpdateOneWithoutChildInput
    child?: levelUpdateManyWithoutParentInput
  }

  export type levelUncheckedUpdateWithoutLevel_typeInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    parent_id?: NullableIntFieldUpdateOperationsInput | number | null
    child?: levelUncheckedUpdateManyWithoutParentInput
  }

  export type levelUncheckedUpdateManyWithoutLevelInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    parent_id?: NullableIntFieldUpdateOperationsInput | number | null
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.DMMF.Document;
}